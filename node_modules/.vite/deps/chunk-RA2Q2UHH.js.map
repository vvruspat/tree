{
  "version": 3,
  "sources": ["../../pixi.js/src/assets/utils/convertToList.ts", "../../pixi.js/src/assets/cache/Cache.ts"],
  "sourcesContent": ["/**\n * @param input\n * @param transform\n * @param forceTransform\n * @internal\n */\nexport const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n", "import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/** @internal */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set<T = any>(key: any | any[], value: T): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /**\n     * All loader parsers registered\n     * @advanced\n     */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\n/**\n * A global cache for all assets in your PixiJS application. The cache system provides fast\n * access to loaded assets and prevents duplicate loading.\n *\n * Key Features:\n * - Automatic caching of loaded assets\n * - Support for custom cache parsers\n * - Automatic parsing of complex assets (e.g., spritesheets)\n * - Memory management utilities\n * > [!IMPORTANT] You typically do not need to use this class directly.\n * > Use the main {@link Assets} class for high-level asset management.\n * > `Assets.get(key)` will automatically use the cache.\n * @example\n * ```ts\n * import { Cache } from 'pixi.js';\n *\n * // Store an asset in the cache\n * Cache.set('myTexture', texture);\n *\n * // Retrieve an asset\n * const texture = Cache.get('myTexture');\n *\n * // Check if an asset exists\n * if (Cache.has('myTexture')) {\n *     // Use the cached asset\n *     const sprite = new Sprite(Cache.get('myTexture'));\n * }\n *\n * // Remove an asset from cache\n * Cache.remove('myTexture');\n *\n * // Clear all cached assets\n * Cache.reset();\n * ```\n * @remarks\n * The Cache is a core component of PixiJS' asset management system:\n * - Used internally by the {@link Assets} class\n * - Supports automatic parsing via {@link CacheParser}\n * - Handles complex asset types like spritesheets\n * - Manages memory through asset removal\n *\n * > [!IMPORTANT]\n * > This is a singleton class and should not be instantiated directly.\n * > Use the exported `Cache` instance instead.\n * @see {@link Assets} For high-level asset management\n * @see {@link CacheParser} For custom cache parsing\n * @category assets\n * @class\n * @advanced\n */\nexport const Cache = new CacheClass();\n"],
  "mappings": ";;;;;AAMO,IAAM,gBAAgB,CACzB,OACA,WACA,iBAAiB,UAErB;AACI,MAAI,CAAC,MAAM,QAAQ,KAAK,GACxB;AACI,YAAQ,CAAC,KAAU;EACvB;AAEA,MAAI,CAAC,WACL;AACI,WAAO;EACX;AAEA,SAAQ,MAAyB,IAAI,CAAC,SACtC;AACI,QAAI,OAAO,SAAS,YAAY,gBAChC;AACI,aAAO,UAAU,IAAc;IACnC;AAEA,WAAO;EACX,CAAC;AACL;;;ACzBA,IAAM,aAAN,MACA;EADA,cAAA;AAEI,SAAiB,WAA0B,CAAA;AAE3C,SAAiB,SAAA,oBAA4B,IAAA;AAC7C,SAAiB,YAAA,oBAGR,IAAA;EAAI;;EAGN,QACP;AACI,SAAK,UAAU,MAAA;AACf,SAAK,OAAO,MAAA;EAChB;;;;;EAMO,IAAI,KACX;AACI,WAAO,KAAK,OAAO,IAAI,GAAG;EAC9B;;;;;EAMO,IAAa,KACpB;AACI,UAAM,SAAS,KAAK,OAAO,IAAI,GAAG;AAElC,QAAI,CAAC,QACL;AAEI,WAAK,qBAAqB,GAAG,6BAA6B;IAE9D;AAEA,WAAO;EACX;;;;;;EAOO,IAAa,KAAkB,OACtC;AACI,UAAM,OAAO,cAAsB,GAAG;AAEtC,QAAI;AAEJ,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACI,YAAM,SAAS,KAAK,QAAQ,CAAC;AAE7B,UAAI,OAAO,KAAK,KAAK,GACrB;AACI,0BAAkB,OAAO,mBAAmB,MAAM,KAAK;AAEvD;MACJ;IACJ;AAGA,UAAM,eAAe,IAAI,IAAI,OAAO,QAAQ,mBAAmB,CAAA,CAAE,CAAC;AAElE,QAAI,CAAC,iBACL;AACI,WAAK,QAAQ,CAACA,SACd;AACI,qBAAa,IAAIA,MAAK,KAAK;MAC/B,CAAC;IACL;AAEA,UAAM,YAAY,CAAC,GAAG,aAAa,KAAA,CAAM;AAEzC,UAAM,eAAe;MACjB;MACA;IAAA;AAIJ,SAAK,QAAQ,CAACA,SACd;AACI,WAAK,UAAU,IAAIA,MAAK,YAAmB;IAC/C,CAAC;AAED,cAAU,QAAQ,CAACA,SACnB;AACI,YAAM,MAAM,kBAAkB,gBAAgBA,IAAG,IAAI;AAErD,UAAI,KAAK,OAAO,IAAIA,IAAG,KAAK,KAAK,OAAO,IAAIA,IAAG,MAAM,KACrD;AAEI,aAAK,4BAA4BA,IAAG;MAExC;AAEA,WAAK,OAAO,IAAIA,MAAK,aAAa,IAAIA,IAAG,CAAC;IAC9C,CAAC;EACL;;;;;;;EAQO,OAAO,KACd;AACI,QAAI,CAAC,KAAK,UAAU,IAAI,GAAG,GAC3B;AAEI,WAAK,qBAAqB,GAAG,6BAA6B;AAG1D;IACJ;AAEA,UAAM,WAAW,KAAK,UAAU,IAAI,GAAG;AAEvC,UAAM,YAAY,SAAS;AAE3B,cAAU,QAAQ,CAACA,SACnB;AACI,WAAK,OAAO,OAAOA,IAAG;IAC1B,CAAC;AAED,aAAS,KAAK,QAAQ,CAACA,SACvB;AACI,WAAK,UAAU,OAAOA,IAAG;IAC7B,CAAC;EACL;;;;;EAMA,IAAW,UACX;AACI,WAAO,KAAK;EAChB;AACJ;AAoDO,IAAM,QAAQ,IAAI,WAAA;",
  "names": ["key"]
}
