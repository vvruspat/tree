{
  "version": 3,
  "sources": ["../../pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts", "../../pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts", "../../pixi.js/src/maths/shapes/Circle.ts", "../../pixi.js/src/maths/shapes/Ellipse.ts", "../../pixi.js/src/maths/shapes/Polygon.ts", "../../pixi.js/src/maths/shapes/RoundedRectangle.ts"],
  "sourcesContent": ["import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of image-like resource that can be used as a texture source.\n *\n * - `ImageBitmap` is used for bitmap images.\n * - `HTMLCanvasElement` and `OffscreenCanvas` are used for canvas elements.\n * - `ICanvas` is an interface for canvas-like objects.\n * - `VideoFrame` is used for video frames.\n * - `HTMLImageElement` is used for HTML image elements.\n * - `HTMLVideoElement` is used for HTML video elements.\n * @category rendering\n * @advanced\n */\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\n/**\n * A texture source that uses an image-like resource as its resource.\n * It can handle HTMLImageElement, ImageBitmap, VideoFrame, and HTMLVideoElement.\n * It is used for textures that can be uploaded to the GPU.\n * @category rendering\n * @advanced\n */\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap)\n        || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n", "/**\n * Calculates the squared distance from a point to a line segment defined by two endpoints.\n * @param x - x coordinate of the point\n * @param y - y coordinate of the point\n * @param x1 - x coordinate of the first endpoint of the line segment\n * @param y1 - y coordinate of the first endpoint of the line segment\n * @param x2 - x coordinate of the second endpoint of the line segment\n * @param y2 - y coordinate of the second endpoint of the line segment\n * @returns The squared distance from the point to the line segment\n * @category maths\n * @internal\n */\nexport function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object represents a circle shape in a two-dimensional coordinate system.\n * Used for drawing graphics and specifying hit areas for containers.\n * @example\n * ```ts\n * // Basic circle creation\n * const circle = new Circle(100, 100, 50);\n *\n * // Use as hit area\n * container.hitArea = new Circle(0, 0, 100);\n *\n * // Check point containment\n * const isInside = circle.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = circle.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and radius\n * - Supports point containment tests\n * - Can check stroke intersections\n * @see {@link Rectangle} For rectangular shapes\n * @category maths\n * @standard\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const circle = new Circle();\n     * circle.x = 100;\n     *\n     * // Center circle on point\n     * circle.x = point.x;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const circle = new Circle();\n     * circle.y = 200;\n     *\n     * // Center circle on point\n     * circle.y = point.y;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const circle = new Circle(100, 100);\n     * circle.radius = 50;\n     *\n     * // Calculate area\n     * const area = Math.PI * circle.radius * circle.radius;\n     * ```\n     * @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks.\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Circle(0, 0, 50);\n     * console.log(shape.type); // 'circle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'circle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @remarks\n     * - Used for shape type checking\n     * - More efficient than instanceof\n     * - Read-only property\n     * @readonly\n     * @default 'circle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     * @see {@link ShapePrimitive} For shape interface\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance.\n     * @example\n     * ```ts\n     * // Basic circle cloning\n     * const original = new Circle(100, 100, 50);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 75;\n     *\n     * // Verify independence\n     * console.log(original.radius); // 50\n     * console.log(modified.radius); // 75\n     * ```\n     * @returns A copy of the Circle\n     * @see {@link Circle.copyFrom} For copying into existing circle\n     * @see {@link Circle.copyTo} For copying to another circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle.\n     *\n     * Uses the distance formula to determine if a point is inside the circle's radius.\n     *\n     * Commonly used for hit testing in PixiJS events and graphics.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const circle = new Circle(100, 100, 50);\n     * const isInside = circle.contains(120, 120);\n     *\n     * // Check mouse position\n     * const circle = new Circle(0, 0, 100);\n     * container.hitArea = circle;\n     * container.on('pointermove', (e) => {\n     *     // only called if pointer is within circle\n     * });\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     * @see {@link Circle.strokeContains} For checking stroke intersection\n     * @see {@link Circle.getBounds} For getting bounding box\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const circle = new Circle(100, 100, 50);\n     * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this Circle's stroke\n     * @see {@link Circle.contains} For checking fill containment\n     * @see {@link Circle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, width: number, alignment: number = 0.5): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const radius = this.radius;\n        const outerWidth = (1 - alignment) * width;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance <= radius + outerWidth && distance > radius - (width - outerWidth));\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const circle = new Circle(100, 100, 50);\n     * const bounds = circle.getBounds();\n     * // bounds: x=50, y=50, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * circle.getBounds(rect);\n     * ```\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Circle.contains} For point containment\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * target.copyFrom(source);\n     * ```\n     * @param circle - The circle to copy from\n     * @returns Returns itself\n     * @see {@link Circle.copyTo} For copying to another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * source.copyTo(target);\n     * ```\n     * @param circle - The circle to copy to\n     * @returns Returns given parameter\n     * @see {@link Circle.copyFrom} For copying from another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @example\n * ```ts\n * // Basic ellipse creation\n * const ellipse = new Ellipse(100, 100, 20, 10);\n *\n * // Use as a hit area\n * container.hitArea = new Ellipse(0, 0, 50, 25);\n *\n * // Check point containment\n * const isInside = ellipse.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = ellipse.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and half dimensions\n * - Total width = halfWidth * 2\n * - Total height = halfHeight * 2\n * @see {@link Rectangle} For rectangular shapes\n * @see {@link Circle} For circular shapes\n * @category maths\n * @standard\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic x position\n     * const ellipse = new Ellipse();\n     * ellipse.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic y position\n     * const ellipse = new Ellipse();\n     * ellipse.y = 200;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @example\n     * ```ts\n     * // Set half width\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfWidth = 50; // Total width will be 100\n     * ```\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @example\n     * ```ts\n     * // Set half height\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfHeight = 25; // Total height will be 50\n     * ```\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Ellipse(0, 0, 50, 25);\n     * console.log(shape.type); // 'ellipse'\n     *\n     * // Use in type guards\n     * if (shape.type === 'ellipse') {\n     *     console.log(shape.halfWidth, shape.halfHeight);\n     * }\n     * ```\n     * @readonly\n     * @default 'ellipse'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Ellipse(100, 100, 50, 25);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.halfWidth *= 2;\n     * modified.halfHeight *= 2;\n     *\n     * // Verify independence\n     * console.log(original.halfWidth);  // 50\n     * console.log(modified.halfWidth);  // 100\n     * ```\n     * @returns A copy of the ellipse\n     * @see {@link Ellipse.copyFrom} For copying into existing ellipse\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse.\n     * Uses normalized coordinates and the ellipse equation to determine containment.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isInside = ellipse.contains(120, 110);\n     * ```\n     * @remarks\n     * - Uses ellipse equation (x²/a² + y²/b² ≤ 1)\n     * - Returns false if dimensions are 0 or negative\n     * - Normalized to center (0,0) for calculation\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     * @see {@link Ellipse.strokeContains} For checking stroke intersection\n     * @see {@link Ellipse.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @remarks\n     * - Uses normalized ellipse equations\n     * - Considers stroke alignment\n     * - Returns false if dimensions are 0\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coords are within this ellipse's stroke\n     * @see {@link Ellipse.contains} For checking fill containment\n     * @see {@link Ellipse.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerHorizontal * innerHorizontal))\n            + ((normalizedY * normalizedY) / (innerVertical * innerVertical));\n\n        const outerEllipse = ((normalizedX * normalizedX) / (outerHorizontal * outerHorizontal))\n            + ((normalizedY * normalizedY) / (outerVertical * outerVertical));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const bounds = ellipse.getBounds();\n     * // bounds: x=50, y=75, width=100, height=50\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * ellipse.getBounds(rect);\n     * ```\n     * @remarks\n     * - Creates Rectangle if none provided\n     * - Top-left is (x-halfWidth, y-halfHeight)\n     * - Width is halfWidth * 2\n     * - Height is halfHeight * 2\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Ellipse.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * target.copyFrom(source);\n     * ```\n     * @param ellipse - The ellipse to copy from\n     * @returns Returns itself\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * source.copyTo(target);\n     * ```\n     * @param ellipse - The ellipse to copy to\n     * @returns Returns given parameter\n     * @see {@link Ellipse.copyFrom} For copying from another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n", "import { deprecation } from '../../utils/logging/deprecation';\nimport { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nlet tempRect: Rectangle;\nlet tempRect2: Rectangle;\n\n/**\n * A class to define a shape via user defined coordinates.\n * Used for creating complex shapes and hit areas with custom points.\n * @example\n * ```ts\n * // Create polygon from array of points\n * const polygon1 = new Polygon([\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * ]);\n *\n * // Create from array of coordinates\n * const polygon2 = new Polygon([0, 0, 0, 100, 100, 100]);\n *\n * // Create from sequence of points\n * const polygon3 = new Polygon(\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * );\n *\n * // Create from sequence of coordinates\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n *\n * // Use as container hit area\n * container.hitArea = new Polygon([0, 0, 100, 0, 50, 100]);\n * ```\n * @see {@link Point} For point objects used in construction\n * @category maths\n * @standard\n */\nexport class Polygon implements ShapePrimitive\n{\n    /**\n     * An array of the points of this polygon stored as a flat array of numbers.\n     * @example\n     * ```ts\n     * // Access points directly\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]\n     *\n     * // Modify points\n     * polygon.points[0] = 10; // Move first x coordinate\n     * polygon.points[1] = 10; // Move first y coordinate\n     * ```\n     * @remarks\n     * - Stored as [x1, y1, x2, y2, ...]\n     * - Each pair represents a vertex\n     * - Length is always even\n     * - Can be modified directly\n     */\n    public points: number[];\n\n    /**\n     * Indicates if the polygon path is closed.\n     * @example\n     * ```ts\n     * // Create open polygon\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * polygon.closePath = false;\n     *\n     * // Check path state\n     * if (polygon.closePath) {\n     *     // Last point connects to first\n     * }\n     * ```\n     * @remarks\n     * - True by default\n     * - False after moveTo\n     * - True after closePath\n     * @default true\n     */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(shape.type); // 'polygon'\n     *\n     * // Use in type guards\n     * if (shape.type === 'polygon') {\n     *     // TypeScript knows this is a Polygon\n     *     console.log(shape.points.length);\n     * }\n     * ```\n     * @readonly\n     * @default 'polygon'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Determines whether the polygon's points are arranged in a clockwise direction.\n     * Uses the shoelace formula (surveyor's formula) to calculate the signed area.\n     *\n     * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n     *\n     * The formula sums up the cross products of adjacent vertices:\n     * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n     * The final sum divided by 2 gives the signed area - positive for clockwise.\n     * @example\n     * ```ts\n     * // Check polygon winding\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.isClockwise()); // Check direction\n     *\n     * // Use in path construction\n     * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);\n     * if (hole.isClockwise() === shape.isClockwise()) {\n     *     hole.points.reverse(); // Reverse for proper hole winding\n     * }\n     * ```\n     * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n     */\n    public isClockwise(): boolean\n    {\n        let area = 0;\n        const points = this.points;\n        const length = points.length;\n\n        for (let i = 0; i < length; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % length];\n            const y2 = points[(i + 3) % length];\n\n            area += (x2 - x1) * (y2 + y1);\n        }\n\n        return area < 0;\n    }\n\n    /**\n     * Checks if this polygon completely contains another polygon.\n     * Used for detecting holes in shapes, like when parsing SVG paths.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n     * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n     *\n     * outerSquare.containsPolygon(innerSquare); // Returns true\n     * innerSquare.containsPolygon(outerSquare); // Returns false\n     * ```\n     * @remarks\n     * - Uses bounds check for quick rejection\n     * - Tests all points for containment\n     * @param polygon - The polygon to test for containment\n     * @returns True if this polygon completely contains the other polygon\n     * @see {@link Polygon.contains} For single point testing\n     * @see {@link Polygon.getBounds} For bounds calculation\n     */\n    public containsPolygon(polygon: Polygon): boolean\n    {\n    // Quick early-out: bounds check\n        const thisBounds = this.getBounds(tempRect);\n        const otherBounds = polygon.getBounds(tempRect2);\n\n        if (!thisBounds.containsRect(otherBounds))\n        {\n            return false; // If bounds aren't contained, the polygon cannot be a hole\n        }\n\n        // Full point containment check\n        const points = polygon.points;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            // Combine bounds and polygon checks for efficiency\n            if (!this.contains(x, y))\n            {\n                return false;\n            }\n        }\n\n        return true; // All points are contained within bounds and polygon\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.points[0] = 10; // Modify first x coordinate\n     * ```\n     * @returns A copy of the polygon\n     * @see {@link Polygon.copyFrom} For copying into existing polygon\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * Uses raycasting algorithm for point-in-polygon testing.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isInside = polygon.contains(25, 25); // true\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this polygon\n     * @see {@link Polygon.strokeContains} For checking stroke intersection\n     * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside\n     * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered\n     * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this polygon's stroke\n     * @see {@link Polygon.contains} For checking fill containment\n     * @see {@link Polygon.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment = 0.5): boolean\n    {\n        const strokeWidthSquared = strokeWidth * strokeWidth;\n        const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            const sign = Math.sign(((x2 - x1) * (y - y1)) - ((y2 - y1) * (x - x1)));\n\n            if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const bounds = polygon.getBounds();\n     * // bounds: x=0, y=0, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * polygon.getBounds(rect);\n     * ```\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Polygon.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * target.copyFrom(source);\n     * ```\n     * @param polygon - The polygon to copy from\n     * @returns Returns itself\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * source.copyTo(target);\n     * ```\n     * @param polygon - The polygon to copy to\n     * @returns Returns given parameter\n     * @see {@link Polygon.copyFrom} For copying from another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastX); // 300\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the last vertex\n     * @see {@link Polygon.lastY} For last Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastY); // 400\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the last vertex\n     * @see {@link Polygon.lastX} For last X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.\n     */\n    get x(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.lastX is deprecated, please use Polygon.lastX instead.');\n        // #endif\n\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.\n     */\n    get y(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.y is deprecated, please use Polygon.lastY instead.');\n        // #endif\n\n        return this.points[this.points.length - 1];\n    }\n    /**\n     * Get the first X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.x); // 0\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the first vertex\n     * @see {@link Polygon.startY} For first Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startX(): number\n    {\n        return this.points[0];\n    }\n\n    /**\n     * Get the first Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.y); // 0\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the first vertex\n     * @see {@link Polygon.startX} For first X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startY(): number\n    {\n        return this.points[1];\n    }\n}\n\n", "import { type SHAPE_PRIMITIVE } from '../misc/const';\nimport { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    strokeWidthInner: number,\n    strokeWidthOuter: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\n\n/**\n * The `RoundedRectangle` object represents a rectangle with rounded corners.\n * Defined by position, dimensions and corner radius.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n * // Use as container hit area\n * container.hitArea = new RoundedRectangle(0, 0, 100, 100, 10);\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n * // Get bounds\n * const bounds = rect.getBounds();\n * ```\n * @remarks\n * - Position defined by top-left corner\n * - Radius clamped to half smallest dimension\n * - Common in UI elements\n * @see {@link Rectangle} For non-rounded rectangles\n * @category maths\n * @standard\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const rect = new RoundedRectangle();\n     * rect.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const rect = new RoundedRectangle();\n     * rect.y = 100;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic width setting\n     * const rect = new RoundedRectangle();\n     * rect.width = 200; // Total width will be 200\n     * ```\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic height setting\n     * const rect = new RoundedRectangle();\n     * rect.height = 150; // Total height will be 150\n     * ```\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const rect = new RoundedRectangle(0, 0, 200, 150);\n     * rect.radius = 20;\n     *\n     * // Clamp to maximum safe radius\n     * rect.radius = Math.min(rect.width, rect.height) / 2;\n     *\n     * // Create pill shape\n     * rect.radius = rect.height / 2;\n     * ```\n     * @remarks\n     * - Automatically clamped to half of smallest dimension\n     * - Common values: 0-20 for UI elements\n     * - Higher values create more rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new RoundedRectangle(0, 0, 100, 100, 20);\n     * console.log(shape.type); // 'roundedRectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'roundedRectangle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @readonly\n     * @default 'roundedRectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const bounds = rect.getBounds();\n     * // bounds: x=100, y=100, width=200, height=150\n     *\n     * // Reuse existing rectangle\n     * const out = new Rectangle();\n     * rect.getBounds(out);\n     * ```\n     * @remarks\n     * - Rectangle matches outer dimensions\n     * - Ignores corner radius\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link RoundedRectangle.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 30;\n     * modified.width *= 2;\n     *\n     * // Verify independence\n     * console.log(original.radius);  // 20\n     * console.log(modified.radius);  // 30\n     * ```\n     * @returns A copy of the rounded rectangle\n     * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * target.copyFrom(source);\n     *\n     * // Chain with other operations\n     * const rect = new RoundedRectangle()\n     *     .copyFrom(source)\n     *     .getBounds(rect);\n     * ```\n     * @param rectangle - The rectangle to copy from\n     * @returns Returns itself\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * source.copyTo(target);\n     *\n     * // Chain with other operations\n     * const result = source\n     *     .copyTo(new RoundedRectangle())\n     *     .getBounds();\n     * ```\n     * @param rectangle - The rectangle to copy to\n     * @returns Returns given parameter\n     * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isInside = rect.contains(150, 125); // true\n     * // Check corner radius\n     * const corner = rect.contains(100, 100); // false if within corner curve\n     * ```\n     * @remarks\n     * - Returns false if width/height is 0 or negative\n     * - Handles rounded corners with radius check\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rounded Rectangle\n     * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection\n     * @see {@link RoundedRectangle.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                    || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this rectangle's stroke\n     * @see {@link RoundedRectangle.contains} For checking fill containment\n     * @see {@link RoundedRectangle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner)\n            || (pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner)\n            || (pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n"],
  "mappings": "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",
  "names": []
}
