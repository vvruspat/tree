{
  "version": 3,
  "sources": ["../../pixi.js/src/culling/cullingMixin.ts", "../../pixi.js/src/maths/point/ObservablePoint.ts", "../../pixi.js/src/scene/container/container-mixins/cacheAsTextureMixin.ts", "../../pixi.js/src/utils/data/removeItems.ts", "../../pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts", "../../pixi.js/src/scene/container/container-mixins/collectRenderablesMixin.ts", "../../pixi.js/src/filters/FilterEffect.ts", "../../pixi.js/src/rendering/mask/MaskEffectManager.ts", "../../pixi.js/src/scene/container/container-mixins/effectsMixin.ts", "../../pixi.js/src/scene/container/container-mixins/findMixin.ts", "../../pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts", "../../pixi.js/src/scene/container/container-mixins/getFastGlobalBoundsMixin.ts", "../../pixi.js/src/scene/container/bounds/getGlobalBounds.ts", "../../pixi.js/src/scene/container/utils/multiplyColors.ts", "../../pixi.js/src/scene/container/container-mixins/getGlobalMixin.ts", "../../pixi.js/src/scene/container/bounds/getLocalBounds.ts", "../../pixi.js/src/scene/container/utils/checkChildrenDidChange.ts", "../../pixi.js/src/scene/container/container-mixins/measureMixin.ts", "../../pixi.js/src/scene/container/container-mixins/onRenderMixin.ts", "../../pixi.js/src/scene/container/container-mixins/sortMixin.ts", "../../pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts", "../../pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts", "../../pixi.js/src/scene/container/RenderGroup.ts", "../../pixi.js/src/scene/container/utils/assignWithIgnore.ts", "../../pixi.js/src/scene/container/Container.ts", "../../pixi.js/src/ticker/const.ts", "../../pixi.js/src/ticker/TickerListener.ts", "../../pixi.js/src/ticker/Ticker.ts", "../../pixi.js/src/utils/data/updateQuadBounds.ts", "../../pixi.js/src/scene/view/ViewContainer.ts", "../../pixi.js/src/scene/sprite/Sprite.ts", "../../pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts", "../../pixi.js/src/rendering/renderers/shared/state/State.ts", "../../pixi.js/src/filters/Filter.ts"],
  "sourcesContent": ["import type { Rectangle } from '../maths/shapes/Rectangle';\n\n/**\n * The CullingMixin interface provides properties and methods for managing culling behavior\n * of a display object. Culling is the process of determining whether an object should be rendered\n * based on its visibility within the current view or frame.\n *\n * Key Features:\n * - Custom culling areas for better performance\n * - Per-object culling control\n * - Child culling management\n * @example\n * ```ts\n * // Enable culling for a container\n * const container = new Container();\n * container.cullable = true;\n *\n * // Set custom cull area for better performance\n * container.cullArea = new Rectangle(0, 0, 800, 600);\n *\n * // Disable child culling for static scenes\n * container.cullableChildren = false;\n * ```\n * @category scene\n * @standard\n */\nexport interface CullingMixinConstructor\n{\n    /**\n     * Custom shape used for culling calculations instead of object bounds.\n     * Defined in local space coordinates relative to the object.\n     * > [!NOTE]\n     * > Setting this to a custom Rectangle allows you to define a specific area for culling,\n     * > which can improve performance by avoiding expensive bounds calculations.\n     * @example\n     * ```ts\n     * const container = new Container();\n     *\n     * // Define custom culling boundary\n     * container.cullArea = new Rectangle(0, 0, 800, 600);\n     *\n     * // Reset to use object bounds\n     * container.cullArea = null;\n     * ```\n     * @remarks\n     * - Improves performance by avoiding bounds calculations\n     * - Useful for containers with many children\n     * - Set to null to use object bounds\n     * @default null\n     */\n    cullArea: Rectangle;\n\n    /**\n     * Controls whether this object should be culled when out of view.\n     * When true, the object will not be rendered if its bounds are outside the visible area.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     *\n     * // Enable culling\n     * sprite.cullable = true;\n     *\n     * // Force object to always render\n     * sprite.cullable = false;\n     * ```\n     * @remarks\n     * - Does not affect transform updates\n     * - Applies to this object only\n     * - Children follow their own cullable setting\n     * @default false\n     */\n    cullable: boolean;\n\n    /**\n     * Controls whether children of this container can be culled.\n     * When false, skips recursive culling checks for better performance.\n     * @example\n     * ```ts\n     * const container = new Container();\n     *\n     * // Enable container culling\n     * container.cullable = true;\n     *\n     * // Disable child culling for performance\n     * container.cullableChildren = false;\n     *\n     * // Children will always render if container is visible\n     * container.addChild(sprite1, sprite2, sprite3);\n     * ```\n     * @remarks\n     * - Improves performance for static scenes\n     * - Useful when children are always within container bounds\n     * - Parent culling still applies\n     * @default true\n     */\n    cullableChildren: boolean;\n}\n\n/** @internal */\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n", "import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * Provides callback mechanism for point value updates.\n * @example\n * ```ts\n * // Basic observer implementation\n * const observer: Observer<ObservablePoint> = {\n *     _onUpdate: (point) => {\n *         console.log(`Point updated to (${point.x}, ${point.y})`);\n *     }\n * };\n *\n * // Create observable point with observer\n * const point = new ObservablePoint(observer, 100, 100);\n *\n * // Observer will be notified on changes\n * point.x = 200; // Logs: Point updated to (200, 100)\n * ```\n * @remarks\n * - Used internally by ObservablePoint\n * - Triggered on x/y changes\n * - Can track multiple points\n * - Useful for change detection\n * @typeParam T - The type of point being observed\n * @see {@link ObservablePoint} The observable point class\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport interface Observer<T>\n{\n    /**\n     * Callback to call when the point has updated.\n     * Triggered whenever x or y coordinates change.\n     * @param point - The point that was updated\n     */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system.\n * Triggers a callback when its position changes.\n *\n * The x and y properties represent the position on the horizontal and vertical axes, respectively.\n * @example\n * ```ts\n * // Basic observable point usage\n * const point = new ObservablePoint(\n *     { _onUpdate: (p) => console.log(`Updated to (${p.x}, ${p.y})`) },\n *     100, 100\n * );\n *\n * // Update triggers callback\n * point.x = 200; // Logs: Updated to (200, 100)\n * point.y = 300; // Logs: Updated to (200, 300)\n *\n * // Set both coordinates\n * point.set(50, 50); // Logs: Updated to (50, 50)\n * ```\n * @see {@link Point} For non-observable version\n * @see {@link Observer} For observer interface\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const point = new ObservablePoint(observer, 100, 200);\n     * const copy = point.clone();\n     *\n     * // Clone with new observer\n     * const newObserver = {\n     *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)\n     * };\n     * const watched = point.clone(newObserver);\n     *\n     * // Verify independence\n     * watched.set(300, 400); // Only triggers new observer\n     * ```\n     * @param observer - Optional observer to pass to the new observable point\n     * @returns A copy of this observable point\n     * @see {@link ObservablePoint.copyFrom} For copying into existing point\n     * @see {@link Observer} For observer interface details\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new x and y position.\n     *\n     * If y is omitted, both x and y will be set to x.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * const point = new ObservablePoint(observer);\n     * point.set(100, 200);\n     *\n     * // Set both x and y to same value\n     * point.set(50); // x=50, y=50\n     * ```\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis, defaults to x\n     * @returns The point instance itself\n     * @see {@link ObservablePoint.copyFrom} For copying from another point\n     * @see {@link ObservablePoint.equals} For comparing positions\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point into this point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new ObservablePoint(observer, 100, 200);\n     * const target = new ObservablePoint();\n     * target.copyFrom(source);\n     *\n     * // Copy and chain operations\n     * const point = new ObservablePoint()\n     *     .copyFrom(source)\n     *     .set(x + 50, y + 50);\n     *\n     * // Copy from any PointData\n     * const data = { x: 10, y: 20 };\n     * point.copyFrom(data);\n     * ```\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     * @see {@link ObservablePoint.copyTo} For copying to another point\n     * @see {@link ObservablePoint.clone} For creating new point copy\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new ObservablePoint(100, 200);\n     * const target = new ObservablePoint();\n     * source.copyTo(target);\n     * ```\n     * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n     * @returns The point (`p`) with values updated\n     * @see {@link ObservablePoint.copyFrom} For copying from another point\n     * @see {@link ObservablePoint.clone} For creating new point copy\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Checks if another point is equal to this point.\n     *\n     * Compares x and y values using strict equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const p1 = new ObservablePoint(100, 200);\n     * const p2 = new ObservablePoint(100, 200);\n     * console.log(p1.equals(p2)); // true\n     *\n     * // Compare with PointData\n     * const data = { x: 100, y: 200 };\n     * console.log(p1.equals(data)); // true\n     *\n     * // Check different points\n     * const p3 = new ObservablePoint(200, 300);\n     * console.log(p1.equals(p3)); // false\n     * ```\n     * @param p - The point to check\n     * @returns `true` if both `x` and `y` are equal\n     * @see {@link ObservablePoint.copyFrom} For making points equal\n     * @see {@link PointData} For point data interface\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /**\n     * Position of the observable point on the x axis.\n     * Triggers observer callback when value changes.\n     * @example\n     * ```ts\n     * // Basic x position\n     * const point = new ObservablePoint(observer);\n     * point.x = 100; // Triggers observer\n     *\n     * // Use in calculations\n     * const width = rightPoint.x - leftPoint.x;\n     * ```\n     * @default 0\n     */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /**\n     * Position of the observable point on the y axis.\n     * Triggers observer callback when value changes.\n     * @example\n     * ```ts\n     * // Basic y position\n     * const point = new ObservablePoint(observer);\n     * point.y = 200; // Triggers observer\n     *\n     * // Use in calculations\n     * const height = bottomPoint.y - topPoint.y;\n     * ```\n     * @default 0\n     */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n", "import { deprecation } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\nimport type { CacheAsTextureOptions } from '../RenderGroup';\n\n/** @ignore */\nexport interface CacheAsTextureMixinConstructor\n{\n    cacheAsTexture?: (val: boolean | CacheAsTextureOptions) => void;\n}\n\n/**\n * The CacheAsTextureMixin interface provides methods and properties for caching a container as a texture.\n * This can improve rendering performance for complex static containers by allowing them to be rendered as a single texture.\n * It includes methods to enable or disable caching, update the cached texture, and check\n * 1if the container is currently cached.\n * @category scene\n * @advanced\n */\nexport interface CacheAsTextureMixin extends Required<CacheAsTextureMixinConstructor>\n{\n    /**\n     * Caches this container as a texture. This allows the container to be rendered as a single texture,\n     * which can improve performance for complex static containers.\n     * @example\n     * ```ts\n     * // Basic caching\n     * container.cacheAsTexture(true);\n     *\n     * // With custom options\n     * container.cacheAsTexture({\n     *     resolution: 2,\n     *     antialias: true,\n     * });\n     *\n     * // Disable caching\n     * container.cacheAsTexture(false);\n     *\n     * // Cache a complex UI\n     * const ui = new Container();\n     * // Add multiple children...\n     * ui.cacheAsTexture(true);\n     * ui.updateCacheTexture(); // Update if contents change\n     * ```\n     * @param val - If true, enables caching with default options.\n     *             If false, disables caching.\n     *             Can also pass options object to configure caching behavior.\n     * @see {@link Container#updateCacheTexture} For updating cached content\n     * @see {@link Container#isCachedAsTexture} For checking cache state\n     */\n    cacheAsTexture: (val: boolean | CacheAsTextureOptions) => void;\n\n    /**\n     * Updates the cached texture of this container. This will flag the container's cached texture\n     * to be redrawn on the next render.\n     * @example\n     * ```ts\n     * // Basic update after changes\n     * container.updateCacheTexture();\n     * ```\n     */\n    updateCacheTexture: () => void;\n\n    /**\n     * Legacy property for backwards compatibility with PixiJS v7 and below.\n     * Use `cacheAsTexture` instead.\n     * @deprecated since 8.0.0\n     */\n    cacheAsBitmap: boolean;\n\n    /**\n     * Whether this container is currently cached as a texture.\n     * @example\n     * ```ts\n     * // Check cache state\n     * if (container.isCachedAsTexture) {\n     *     console.log('Container is cached');\n     * }\n     * ```\n     * @readonly\n     * @see {@link Container#cacheAsTexture} For enabling caching\n     * @see {@link Container#updateCacheTexture} For updating cache\n     */\n    readonly isCachedAsTexture: boolean;\n}\n\n/** @internal */\nexport const cacheAsTextureMixin: Partial<Container> = {\n    get isCachedAsTexture(): boolean\n    {\n        return !!this.renderGroup?.isCachedAsTexture;\n    },\n\n    cacheAsTexture(val: boolean | CacheAsTextureOptions): void\n    {\n        if (typeof val === 'boolean' && val === false)\n        {\n            this.disableRenderGroup();\n        }\n        else\n        {\n            this.enableRenderGroup();\n            this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n        }\n    },\n\n    updateCacheTexture(): void\n    {\n        this.renderGroup?.updateCacheTexture();\n    },\n\n    get cacheAsBitmap(): boolean\n    {\n        return this.isCachedAsTexture;\n    },\n\n    set cacheAsBitmap(val: boolean)\n    {\n        // #if _DEBUG\n        deprecation('v8.6.0', 'cacheAsBitmap is deprecated, use cacheAsTexture instead.');\n        // #endif\n        this.cacheAsTexture(val);\n    },\n} as Container;\n", "/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @category utils\n * @internal\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n", "import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container, ContainerChild } from '../Container';\n\n/**\n * Mixin interface for containers that allows them to manage children.\n * It provides methods for adding, removing, and manipulating child containers.\n * @category scene\n * @advanced\n */\nexport interface ChildrenHelperMixin<C = ContainerChild>\n{\n    /** @internal */\n    allowChildren: boolean;\n    addChild<U extends C[]>(...children: U): U[0];\n    removeChild<U extends C[]>(...children: U): U[0];\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @example\n     * ```ts\n     * // Remove all children\n     * container.removeChildren();\n     *\n     * // Remove first 3 children\n     * const removed = container.removeChildren(0, 3);\n     * console.log('Removed:', removed.length); // 3\n     *\n     * // Remove children from index 2 onwards\n     * container.removeChildren(2);\n     *\n     * // Remove specific range\n     * const middle = container.removeChildren(1, 4);\n     * ```\n     * @param {number} beginIndex - The beginning position\n     * @param {number} endIndex - The ending position. Default is container size\n     * @returns List of removed children\n     * @throws {RangeError} If begin/end indexes are invalid\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing specific children\n     */\n    removeChildren(beginIndex?: number, endIndex?: number): C[];\n    /**\n     * Removes a child from the specified index position.\n     * @example\n     * ```ts\n     * // Remove first child\n     * const removed = container.removeChildAt(0);\n     *\n     * // type safe access\n     * const sprite = container.removeChildAt<Sprite>(1);\n     *\n     * // With error handling\n     * try {\n     *     const child = container.removeChildAt(10);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {number} index - The index to remove the child from\n     * @returns The child that was removed\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#removeChild} For removing specific children\n     * @see {@link Container#removeChildren} For removing multiple children\n     */\n    removeChildAt<U extends C>(index: number): U;\n    /**\n     * Returns the child at the specified index.\n     * @example\n     * ```ts\n     * // Get first child\n     * const first = container.getChildAt(0);\n     *\n     * // Type-safe access\n     * const sprite = container.getChildAt<Sprite>(1);\n     *\n     * // With error handling\n     * try {\n     *     const child = container.getChildAt(10);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {number} index - The index to get the child from\n     * @returns The child at the given index\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#children} For direct array access\n     * @see {@link Container#getChildByLabel} For name-based lookup\n     */\n    getChildAt<U extends C>(index: number): U;\n    /**\n     * Changes the position of an existing child in the container.\n     * @example\n     * ```ts\n     * // Basic index change\n     * container.setChildIndex(sprite, 0); // Move to front\n     * container.setChildIndex(sprite, container.children.length - 1); // Move to back\n     *\n     * // With error handling\n     * try {\n     *     container.setChildIndex(sprite, 5);\n     * } catch (e) {\n     *     console.warn('Invalid index or child not found');\n     * }\n     * ```\n     * @param {Container}child - The child Container instance to reposition\n     * @param {number}index - The resulting index number for the child\n     * @throws {Error} If index is out of bounds\n     * @throws {Error} If child is not in container\n     * @see {@link Container#getChildIndex} For getting current index\n     * @see {@link Container#swapChildren} For swapping positions\n     */\n    setChildIndex(child: C, index: number): void;\n    /**\n     * Returns the index position of a child Container instance.\n     * @example\n     * ```ts\n     * // Basic index lookup\n     * const index = container.getChildIndex(sprite);\n     * console.log(`Sprite is at index ${index}`);\n     *\n     * // With error handling\n     * try {\n     *     const index = container.getChildIndex(sprite);\n     * } catch (e) {\n     *     console.warn('Child not found in container');\n     * }\n     * ```\n     * @param {Container} child - The Container instance to identify\n     * @returns The index position of the child container\n     * @throws {Error} If child is not in this container\n     * @see {@link Container#setChildIndex} For changing index\n     * @see {@link Container#children} For direct array access\n     */\n    getChildIndex(child: C): number;\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @example\n     * ```ts\n     * // Add at specific index\n     * container.addChildAt(sprite, 0); // Add to front\n     *\n     * // Move existing child\n     * const index = container.children.length - 1;\n     * container.addChildAt(existingChild, index); // Move to back\n     *\n     * // With error handling\n     * try {\n     *     container.addChildAt(sprite, 1000);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {Container} child - The child to add\n     * @param {number} index - The index where the child will be placed\n     * @returns The child that was added\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#addChild} For adding to the end\n     * @see {@link Container#setChildIndex} For moving existing children\n     */\n    addChildAt<U extends C>(child: U, index: number): U;\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @example\n     * ```ts\n     * // Basic swap\n     * container.swapChildren(sprite1, sprite2);\n     *\n     * // With error handling\n     * try {\n     *     container.swapChildren(sprite1, sprite2);\n     * } catch (e) {\n     *     console.warn('One or both children not found in container');\n     * }\n     * ```\n     * @remarks\n     * - Updates render groups\n     * - No effect if same child\n     * - Triggers container changes\n     * - Common in z-ordering\n     * @param {Container} child - First container to swap\n     * @param {Container} child2 - Second container to swap\n     * @throws {Error} If either child is not in container\n     * @see {@link Container#setChildIndex} For direct index placement\n     * @see {@link Container#getChildIndex} For getting current positions\n     */\n    swapChildren<U extends C>(child: U, child2: U): void;\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @example\n     * ```ts\n     * // Basic removal\n     * sprite.removeFromParent();\n     *\n     * // With validation\n     * if (sprite.parent) {\n     *     sprite.removeFromParent();\n     * }\n     * ```\n     * @see {@link Container#addChild} For adding to a new parent\n     * @see {@link Container#removeChild} For parent removing children\n     */\n    removeFromParent(): void;\n    /**\n     * Reparent a child or multiple children to this container while preserving their world transform.\n     * This ensures that the visual position and rotation of the children remain the same even when changing parents.\n     * @example\n     * ```ts\n     * // Basic reparenting\n     * const sprite = new Sprite(texture);\n     * oldContainer.addChild(sprite);\n     * // Move to new parent, keeping visual position\n     * newContainer.reparentChild(sprite);\n     *\n     * // Reparent multiple children\n     * const batch = [sprite1, sprite2, sprite3];\n     * newContainer.reparentChild(...batch);\n     * ```\n     * @param {Container} child - The child or children to reparent\n     * @returns The first child that was reparented\n     * @see {@link Container#reparentChildAt} For index-specific reparenting\n     * @see {@link Container#addChild} For simple parenting\n     */\n    reparentChild<U extends C[]>(...child: U): U[0];\n    /**\n     * Reparent the child to this container at the specified index while preserving its world transform.\n     * This ensures that the visual position and rotation of the child remain the same even when changing parents.\n     * @example\n     * ```ts\n     * // Basic index-specific reparenting\n     * const sprite = new Sprite(texture);\n     * oldContainer.addChild(sprite);\n     * // Move to new parent at index 0 (front)\n     * newContainer.reparentChildAt(sprite, 0);\n     * ```\n     * @param {Container} child - The child to reparent\n     * @param {number} index - The index to reparent the child to\n     * @returns The reparented child\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#reparentChild} For appending reparented children\n     * @see {@link Container#addChildAt} For simple indexed parenting\n     */\n    reparentChildAt<U extends C>(child: U, index: number): U;\n    /**\n     * Replace a child in the container with a new child. Copying the local transform from the old child to the new one.\n     * @param {Container} oldChild - The child to replace.\n     * @param {Container} newChild - The new child to add.\n     */\n    replaceChild<U extends C, T extends C>(oldChild: U, newChild: T): void;\n}\n\n/** @internal */\nexport const childrenHelperMixin: ChildrenHelperMixin<ContainerChild> = {\n\n    allowChildren: true,\n\n    removeChildren(beginIndex = 0, endIndex?: number): ContainerChild[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: ContainerChild[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.removeChildren(removed);\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                const child = removed[i];\n\n                child.parentRenderLayer?.detach(child);\n\n                this.emit('childRemoved', child, this, i);\n                removed[i].emit('removed', this);\n            }\n\n            if (removed.length > 0)\n            {\n                this._didViewChangeTick++;\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    removeChildAt<U extends ContainerChild>(index: number): U\n    {\n        const child = this.getChildAt<U>(index);\n\n        return this.removeChild(child);\n    },\n\n    getChildAt<U extends ContainerChild>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    setChildIndex(child: ContainerChild, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    getChildIndex(child: ContainerChild): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    addChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child);\n        }\n        else\n        {\n            children.splice(index, 0, child);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n\n    swapChildren<U extends ContainerChild>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        this._didContainerChangeTick++;\n    },\n\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    },\n\n    reparentChild<U extends ContainerChild[]>(...child: U): U[0]\n    {\n        if (child.length === 1)\n        {\n            return this.reparentChildAt(child[0], this.children.length);\n        }\n\n        child.forEach((c) => this.reparentChildAt(c, this.children.length));\n\n        return child[0];\n    },\n\n    reparentChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        if (child.parent === this)\n        {\n            this.setChildIndex(child, index);\n\n            return child;\n        }\n\n        const childMat = child.worldTransform.clone();\n\n        child.removeFromParent();\n        this.addChildAt(child, index);\n\n        const newMatrix = this.worldTransform.clone();\n\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n\n        child.setFromMatrix(childMat);\n\n        return child;\n    },\n\n    replaceChild<U extends ContainerChild, T extends ContainerChild>(oldChild: U, newChild: T)\n    {\n        oldChild.updateLocalTransform();\n        this.addChildAt(newChild, this.getChildIndex(oldChild));\n\n        newChild.setFromMatrix(oldChild.localTransform);\n        newChild.updateLocalTransform();\n        this.removeChild(oldChild);\n    },\n} as Container;\n", "import { type InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer, type RenderPipes } from '../../../rendering/renderers/types';\nimport { type RenderLayer } from '../../layers/RenderLayer';\n\nimport type { Container } from '../Container';\n\n/**\n * The CollectRenderablesMixin interface defines methods for collecting renderable objects\n * from a container and its children. These methods add the renderables to an instruction set,\n * which is used by the renderer to process and display the scene.\n * @category scene\n * @internal\n */\nexport interface CollectRenderablesMixin\n{\n    /**\n     * Collects all renderables from the container and its children, adding them to the instruction set.\n     * This method decides whether to use a simple or advanced collection method based on the container's properties.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n\n    /**\n     * Collects renderables using a simple method, suitable for containers marked as simple.\n     * This method iterates over the container's children and adds their renderables to the instruction set.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderablesSimple(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n\n    /**\n     * Collects renderables using an advanced method, suitable for containers with complex processing needs.\n     * This method handles additional effects and transformations that may be applied to the renderables.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void;\n}\n\n/**\n * The collectRenderablesMixin provides implementations for the methods defined in the CollectRenderablesMixin interface.\n * It includes logic to determine the appropriate method for collecting renderables based on the container's properties.\n * @internal\n */\nexport const collectRenderablesMixin: Partial<Container> = {\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void\n    {\n        // Skip processing if the container is not in the current render layer or is not fully visible.\n        if ((this.parentRenderLayer && this.parentRenderLayer !== currentLayer)\n            || this.globalDisplayStatus < 0b111 || !this.includeInBuild) return;\n\n        // Sort children if the container has sortable children.\n        if (this.sortableChildren)\n        {\n            this.sortChildren();\n        }\n\n        // Choose the appropriate method for collecting renderables based on the container's properties.\n        if (this.isSimple)\n        {\n            this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n        }\n        else if (this.renderGroup)\n        {\n            renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n        }\n        else\n        {\n            this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n        }\n    },\n    collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void\n    {\n        const children = this.children;\n        const length = children.length;\n\n        // Iterate over each child and collect their renderables.\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    },\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        // Apply each effect to the renderables before collecting them.\n        for (let i = 0; i < this.effects.length; i++)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.push(effect, this, instructionSet);\n        }\n\n        // Collect renderables using the simple method after applying effects.\n        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n\n        // Remove effects from the renderables after collection, processing in reverse order.\n        for (let i = this.effects.length - 1; i >= 0; i--)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.pop(effect, this, instructionSet);\n        }\n    }\n} as Container;\n", "import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container.\n * @internal\n */\nexport class FilterEffect implements Effect\n{\n    /** read only filters array - to modify, set it again! */\n    public filters: readonly Filter[];\n    /**\n     * If specified, rather than calculating the bounds of the container that the filter\n     * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n     * applied to it\n     */\n    public filterArea?: Rectangle;\n\n    /** the pipe that knows how to handle this effect */\n    public pipe = 'filter';\n    /** the priority of this effect */\n    public priority = 1;\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\n/**\n * Represents a mask effect that can be applied to a container.\n * @category rendering\n * @advanced\n */\nexport type MaskEffect = {mask: unknown} & Effect;\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @category rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /** @private */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): MaskEffect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<MaskEffect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @class\n * @category rendering\n * @advanced\n */\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n", "import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\n/** @ignore */\nexport interface EffectsMixinConstructor\n{\n    /**\n     * The mask to apply, which can be a Container or null.\n     *\n     * If null, it clears the existing mask.\n     * @example\n     * ```ts\n     * // Set a mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: false,\n     * });\n     */\n    mask?: Mask;\n    setMask?: (options: Partial<MaskOptionsAndMask>) => void;\n    /**\n     * Sets the filters for the displayObject.\n     * Filters are visual effects that can be applied to any display object and its children.\n     *\n     * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n     * @example\n     * ```ts\n     * new Container({\n     *     filters: [new BlurFilter(2), new ColorMatrixFilter()],\n     * });\n     * ```\n     * @see {@link Filter} For filter base class\n     */\n    filters?: Filter | readonly Filter[];\n}\n\n/**\n * The Mask type represents different ways to mask a display object.\n * - A number represents a mask ID.\n * - A Container represents a mask object, such as a Graphics or Sprite.\n * - null indicates that no mask is applied.\n * @example\n * ```ts\n * // Using a Container as a mask\n * const maskContainer: Mask = new Graphics();\n * // Using a mask ID\n * const maskId: Mask = 123;\n * // No mask applied\n * const noMask: Mask = null;\n * ```\n * @category scene\n * @standard\n */\nexport type Mask = number | Container | null;\n\n/**\n * Options for configuring mask behavior on a display object.\n * @example\n * ```ts\n * // Basic mask inversion\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true\n * });\n * ```\n * @see {@link Container#setMask} For applying masks with options\n * @see {@link Container#mask} For basic masking\n * @category scene\n * @standard\n */\nexport interface MaskOptions\n{\n    /**\n     * Whether the mask should be inverted.\n     * When true, the masked area becomes transparent and the unmasked area becomes visible.\n     * @default false\n     * @example\n     * ```ts\n     * // Invert the mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true\n     * });\n     * ```\n     */\n    inverse: boolean;\n}\n\n/**\n * MaskOptionsAndMask combines MaskOptions with a Mask for configuring masking behavior.\n * Used when setting up complex masking effects with additional options.\n * @example\n * ```ts\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true,\n * });\n *\n * // Clear existing mask\n * sprite.setMask({\n *     mask: null,\n *     inverse: false,\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link Container#setMask} For applying masks\n * @see {@link MaskOptions} For base options\n */\nexport interface MaskOptionsAndMask extends MaskOptions\n{\n    /**\n     * The mask to apply, which can be a Container or null.\n     *\n     * If null, it clears the existing mask.\n     * @example\n     * ```ts\n     * // Set a mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: false,\n     * });\n     */\n    mask: Mask;\n}\n\n/**\n * The EffectsMixin interface provides methods and properties for managing effects\n * such as masks and filters on a display object.\n * It allows for adding, removing, and configuring effects, as well as setting a mask for the display object.\n * @category scene\n * @advanced\n */\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    /** @private */\n    _maskEffect?: MaskEffect;\n    /** @private */\n    _maskOptions?: MaskOptions;\n    /** @private */\n    _filterEffect?: FilterEffect,\n    /** @private */\n    _markStructureAsChanged(): void;\n\n    /**\n     * The area the filter is applied to. This is used as an optimization to define a specific region\n     * for filter effects instead of calculating the display object bounds each frame.\n     *\n     * > [!NOTE]\n     * > Setting this to a custom Rectangle allows you to define a specific area for filter effects,\n     * > which can improve performance by avoiding expensive bounds calculations.\n     * @example\n     * ```ts\n     * // Set specific filter area\n     * container.filterArea = new Rectangle(0, 0, 100, 100);\n     *\n     * // Optimize filter region\n     * const screen = app.screen;\n     * container.filterArea = new Rectangle(\n     *     screen.x,\n     *     screen.y,\n     *     screen.width,\n     *     screen.height\n     * );\n     * ```\n     * @see {@link Container#filters} For applying filters\n     * @see {@link Rectangle} For area definition\n     */\n    filterArea?: Rectangle,\n    /**\n     * todo Needs docs\n     * @advanced\n     */\n    effects?: Effect[];\n    /**\n     * todo Needs docs.\n     * @param {Effect} effect - The effect to add.\n     * @ignore\n     */\n    addEffect(effect: Effect): void;\n    /**\n     * todo Needs docs.\n     * @param {Effect} effect - The effect to remove.\n     * @ignore\n     */\n    removeEffect(effect: Effect): void;\n    /**\n     * Used to set mask and control mask options on a display object.\n     * Allows for more detailed control over masking behavior compared to the mask property.\n     * @example\n     * ```ts\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * // Create a circular mask\n     * const graphics = new Graphics()\n     *     .beginFill(0xFF3300)\n     *     .drawCircle(100, 100, 50)\n     *     .endFill();\n     *\n     * // Apply mask with options\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true, // Create a hole effect\n     * });\n     *\n     * // Clear existing mask\n     * sprite.setMask({ mask: null });\n     * ```\n     * @param {Partial<MaskOptionsAndMask>} options - Configuration options for the mask\n     * @see {@link Container#mask} For simple masking\n     * @see {@link MaskOptionsAndMask} For full options API\n     */\n    setMask(options: Partial<MaskOptionsAndMask>): void;\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it.\n     *\n     * > [!IMPORTANT] In PixiJS a regular mask must be a {@link Graphics} or a {@link Sprite} object.\n     * > This allows for much faster masking in canvas as it utilities shape clipping.\n     * > Furthermore, a mask of an object must be in the subtree of its parent.\n     * > Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * ```ts\n     * // Apply mask to sprite\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     *\n     * // Remove mask\n     * sprite.mask = null;\n     * ```\n     * @see {@link Graphics} For creating mask shapes\n     * @see {@link Sprite} For texture-based masks\n     * @see {@link Container#setMask} For advanced mask options\n     */\n    mask: Mask;\n    /**\n     * Sets the filters for the displayObject.\n     * Filters are visual effects that can be applied to any display object and its children.\n     *\n     * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n     * @example\n     * ```ts\n     * // Add a single filter\n     * sprite.filters = new BlurFilter(2);\n     *\n     * // Apply multiple filters\n     * container.filters = [\n     *     new BlurFilter(2),\n     *     new ColorMatrixFilter(),\n     * ];\n     *\n     * // Remove filters\n     * sprite.filters = null;\n     * ```\n     * @see {@link Filter} For filter base class\n     */\n    set filters(value: Filter | Filter[] | null | undefined);\n    get filters(): readonly Filter[];\n}\n\n/** @internal */\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _maskOptions: {\n        inverse: false,\n    },\n    _filterEffect: null,\n\n    effects: [],\n\n    _markStructureAsChanged()\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n    },\n\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        this._markStructureAsChanged();\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        this._markStructureAsChanged();\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: Mask)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n\n            this._maskEffect = null;\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    setMask(options: Partial<MaskOptionsAndMask>)\n    {\n        this._maskOptions = {\n            ...this._maskOptions,\n            ...options,\n        };\n\n        if (options.mask)\n        {\n            this.mask = options.mask;\n        }\n\n        this._markStructureAsChanged();\n    },\n\n    set filters(value: Filter | readonly Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = ([value] as Filter[]);\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\n/** @ignore */\nexport interface FindMixinConstructor\n{\n    /**\n     * The instance label of the object.\n     * @default null\n     */\n    label?: string;\n}\n\n/**\n * The FindMixin interface provides methods for finding children within a container by their label.\n * It allows for searching for a single child or multiple children with a specific label,\n * either directly or recursively through the container's hierarchy.\n * @category scene\n * @advanced\n */\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see Container#label\n     * @default null\n     */\n    name: string;\n    /**\n     * @deprecated since 8.0.0\n     * @param {string} label - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see Container#getChildByLabel\n     */\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    /**\n     * Returns the first child in the container with the specified label.\n     * Recursive searches are done in a pre-order traversal.\n     * @example\n     * ```ts\n     * // Basic label search\n     * const child = container.getChildByLabel('player');\n     *\n     * // Search with regular expression\n     * const enemy = container.getChildByLabel(/enemy-\\d+/);\n     *\n     * // Deep search through children\n     * const deepChild = container.getChildByLabel('powerup', true);\n     * ```\n     * @param {RegExp|string} label - Instance label to search for\n     * @param {boolean} deep - Whether to search recursively through children\n     * @returns The first child with the specified label, or null if none found\n     * @see {@link Container#getChildrenByLabel} For finding all matches\n     * @see {@link Container#label} For setting labels\n     */\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    /**\n     * Returns all children in the container with the specified label.\n     * Recursive searches are done in a pre-order traversal.\n     * @example\n     * ```ts\n     * // Basic label search\n     * const enemies = container.getChildrenByLabel('enemy');\n     * // Search with regular expression\n     * const powerups = container.getChildrenByLabel(/powerup-\\d+/);\n     * // Deep search with collection\n     * const buttons = [];\n     * container.getChildrenByLabel('button', true, buttons);\n     * ```\n     * @param {string|RegExp} label  - Instance label to search for\n     * @param {boolean}[deep=false] - Whether to search recursively through children\n     * @param {Container[]} [out=[]]  - Optional array to store matching children in\n     * @returns An array of children with the specified label\n     * @see {@link Container#getChildByLabel} For finding first match\n     * @see {@link Container#label} For setting labels\n     */\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\n/** @internal */\nexport const findMixin: Partial<Container> = {\n    label: null,\n\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\n/** @internal */\nexport const matrixPool = BigPool.getPool<MatrixPoolItem>(Matrix);\n/** @internal */\nexport const boundsPool = BigPool.getPool<BoundsPoolItem>(Bounds);\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { type Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport { type RenderLayer } from '../../layers/RenderLayer';\nimport { Bounds } from '../bounds/Bounds';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { Container } from '../Container';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Interface for the GetFastGlobalBoundsMixin, which provides methods to compute\n * an approximate global bounding box for a container and its children.\n * @category scene\n * @advanced\n */\nexport interface GetFastGlobalBoundsMixin\n{\n    /**\n     * Computes an approximate global bounding box for the container and its children.\n     * This method is optimized for speed by using axis-aligned bounding boxes (AABBs),\n     * and uses the last render results from when it updated the transforms. This function does not update them.\n     * which may result in slightly larger bounds but never smaller than the actual bounds.\n     *\n     * for accurate (but less performant) results use `container.getGlobalBounds`\n     * @param {boolean} [factorRenderLayers] - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The output bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @advanced\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * This method is used internally by getFastGlobalBounds to traverse the scene graph.\n     * @param {boolean} factorRenderLayers - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: RenderLayer,\n    ): void;\n}\n\n/**\n * Mixin providing the implementation of the GetFastGlobalBoundsMixin interface.\n * It includes methods to compute and recursively calculate global bounds for containers.\n * @internal\n */\nexport const getFastGlobalBoundsMixin: Partial<Container> = {\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds\n    {\n        bounds ||= new Bounds();\n\n        // Initialize the bounds for fresh calculations.\n        bounds.clear();\n\n        // Calculate bounds recursively, starting from the current container.\n        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n\n        // Validate the calculated bounds, resetting if invalid.\n        if (!bounds.isValid)\n        {\n            bounds.set(0, 0, 0, 0);\n        }\n\n        // Apply the world transformation to the bounds.\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        bounds.applyMatrix(renderGroup.worldTransform);\n\n        return bounds;\n    },\n\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: RenderLayer,\n    )\n    {\n        let localBounds = bounds;\n\n        // Skip if the container is not in the current render layer when factoring render layers.\n        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;\n\n        // Skip if the container is not fully visible or not measurable.\n        if (this.localDisplayStatus !== 0b111 || (!this.measurable))\n        {\n            return;\n        }\n\n        // Determine if effects need to be managed, requiring separate bounds handling.\n        const manageEffects = !!this.effects.length;\n\n        // Use a temporary bounds object if the container is a render group or has effects.\n        if (this.renderGroup || manageEffects)\n        {\n            localBounds = boundsPool.get().clear();\n        }\n\n        // Add the container's own bounds area to the bounds if it exists.\n        if (this.boundsArea)\n        {\n            bounds.addRect(this.boundsArea, this.worldTransform);\n        }\n        else\n        {\n            // If the container is renderable, add its bounds to the local bounds.\n            if (this.renderPipeId)\n            {\n                const viewBounds = (this as Renderable).bounds;\n\n                localBounds.addFrame(\n                    viewBounds.minX,\n                    viewBounds.minY,\n                    viewBounds.maxX,\n                    viewBounds.maxY,\n                    this.groupTransform\n                );\n            }\n\n            // Recursively process each child to include their bounds.\n            const children = this.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n            }\n        }\n\n        // If effects are managed, apply them to the bounds.\n        if (manageEffects)\n        {\n            let advanced = false;\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            // Apply each effect that modifies bounds.\n            for (let i = 0; i < this.effects.length; i++)\n            {\n                if (this.effects[i].addBounds)\n                {\n                    if (!advanced)\n                    {\n                        advanced = true;\n                        localBounds.applyMatrix(renderGroup.worldTransform);\n                    }\n                    this.effects[i].addBounds(localBounds, true);\n                }\n            }\n\n            // Adjust bounds back to the local coordinate space if advanced bounds were calculated.\n            if (advanced)\n            {\n                localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            }\n\n            // Add the local bounds to the final bounds and return the temporary bounds object.\n            bounds.addBounds(localBounds);\n            boundsPool.return(localBounds);\n        }\n        else if (this.renderGroup)\n        {\n            // If the container is a render group, add its local bounds to the final bounds.\n            bounds.addBounds(localBounds, this.relativeGroupTransform);\n            boundsPool.return(localBounds);\n        }\n    }\n\n} as Container;\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n/**\n * Gets the global bounds of a container, including all its children\n * @param target - The target container to get the bounds from\n * @param skipUpdateTransform - If true, the transform will not be updated before calculating bounds.\n * @param bounds - The output bounds object.\n * @returns The bounds.\n * @internal\n */\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        const renderableBounds = (target as Renderable).bounds;\n\n        if (renderableBounds && !renderableBounds.isEmpty())\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n            bounds.addBounds(renderableBounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\n/**\n * @param target\n * @param parentTransform\n * @internal\n */\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n", "import { multiplyHexColors } from './multiplyHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\n/**\n * @param localBGRColor\n * @param parentBGRColor\n * @internal\n */\nexport function multiplyColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR)\n    {\n        return parentBGRColor;\n    }\n\n    if (parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor;\n    }\n\n    return multiplyHexColors(localBGRColor, parentBGRColor);\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\nimport { multiplyColors } from '../utils/multiplyColors';\n\nimport type { Container } from '../Container';\n\n/**\n * Converts a color from BGR format to RGB format.\n * @param color - The color in BGR format (0xBBGGRR).\n * @returns The color in RGB format (0xRRGGBB).\n * @category utils\n * @internal\n */\nexport function bgr2rgb(color: number): number\n{\n    return ((color & 0xFF) << 16) + (color & 0xFF00) + ((color >> 16) & 0xFF);\n}\n\n/**\n * Interface for a mixin that provides methods to retrieve global properties of a container.\n * This mixin allows you to get the global alpha, transform matrix, and tint color of a container,\n * taking into account its parent containers and render groups.\n * It includes methods to optimize performance by using cached values when available.\n * @category scene\n * @advanced\n */\nexport interface GetGlobalMixin\n{\n    /**\n     * Returns the global (compound) alpha of the container within the scene.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n     *   - If true: Uses cached worldAlpha from the last render pass for better performance\n     * @returns The resulting alpha value (between 0 and 1)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire alpha chain\n     * const preciseAlpha = container.getGlobalAlpha();\n     *\n     * // Faster but may be outdated - uses cached alpha\n     * const cachedAlpha = container.getGlobalAlpha(true);\n     * ```\n     */\n    getGlobalAlpha(skipUpdate?: boolean): number;\n    /**\n     * Returns the global transform matrix of the container within the scene.\n     * @param {Matrix} matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire transform chain for accuracy\n     *   - If true: Uses cached worldTransform from the last render pass for better performance\n     * @returns The resulting transformation matrix (either the input matrix or a new one)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire transform chain\n     * const preciseTransform = container.getGlobalTransform();\n     *\n     * // Faster but may be outdated - uses cached transform\n     * const cachedTransform = container.getGlobalTransform(undefined, true);\n     *\n     * // Reuse existing matrix\n     * const existingMatrix = new Matrix();\n     * container.getGlobalTransform(existingMatrix);\n     * ```\n     */\n    getGlobalTransform(matrix?: Matrix, skipUpdate?: boolean): Matrix;\n    /**\n     * Returns the global (compound) tint color of the container within the scene.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n     *   - If true: Uses cached worldColor from the last render pass for better performance\n     * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire tint chain\n     * const preciseTint = container.getGlobalTint();\n     *\n     * // Faster but may be outdated - uses cached tint\n     * const cachedTint = container.getGlobalTint(true);\n     * ```\n     */\n    getGlobalTint(skipUpdate?: boolean): number;\n}\n\n/** @internal */\nexport const getGlobalMixin: Partial<Container> = {\n    getGlobalAlpha(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return this.renderGroup.worldAlpha;\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return this.parentRenderGroup.worldAlpha * this.alpha;\n            }\n\n            return this.alpha;\n        }\n\n        let alpha = this.alpha;\n        let current = this.parent;\n\n        while (current)\n        {\n            alpha *= current.alpha;\n            current = current.parent;\n        }\n\n        return alpha;\n    },\n    getGlobalTransform(matrix = new Matrix(), skipUpdate?: boolean): Matrix\n    {\n        if (skipUpdate)\n        {\n            return matrix.copyFrom(this.worldTransform);\n        }\n\n        this.updateLocalTransform();\n\n        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n\n        matrix.appendFrom(this.localTransform, parentTransform);\n        matrixPool.return(parentTransform);\n\n        return matrix;\n    },\n    getGlobalTint(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return bgr2rgb(this.renderGroup.worldColor);\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return bgr2rgb(\n                    multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n                );\n            }\n\n            return this.tint;\n        }\n\n        let color = this.localColor;\n        let parent = this.parent;\n\n        while (parent)\n        {\n            color = multiplyColors(color, parent.localColor);\n            parent = parent.parent;\n        }\n\n        return bgr2rgb(color);\n    }\n\n} as Container;\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n/**\n * @param target\n * @param bounds\n * @param relativeMatrix\n * @internal\n */\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            bounds.addBounds((target as Renderable).bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\n", "import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n * @internal\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const uid = child.uid;\n        const didChange = ((child._didViewChangeTick & 0xffff) << 16) | (child._didContainerChangeTick & 0xffff);\n\n        const index = previousData.index;\n\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange)\n        {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index = index + 2;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\n/**\n * A utility type that makes all properties of T optional except for the specified keys K.\n * @category utils\n * @internal\n */\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n/** @ignore */\nexport interface MeasureMixinConstructor\n{\n    /**\n     * The width of the display object, in pixels.\n     * @example\n     * ```ts\n     * new Container({ width: 100});\n     * ```\n     * @default 0\n     */\n    width?: number;\n    /**\n     * The height of the display object, in pixels.\n     * @example\n     * ```ts\n     * new Container({ height: 100});\n     * ```\n     * @default 0\n     */\n    height?: number;\n}\n/**\n * The MeasureMixin interface provides methods for measuring and manipulating the size and bounds of a display object.\n * It includes methods to get and set the size of the object, retrieve its local bounds,\n * and calculate its global bounds.\n * @category scene\n * @advanced\n */\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * Uses cached values when possible for better performance.\n     * @example\n     * ```ts\n     * // Basic bounds check\n     * const bounds = container.getLocalBounds();\n     * console.log(`Width: ${bounds.width}, Height: ${bounds.height}`);\n     * // subsequent calls will reuse the cached bounds\n     * const cachedBounds = container.getLocalBounds();\n     * console.log(bounds === cachedBounds); // true\n     * ```\n     * @returns The bounding area\n     * @see {@link Container#getBounds} For world space bounds\n     * @see {@link Bounds} For bounds properties\n     */\n    getLocalBounds(): Bounds;\n    /**\n     * Calculates and returns the (world) bounds of the display object as a Rectangle.\n     * Takes into account transforms and child bounds.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const bounds = sprite.getBounds();\n     * console.log(`World bounds: ${bounds.x}, ${bounds.y}, ${bounds.width}, ${bounds.height}`);\n     *\n     * // Reuse bounds object for performance\n     * const recycleBounds = new Bounds();\n     * sprite.getBounds(false, recycleBounds);\n     *\n     * // Skip update for performance\n     * const fastBounds = sprite.getBounds(true);\n     * ```\n     * @remarks\n     * - Includes transform calculations\n     * - Updates scene graph by default\n     * - Can reuse bounds objects\n     * - Common in hit testing\n     * @param {boolean} skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param {Bounds} bounds - Optional bounds to store the result of the bounds calculation\n     * @returns The minimum axis-aligned rectangle in world space that fits around this object\n     * @see {@link Container#getLocalBounds} For untransformed bounds\n     * @see {@link Bounds} For bounds properties\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    /** @private */\n    _localBoundsCacheData: LocalBoundsCacheData;\n    /** @private */\n    _localBoundsCacheId: number;\n    /** @private */\n    _setWidth(width: number, localWidth: number): void;\n    /** @private */\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\n/** @internal */\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n", "import type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\n\n/** @internal */\nexport interface OnRenderMixinConstructor\n{\n    /**\n     * This callback is used when the container is rendered. It runs every frame during the render process,\n     * making it ideal for per-frame updates and animations.\n     *\n     * > [!NOTE] In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * > and \"updateTransform\" is no longer called every frame\n     * @example\n     * ```ts\n     * // Basic rotation animation\n     * const container = new Container();\n     * container.onRender = () => {\n     *     container.rotation += 0.01;\n     * };\n     *\n     * // Cleanup when done\n     * container.onRender = null; // Removes callback\n     * ```\n     * @param renderer - The renderer instance\n     * @see {@link Renderer} For renderer capabilities\n     */\n    onRender?: ((renderer: Renderer) => void) | null;\n}\n\n/**\n * The OnRenderMixin interface provides a way to define a callback that is executed\n * every time the container is rendered. This is useful for adding custom rendering logic\n * or animations that need to be updated each frame.\n * @category scene\n * @advanced\n */\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    /** @private */\n    _onRender: ((renderer: Renderer) => void) | null;\n}\n\n/** @internal */\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: (renderer: Renderer) => void)\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    get onRender(): (renderer: Renderer) => void\n    {\n        return this._onRender;\n    }\n} as Container;\n", "import type { Container } from '../Container';\n\n/** @ignore */\nexport interface SortMixinConstructor\n{\n    /**\n     * The zIndex of the container.\n     *\n     * Controls the rendering order of children within their parent container.\n     *\n     * A higher value will mean it will be moved towards the front of the rendering order.\n     * @example\n     * ```ts\n     * // Add in any order\n     * container.addChild(character, background, foreground);\n     *\n     * // Adjust rendering order\n     * background.zIndex = 0;\n     * character.zIndex = 1;\n     * foreground.zIndex = 2;\n     * ```\n     * @see {@link Container#sortableChildren} For enabling sorting\n     * @see {@link Container#sortChildren} For manual sorting\n     * @default 0\n     */\n    zIndex?: number;\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @default false\n     * @internal\n     */\n    sortDirty?: boolean;\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array of children,\n     * so it will affect the rendering order.\n     *\n     * > [!NOTE] Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * > as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @example\n     * ```ts\n     * container.sortableChildren = true;\n     * ```\n     * @default false\n     */\n    sortableChildren?: boolean;\n}\n\n/**\n * The SortMixin interface provides methods and properties for sorting children of a container\n * based on their `zIndex` values. It allows for automatic sorting of children when their `zIndex`\n * changes or when new children are added. The mixin includes properties to manage sorting state\n * and methods to sort children explicitly.\n * @category scene\n * @advanced\n */\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    /** @internal */\n    _zIndex: number;\n    /**\n     * Sorts children by zIndex value. Only sorts if container is marked as dirty.\n     * @example\n     * ```ts\n     * // Basic sorting\n     * particles.zIndex = 2;     // Will mark as dirty\n     * container.sortChildren();\n     * ```\n     * @see {@link Container#sortableChildren} For enabling automatic sorting\n     * @see {@link Container#zIndex} For setting child order\n     */\n    sortChildren: () => void;\n    /** @internal */\n    depthOfChildModified: () => void;\n}\n\n/** @internal */\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    sortDirty: false,\n    sortableChildren: false,\n\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n    },\n\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n", "import { Point } from '../../../maths/point/Point';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\n/**\n * Interface for a mixin that provides methods to convert between local and global coordinates.\n * This mixin allows you to get the global position of a container,\n * convert a point from local to global coordinates,\n * and convert a point from global to local coordinates.\n *\n * It includes methods to optimize performance by using cached matrices when available.\n * @category scene\n * @advanced\n */\nexport interface ToLocalGlobalMixin\n{\n    /**\n     * Returns the global position of the container, taking into account the container hierarchy.\n     * @example\n     * ```ts\n     * // Basic position check\n     * const globalPos = sprite.getGlobalPosition();\n     * console.log(`Global: (${globalPos.x}, ${globalPos.y})`);\n     *\n     * // Reuse point object\n     * const point = new Point();\n     * sprite.getGlobalPosition(point);\n     *\n     * // Skip transform update for performance\n     * const fastPos = container.getGlobalPosition(undefined, true);\n     * ```\n     * @param {Point} point - The optional point to write the global value to\n     * @param {boolean} skipUpdate - Should we skip the update transform\n     * @returns The updated point\n     * @see {@link Container#toGlobal} For converting specific points\n     * @see {@link Container#toLocal} For converting to local space\n     */\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    /**\n     * Calculates the global position of a point relative to this container.\n     * Takes into account the container hierarchy and transforms.\n     * @example\n     * ```ts\n     * // Basic point conversion\n     * const localPoint = { x: 10, y: 20 };\n     * const globalPoint = container.toGlobal(localPoint);\n     *\n     * // With point reuse\n     * const reusePoint = new Point();\n     * container.toGlobal(localPoint, reusePoint);\n     *\n     * // Performance optimization\n     * const fastPoint = container.toGlobal(\n     *     { x: 50, y: 50 },\n     *     undefined,\n     *     true // Skip transform update\n     * );\n     * ```\n     * @param {PointData} position - The local point to convert\n     * @param {P} point - Optional point to store the result\n     * @param {boolean} skipUpdate - Whether to skip transform updates\n     * @returns The global position\n     * @see {@link Container#toLocal} For reverse conversion\n     * @see {@link Container#getGlobalPosition} For container position\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    /**\n     * Calculates the local position of the container relative to another point.\n     * Converts coordinates from any coordinate space to this container's local coordinate space.\n     * @example\n     * ```ts\n     * // Basic coordinate conversion\n     * const worldPoint = { x: 100, y: 100 };\n     * const localPos = container.toLocal(worldPoint);\n     *\n     * // Convert from another container\n     * const fromSprite = new Sprite(texture);\n     * fromSprite.position.set(50, 50);\n     * const pointInSprite = { x: 10, y: 10 };\n     * const localPoint = container.toLocal(pointInSprite, fromSprite);\n     *\n     * // With point reuse for performance\n     * const reusePoint = new Point();\n     * container.toLocal(worldPoint, undefined, reusePoint);\n     *\n     * // Skip transform update for static objects\n     * const fastLocal = container.toLocal(\n     *     worldPoint,\n     *     undefined,\n     *     undefined,\n     *     true\n     * );\n     * ```\n     * @param {PointData} position - The world origin to calculate from\n     * @param {Container} from - The Container to calculate the global position from\n     * @param {P} point - A Point object in which to store the value\n     * @param {boolean} skipUpdate - Should we skip the update transform\n     * @returns A point object representing the position in local space\n     * @see {@link Container#toGlobal} For reverse conversion\n     * @see {@link Container#getGlobalPosition} For container position\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\n/** @internal */\nexport const toLocalGlobalMixin: Partial<Container> = {\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.apply(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    },\n\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.applyInverse(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    }\n} as Container;\n", "import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\nimport { TextureStyle } from './TextureStyle';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @category rendering\n * @advanced\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /** The default texture style for the pool */\n    public textureStyle: TextureStyle;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n        this.textureStyle = new TextureStyle(this.textureOptions);\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: false,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.\n     * useful if you modified the style of the texture after getting it from the pool.\n     * @param renderTexture - The renderTexture to free\n     * @param resetStyle - Whether to reset the style of the texture to the default texture style\n     */\n    public returnTexture(renderTexture: Texture, resetStyle = false): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        // we can skip the copy if we don't need to reset the style\n        if (resetStyle)\n        {\n            renderTexture.source.style = this.textureStyle;\n        }\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\n/**\n * The default texture pool instance.\n * @category rendering\n * @advanced\n */\nexport const TexturePool = new TexturePoolClass();\nGlobalResourceRegistry.register(TexturePool);\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type SCALE_MODE } from '../../rendering/renderers/shared/texture/const';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer } from '../../rendering/renderers/types';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BatchableSprite } from '../sprite/BatchableSprite';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Bounds } from './bounds/Bounds';\nimport type { Container } from './Container';\n\n/**\n * Options for caching a container as a texture.\n * @category rendering\n * @advanced\n */\nexport interface CacheAsTextureOptions\n{\n    /**\n     * If true, the texture will be antialiased. This smooths out the edges of the texture.\n     * @default false\n     */\n    antialias?: boolean;\n    /**\n     * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n     * By default the resolution is 1 which is the same as the rendererers resolution.\n     */\n    resolution?: number;\n    /**\n     * Scale Mode to use for the cached texture\n     * @type {SCALE_MODE}\n     * @default 'linear'\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.cacheAsTexture({ scaleMode: 'nearest' });\n     * ```\n     * @see {@link SCALE_MODE}\n     */\n    scaleMode?: SCALE_MODE;\n}\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @category rendering\n * @advanced\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n    public gcTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    public textureNeedsUpdate = true;\n\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    public isCachedAsTexture = false;\n\n    /**\n     * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n     * It can only be accessed after a render pass.\n     * @type {Texture | undefined}\n     */\n    public texture?: Texture;\n\n    /**\n     * The bounds of the cached texture.\n     * @type {Bounds | undefined}\n     * @ignore\n     */\n    public _textureBounds?: Bounds;\n\n    /**\n     * The options for caching the container as a texture.\n     * @type {CacheAsTextureOptions}\n     */\n    public textureOptions: CacheAsTextureOptions;\n\n    /**\n     *  holds a reference to the batchable render sprite\n     *  @ignore\n     */\n    public _batchableRenderGroup: BatchableSprite;\n\n    /**\n     * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @type {RenderGroup | null}\n     * @ignore\n     */\n    public _parentCacheAsTextureRenderGroup: RenderGroup;\n\n    private _inverseWorldTransform: Matrix;\n    private _textureOffsetInverseTransform: Matrix;\n    private _inverseParentTextureTransform: Matrix;\n\n    private _matrixDirty = 0b111;\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            // make sure the children are all updated on the first pass..\n            child._updateFlags = 0b1111;\n\n            this.addChild(child);\n        }\n    }\n\n    public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void\n    {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n\n    public disableCacheAsTexture(): void\n    {\n        this.isCachedAsTexture = false;\n        if (this.texture)\n        {\n            TexturePool.returnTexture(this.texture, true);\n            this.texture = null;\n        }\n    }\n\n    public updateCacheTexture(): void\n    {\n        this.textureNeedsUpdate = true;\n\n        const cachedParent = this._parentCacheAsTextureRenderGroup;\n\n        // It's worth going bottom-up and notify all parents cached as texture\n        // that cached child was updated.\n        if (cachedParent && !cachedParent.textureNeedsUpdate)\n        {\n            cachedParent.updateCacheTexture();\n        }\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n\n        this.disableCacheAsTexture();\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    public updateRenderable(renderable: ViewContainer)\n    {\n        if (renderable.globalDisplayStatus < 0b111) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender(renderer: Renderer)\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender(renderer);\n        }\n    }\n\n    public destroy()\n    {\n        this.disableCacheAsTexture();\n\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    public invalidateMatrices()\n    {\n        this._matrixDirty = 0b111;\n    }\n\n    /**\n     * Returns the inverse of the world transform matrix.\n     * @returns {Matrix} The inverse of the world transform matrix.\n     */\n    public get inverseWorldTransform()\n    {\n        if ((this._matrixDirty & 0b001) === 0) return this._inverseWorldTransform;\n\n        this._matrixDirty &= ~0b001;\n\n        // TODO - add dirty flag\n        this._inverseWorldTransform ||= new Matrix();\n\n        return this._inverseWorldTransform\n            .copyFrom(this.worldTransform)\n            .invert();\n    }\n\n    /**\n     * Returns the inverse of the texture offset transform matrix.\n     * @returns {Matrix} The inverse of the texture offset transform matrix.\n     */\n    public get textureOffsetInverseTransform()\n    {\n        if ((this._matrixDirty & 0b010) === 0) return this._textureOffsetInverseTransform;\n\n        this._matrixDirty &= ~0b010;\n\n        this._textureOffsetInverseTransform ||= new Matrix();\n\n        // TODO shared.. bad!\n        return this._textureOffsetInverseTransform\n            .copyFrom(this.inverseWorldTransform)\n            .translate(\n                -this._textureBounds.x,\n                -this._textureBounds.y\n            );\n    }\n\n    /**\n     * Returns the inverse of the parent texture transform matrix.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @returns {Matrix} The inverse of the parent texture transform matrix.\n     */\n    public get inverseParentTextureTransform()\n    {\n        if ((this._matrixDirty & 0b100) === 0) return this._inverseParentTextureTransform;\n\n        this._matrixDirty &= ~0b100;\n\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n\n        if (parentCacheAsTexture)\n        {\n            this._inverseParentTextureTransform ||= new Matrix();\n\n            // Get relative transform by removing parent's world transform\n            return this._inverseParentTextureTransform\n                .copyFrom(this.worldTransform)\n                .prepend(parentCacheAsTexture.inverseWorldTransform)\n                // Offset by texture bounds\n                .translate(\n                    -parentCacheAsTexture._textureBounds.x,\n                    -parentCacheAsTexture._textureBounds.y\n                );\n        }\n\n        return this.worldTransform;\n    }\n\n    /**\n     * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n     * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n     * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n     * or null if no parent is cached as texture.\n     */\n    public get cacheToLocalTransform()\n    {\n        if (this.isCachedAsTexture)\n        {\n            return this.textureOffsetInverseTransform;\n        }\n\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n", "/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n * @category utils\n * @internal\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { extensions } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { type RenderLayer } from '../layers/RenderLayer';\nimport { cacheAsTextureMixin } from './container-mixins/cacheAsTextureMixin';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { collectRenderablesMixin } from './container-mixins/collectRenderablesMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { getFastGlobalBoundsMixin } from './container-mixins/getFastGlobalBoundsMixin';\nimport { bgr2rgb, getGlobalMixin } from './container-mixins/getGlobalMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\n/**\n * The type of child that can be added to a {@link Container}.\n * This is a generic type that extends the {@link Container} class.\n * @category scene\n * @standard\n */\nexport type ContainerChild = Container;\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst defaultOrigin = new ObservablePoint(null);\n\n/**\n * Events that can be emitted by a Container. These events provide lifecycle hooks and notifications\n * for container state changes.\n * @example\n * ```ts\n * import { Container, Sprite } from 'pixi.js';\n *\n * // Setup container with event listeners\n * const container = new Container();\n *\n * // Listen for child additions\n * container.on('childAdded', (child, container, index) => {\n *     console.log(`Child added at index ${index}:`, child);\n * });\n *\n * // Listen for child removals\n * container.on('childRemoved', (child, container, index) => {\n *     console.log(`Child removed from index ${index}:`, child);\n * });\n *\n * // Listen for when container is added to parent\n * container.on('added', (parent) => {\n *     console.log('Added to parent:', parent);\n * });\n *\n * // Listen for when container is removed from parent\n * container.on('removed', (parent) => {\n *     console.log('Removed from parent:', parent);\n * });\n *\n * // Listen for container destruction\n * container.on('destroyed', (container) => {\n *     console.log('Container destroyed:', container);\n * });\n * ```\n * @category scene\n * @standard\n */\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    /**\n     * Emitted when this container is added to a new container.\n     * Useful for setting up parent-specific behaviors.\n     * @param container - The parent container this was added to\n     * @example\n     * ```ts\n     * const child = new Container();\n     * child.on('added', (parent) => {\n     *     console.log('Child added to parent:', parent.label);\n     * });\n     * parentContainer.addChild(child);\n     * ```\n     */\n    added: [container: Container];\n\n    /**\n     * Emitted when a child is added to this container.\n     * Useful for tracking container composition changes.\n     * @param child - The child that was added\n     * @param container - The container the child was added to (this container)\n     * @param index - The index at which the child was added\n     * @example\n     * ```ts\n     * const parent = new Container();\n     * parent.on('childAdded', (child, container, index) => {\n     *     console.log(`New child at index ${index}:`, child);\n     * });\n     * ```\n     */\n    childAdded: [child: C, container: Container, index: number];\n\n    /**\n     * Emitted when this container is removed from its parent.\n     * Useful for cleanup and state management.\n     * @param container - The parent container this was removed from\n     * @example\n     * ```ts\n     * const child = new Container();\n     * child.on('removed', (oldParent) => {\n     *     console.log('Child removed from parent:', oldParent.label);\n     * });\n     * ```\n     */\n    removed: [container: Container];\n\n    /**\n     * Emitted when a child is removed from this container.\n     * Useful for cleanup and maintaining container state.\n     * @param child - The child that was removed\n     * @param container - The container the child was removed from (this container)\n     * @param index - The index from which the child was removed\n     * @example\n     * ```ts\n     * const parent = new Container();\n     * parent.on('childRemoved', (child, container, index) => {\n     *     console.log(`Child removed from index ${index}:`, child);\n     * });\n     * ```\n     */\n    childRemoved: [child: C, container: Container, index: number];\n\n    /**\n     * Emitted when the container is destroyed.\n     * Useful for final cleanup and resource management.\n     * @param container - The container that was destroyed\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.on('destroyed', (container) => {\n     *     console.log('Container destroyed:', container.label);\n     * });\n     * ```\n     */\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\n/** @internal */\nexport const UPDATE_COLOR = 0b0001;\n/** @internal */\nexport const UPDATE_BLEND = 0b0010;\n/** @internal */\nexport const UPDATE_VISIBLE = 0b0100;\n/** @internal */\nexport const UPDATE_TRANSFORM = 0b1000;\n\n/**\n * Options for updating the transform of a container.\n * @category scene\n * @standard\n */\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n    originX: number;\n    originY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @category scene\n * @standard\n * @see Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /**\n     * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n     *\n     * Setting to 'normal' will reset to default blending.\n     * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n     * @example\n     * ```ts\n     * // Basic blend modes\n     * new Container({ blendMode: 'normal' }); // Default blending\n     * new Container({ blendMode: 'add' });    // Additive blending\n     * new Container({ blendMode: 'multiply' }); // Multiply colors\n     * new Container({ blendMode: 'screen' }); // Screen blend\n     * ```\n     * @default 'normal'\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#tint} For color adjustments\n     */\n    blendMode?: BLEND_MODES;\n    /**\n     * The tint applied to the sprite.\n     *\n     * This can be any valid {@link ColorSource}.\n     * @example\n     * ```ts\n     * new Container({ tint: 0xff0000 }); // Red tint\n     * new Container({ tint: 'blue' }); // Blue tint\n     * new Container({ tint: '#00ff00' }); // Green tint\n     * new Container({ tint: 'rgb(0,0,255)' }); // Blue tint\n     * ```\n     * @default 0xFFFFFF\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#visible} For visibility control\n     */\n    tint?: ColorSource;\n\n    /**\n     * The opacity of the object relative to its parent's opacity.\n     * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n     * @example\n     * ```ts\n     * new Container({ alpha: 0.5 }); // 50% opacity\n     * new Container({ alpha: 1 }); // Fully opaque\n     * ```\n     * @default 1\n     * @see {@link Container#visible} For toggling visibility\n     * @see {@link Container#renderable} For render control\n     */\n    alpha?: number;\n    /**\n     * The angle of the object in degrees.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * new Container({ angle: 45 }); // Rotate 45 degrees\n     * new Container({ angle: 90 }); // Rotate 90 degrees\n     * ```\n     */\n    angle?: number;\n    /**\n     * The array of children of this container. Each child must be a Container or extend from it.\n     *\n     * The array is read-only, but its contents can be modified using Container methods.\n     * @example\n     * ```ts\n     * new Container({\n     *    children: [\n     *        new Container(), // First child\n     *        new Container(), // Second child\n     *    ],\n     * });\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing children\n     */\n    children?: C[];\n    /**\n     * The display object container that contains this display object.\n     * This represents the parent-child relationship in the display tree.\n     * @readonly\n     * @see {@link Container#addChild} For adding to a parent\n     * @see {@link Container#removeChild} For removing from parent\n     */\n    parent?: Container;\n    /**\n     * Controls whether this object can be rendered. If false the object will not be drawn,\n     * but the transform will still be updated. This is different from visible, which skips\n     * transform updates.\n     * @example\n     * ```ts\n     * new Container({ renderable: false }); // Will not be drawn, but transforms will update\n     * ```\n     * @default true\n     * @see {@link Container#visible} For skipping transform updates\n     * @see {@link Container#alpha} For transparency\n     */\n    renderable?: boolean;\n    /**\n     * The rotation of the object in radians.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * new Container({ rotation: Math.PI / 4 }); // Rotate 45 degrees\n     * new Container({ rotation: Math.PI / 2 }); // Rotate 90 degrees\n     * ```\n     */\n    rotation?: number;\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @example\n     * ```ts\n     * new Container({ scale: new Point(2, 2) }); // Scale by 2x\n     * new Container({ scale: 0.5 }); // Scale by 0.5x\n     * new Container({ scale: { x: 1.5, y: 1.5 } }); // Scale by 1.5x\n     * ```\n     */\n    scale?: PointData | number;\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space.\n     * The `position` is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @example\n     * ```ts\n     * new Container({ pivot: new Point(100, 200) }); // Set pivot to (100, 200)\n     * new Container({ pivot: 50 }); // Set pivot to (50, 50)\n     * new Container({ pivot: { x: 150, y: 150 } }); // Set pivot to (150, 150)\n     * ```\n     */\n    pivot?: PointData | number;\n    /**\n     * The origin point around which the container rotates and scales.\n     * Unlike pivot, changing origin will not move the container's position.\n     * @example\n     * ```ts\n     * new Container({ origin: new Point(100, 100) }); // Rotate around point (100,100)\n     * new Container({ origin: 50 }); // Rotate around point (50, 50)\n     * new Container({ origin: { x: 150, y: 150 } }); // Rotate around point (150, 150)\n     * ```\n     */\n    origin?: PointData | number;\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @example\n     * ```ts\n     * new Container({ position: new Point(100, 200) }); // Set position to (100, 200)\n     * new Container({ position: { x: 150, y: 150 } }); // Set position to (150, 150)\n     * ```\n     */\n    position?: PointData;\n    /**\n     * The skew factor for the object in radians. Skewing is a transformation that distorts\n     * the object by rotating it differently at each point, creating a non-uniform shape.\n     * @example\n     * ```ts\n     * new Container({ skew: new Point(0.1, 0.2) }); // Skew by 0.1 radians on x and 0.2 radians on y\n     * new Container({ skew: { x: 0.1, y: 0.2 } }); // Skew by 0.1 radians on x and 0.2 radians on y\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    skew?: PointData;\n    /**\n     * The visibility of the object. If false the object will not be drawn,\n     * and the transform will not be updated.\n     * @example\n     * ```ts\n     * new Container({ visible: false }); // Will not be drawn and transforms will not update\n     * new Container({ visible: true }); // Will be drawn and transforms will update\n     * ```\n     * @default true\n     * @see {@link Container#renderable} For render-only control\n     * @see {@link Container#alpha} For transparency\n     */\n    visible?: boolean;\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.x\n     * @example\n     * ```ts\n     * new Container({ x: 100 }); // Set x position to 100\n     * ```\n     */\n    x?: number;\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.y\n     * @example\n     * ```ts\n     * new Container({ y: 200 }); // Set y position to 200\n     * ```\n     */\n    y?: number;\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     *\n     * > [!IMPORTANT] This is great for optimisation! If for example you have a\n     * > 1000 spinning particles and you know they all sit within a specific bounds,\n     * > then setting it will mean the renderer will not need to measure the\n     * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n     * @example\n     * ```ts\n     * const container = new Container({\n     *    boundsArea: new Rectangle(0, 0, 500, 500) // Set a fixed bounds area\n     * });\n     * ```\n     */\n    boundsArea?: Rectangle;\n}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Container<C extends ContainerChild>\n    extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link Container#localTransform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *          and \"skew.y\" is , then the line x = 0 will be rotated by  (y = -x*cot) and the line y = 0 will be\n *         rotated by  (y = x*tan). A line y = x*tan (i.e. a line at angle  to the x-axis in local-space) will\n *         be rotated by an angle between  and .\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = - and \"skew.y\" = , it will produce an equivalent of \"rotation\" = .\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJSs rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @category scene\n * @standard\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     * @deprecated since 8.8.0\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        // #if _DEBUG\n        deprecation('8.8.0', 'Container.mixin is deprecated, please use extensions.mixin instead.');\n        // #endif\n        extensions.mixin(Container, source);\n    }\n\n    /**\n     * unique id for this container\n     * @internal\n     */\n    public readonly uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // the render group this container owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    public parentRenderGroup: RenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    public parentRenderGroupIndex: number = 0;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container. Each child must be a Container or extend from it.\n     *\n     * The array is read-only, but its contents can be modified using Container methods.\n     * @example\n     * ```ts\n     * // Access children\n     * const firstChild = container.children[0];\n     * const lastChild = container.children[container.children.length - 1];\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing children\n     */\n    public children: C[] = [];\n    /**\n     * The display object container that contains this display object.\n     * This represents the parent-child relationship in the display tree.\n     * @example\n     * ```ts\n     * // Basic parent access\n     * const parent = sprite.parent;\n     *\n     * // Walk up the tree\n     * let current = sprite;\n     * while (current.parent) {\n     *     console.log('Level up:', current.parent.constructor.name);\n     *     current = current.parent;\n     * }\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding to a parent\n     * @see {@link Container#removeChild} For removing from parent\n     */\n    public parent: Container | null = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    /**\n     * The RenderLayer this container belongs to, if any.\n     * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.\n     * @readonly\n     * @advanced\n     */\n    public parentRenderLayer: RenderLayer | null = null;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /** @internal */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * This matrix represents the local transformation without any parent influence.\n     * @example\n     * ```ts\n     * // Basic transform access\n     * const localMatrix = sprite.localTransform;\n     * console.log(localMatrix.toString());\n     * ```\n     * @readonly\n     * @see {@link Container#worldTransform} For global transform\n     * @see {@link Container#groupTransform} For render group transform\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     * @advanced\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     * @advanced\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /**\n     * Whether this object has been destroyed. If true, the object should no longer be used.\n     * After an object is destroyed, all of its functionality is disabled and references are removed.\n     * @example\n     * ```ts\n     * // Cleanup with destroy\n     * sprite.destroy();\n     * console.log(sprite.destroyed); // true\n     * ```\n     * @default false\n     * @see {@link Container#destroy} For destroying objects\n     */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The origin point around which the container rotates and scales.\n     * Unlike pivot, changing origin will not move the container's position.\n     * @private\n     */\n    public _origin: ObservablePoint = defaultOrigin;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    /** @internal */\n    public localColor = 0xFFFFFF;\n    /** @internal */\n    public localAlpha = 1;\n\n    /** @internal */\n    public groupAlpha = 1; // A\n    /** @internal */\n    public groupColor = 0xFFFFFF; // BGR\n    /** @internal */\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /** @internal */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /** @internal */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /** @internal */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    /** @internal */\n    public readonly renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     *\n     * > [!IMPORTANT] This is great for optimisation! If for example you have a\n     * > 1000 spinning particles and you know they all sit within a specific bounds,\n     * > then setting it will mean the renderer will not need to measure the\n     * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.boundsArea = new Rectangle(0, 0, 500, 500);\n     * ```\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    public _didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    public _didViewChangeTick = 0;\n\n    /** @internal */\n    public layerParentId: string;// = 'default';\n    /**\n     * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n     * @deprecated since 8.2.6\n     * @ignore\n     */\n    set _didChangeId(value: number)\n    {\n        this._didViewChangeTick = (value >> 12) & 0xFFF; // Extract the upper 12 bits\n        this._didContainerChangeTick = value & 0xFFF; // Extract the lower 12 bits\n    }\n    /** @ignore */\n    get _didChangeId(): number\n    {\n        return (this._didContainerChangeTick & 0xfff) | ((this._didViewChangeTick & 0xfff) << 12);\n    }\n\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        this.effects = [];\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     * The children will be rendered as part of this container's display list.\n     * @example\n     * ```ts\n     * // Add a single child\n     * container.addChild(sprite);\n     *\n     * // Add multiple children\n     * container.addChild(background, player, foreground);\n     *\n     * // Add with type checking\n     * const sprite = container.addChild<Sprite>(new Sprite(texture));\n     * sprite.tint = 'red';\n     * ```\n     * @param children - The Container(s) to add to the container\n     * @returns The first child that was added\n     * @see {@link Container#removeChild} For removing children\n     * @see {@link Container#addChildAt} For adding at specific index\n     */\n    public addChild<U extends C[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n\n        // TODO - Optimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        this._didViewChangeTick++;\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * When removing multiple children, events will be triggered for each child in sequence.\n     * @example\n     * ```ts\n     * // Remove a single child\n     * const removed = container.removeChild(sprite);\n     *\n     * // Remove multiple children\n     * const bg = container.removeChild(background, player, userInterface);\n     *\n     * // Remove with type checking\n     * const sprite = container.removeChild<Sprite>(childSprite);\n     * sprite.texture = newTexture;\n     * ```\n     * @param children - The Container(s) to remove\n     * @returns The first child that was removed\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChildren} For removing multiple children\n     */\n    public removeChild<U extends C[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._didViewChangeTick++;\n\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n            else if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.removeChild(child);\n            }\n\n            if (child.parentRenderLayer)\n            {\n                child.parentRenderLayer.detach(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didContainerChangeTick++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (!!this.renderGroup === value) return;\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n        else\n        {\n            this.disableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     * @advanced\n     */\n    get isRenderGroup(): boolean\n    {\n        return !!this.renderGroup;\n    }\n\n    /**\n     * Calling this enables a render group for this container.\n     * This means it will be rendered as a separate set of instructions.\n     * The transform of the container will also be handled on the GPU rather than the CPU.\n     * @advanced\n     */\n    public enableRenderGroup(): void\n    {\n        if (this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        this.renderGroup = BigPool.get(RenderGroup, this);\n\n        // this group matrix will now be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /**\n     * This will disable the render group for this container.\n     * @advanced\n     */\n    public disableRenderGroup(): void\n    {\n        if (!this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        BigPool.return(this.renderGroup);\n\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.renderGroup) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     *\n     * This matrix represents the absolute transformation in the scene graph.\n     * @example\n     * ```ts\n     * // Get world position\n     * const worldPos = container.worldTransform;\n     * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);\n     * ```\n     * @readonly\n     * @see {@link Container#localTransform} For local space transform\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        }\n        else if (this.parentRenderGroup)\n        {\n            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        }\n\n        return this._worldTransform;\n    }\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.x\n     * @example\n     * ```ts\n     * // Basic position\n     * container.x = 100;\n     * ```\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.y\n     * @example\n     * ```ts\n     * // Basic position\n     * container.y = 200;\n     * ```\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * container.position.set(100, 200);\n     * container.position.set(100); // Sets both x and y to 100\n     * // Using point data\n     * container.position = { x: 50, y: 75 };\n     * ```\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * // Basic rotation\n     * container.rotation = Math.PI / 4; // 45 degrees\n     *\n     * // Convert from degrees\n     * const degrees = 45;\n     * container.rotation = degrees * Math.PI / 180;\n     *\n     * // Rotate around center\n     * container.pivot.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // 180 degrees\n     *\n     * // Rotate around center with origin\n     * container.origin.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // 180 degrees\n     * ```\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * // Basic angle rotation\n     * sprite.angle = 45; // 45 degrees\n     *\n     * // Rotate around center\n     * sprite.pivot.set(sprite.width / 2, sprite.height / 2);\n     * sprite.angle = 180; // Half rotation\n     *\n     * // Rotate around center with origin\n     * sprite.origin.set(sprite.width / 2, sprite.height / 2);\n     * sprite.angle = 180; // Half rotation\n     *\n     * // Reset rotation\n     * sprite.angle = 0;\n     * ```\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space.\n     * The `position` is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @example\n     * ```ts\n     * // Rotate around center\n     * container.pivot.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // Rotates around center\n     * ```\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n\n            // #if _DEBUG\n            if (this._origin !== defaultOrigin)\n            {\n                // eslint-disable-next-line max-len\n                warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);\n            }\n            // #endif\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians. Skewing is a transformation that distorts\n     * the object by rotating it differently at each point, creating a non-uniform shape.\n     * @example\n     * ```ts\n     * // Basic skewing\n     * container.skew.set(0.5, 0); // Skew horizontally\n     * container.skew.set(0, 0.5); // Skew vertically\n     *\n     * // Skew with point data\n     * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew\n     *\n     * // Reset skew\n     * container.skew.set(0, 0);\n     *\n     * // Animate skew\n     * app.ticker.add(() => {\n     *     // Create wave effect\n     *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;\n     * });\n     *\n     * // Combine with rotation\n     * container.rotation = Math.PI / 4; // 45 degrees\n     * container.skew.set(0.2, 0.2); // Skew the rotated object\n     * ```\n     * @since 4.0.0\n     * @type {ObservablePoint} Point-like object with x/y properties in radians\n     * @default {x: 0, y: 0}\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @example\n     * ```ts\n     * // Basic scaling\n     * container.scale.set(2, 2); // Scales to double size\n     * container.scale.set(2); // Scales uniformly to double size\n     * container.scale = 2; // Scales uniformly to double size\n     * // Scale to a specific width and height\n     * container.setSize(200, 100); // Sets width to 200 and height to 100\n     * ```\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number | string)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        if (typeof value === 'string')\n        {\n            value = parseFloat(value);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * @experimental\n     * The origin point around which the container rotates and scales without affecting its position.\n     * Unlike pivot, changing the origin will not move the container's position.\n     * @example\n     * ```ts\n     * // Rotate around center point\n     * container.origin.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // Rotates around center\n     *\n     * // Reset origin\n     * container.origin.set(0, 0);\n     * ```\n     */\n    get origin(): ObservablePoint\n    {\n        if (this._origin === defaultOrigin)\n        {\n            this._origin = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._origin;\n    }\n\n    set origin(value: PointData | number)\n    {\n        if (this._origin === defaultOrigin)\n        {\n            this._origin = new ObservablePoint(this, 0, 0);\n\n            // #if _DEBUG\n            if (this._pivot !== defaultPivot)\n            {\n                // eslint-disable-next-line max-len\n                warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);\n            }\n            // #endif\n        }\n\n        typeof value === 'number' ? this._origin.set(value) : this._origin.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.\n     * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n     * as it is more optimized by not recalculating the local bounds twice.\n     * @example\n     * ```ts\n     * // Basic width setting\n     * container.width = 100;\n     * // Optimized width setting\n     * container.setSize(100, 100);\n     * ```\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container,\n     * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.\n     * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n     * as it is more optimized by not recalculating the local bounds twice.\n     * @example\n     * ```ts\n     * // Basic height setting\n     * container.height = 200;\n     * // Optimized height setting\n     * container.setSize(100, 200);\n     * ```\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     *\n     * This is faster than get the width and height separately.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const size = container.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * container.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in.\n     * @returns The size of the container.\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is more efficient than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * container.setSize(100, 200);\n     *\n     * // Set uniform size\n     * container.setSize(100); // Sets both width and height to 100\n     * ```\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, size.width);\n        height !== undefined && this._setHeight(height, size.height);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container.\n     * Allows partial updates of transform properties for optimized manipulation.\n     * @example\n     * ```ts\n     * // Basic transform update\n     * container.updateTransform({\n     *     x: 100,\n     *     y: 200,\n     *     rotation: Math.PI / 4\n     * });\n     *\n     * // Scale and rotate around center\n     * sprite.updateTransform({\n     *     pivotX: sprite.width / 2,\n     *     pivotY: sprite.height / 2,\n     *     scaleX: 2,\n     *     scaleY: 2,\n     *     rotation: Math.PI\n     * });\n     *\n     * // Update position only\n     * button.updateTransform({\n     *     x: button.x + 10, // Move right\n     *     y: button.y      // Keep same y\n     * });\n     * ```\n     * @param opts - Transform options to update\n     * @param opts.x - The x position\n     * @param opts.y - The y position\n     * @param opts.scaleX - The x-axis scale factor\n     * @param opts.scaleY - The y-axis scale factor\n     * @param opts.rotation - The rotation in radians\n     * @param opts.skewX - The x-axis skew factor\n     * @param opts.skewY - The y-axis skew factor\n     * @param opts.pivotX - The x-axis pivot point\n     * @param opts.pivotY - The y-axis pivot point\n     * @returns This container, for chaining\n     * @see {@link Container#setFromMatrix} For matrix-based transforms\n     * @see {@link Container#position} For direct position access\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n        this.origin.set(\n            typeof opts.originX === 'number' ? opts.originX : this.origin.x,\n            typeof opts.originY === 'number' ? opts.originY : this.origin.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform properties by decomposing the given matrix.\n     * Extracts position, scale, rotation, and skew from a transformation matrix.\n     * @example\n     * ```ts\n     * // Basic matrix transform\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * container.setFromMatrix(matrix);\n     *\n     * // Copy transform from another container\n     * const source = new Container();\n     * source.position.set(100, 100);\n     * source.rotation = Math.PI / 2;\n     *\n     * target.setFromMatrix(source.localTransform);\n     *\n     * // Reset transform\n     * container.setFromMatrix(Matrix.IDENTITY);\n     * ```\n     * @param matrix - The matrix to use for updating the transform\n     * @see {@link Container#updateTransform} For property-based updates\n     * @see {@link Matrix#decompose} For matrix decomposition details\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        const localTransformChangeId = this._didContainerChangeTick;\n\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n\n        this._didLocalTransformChangeId = localTransformChangeId;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const origin = this._origin;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        const ox = -origin._x;\n        const oy = -origin._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c)) // Pivot offset\n            + ((ox * lt.a) + (oy * lt.c)) // Origin offset for rotation and scaling\n            - ox; // Remove origin to maintain position\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d)) // Pivot offset\n            + ((ox * lt.b) + (oy * lt.d)) // Origin offset for rotation and scaling\n            - oy; // Remove origin to maintain position\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The opacity of the object relative to its parent's opacity.\n     * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n     * @example\n     * ```ts\n     * // Basic transparency\n     * sprite.alpha = 0.5; // 50% opacity\n     *\n     * // Inherited opacity\n     * container.alpha = 0.5;\n     * const child = new Sprite(texture);\n     * child.alpha = 0.5;\n     * container.addChild(child);\n     * // child's effective opacity is 0.25 (0.5 * 0.5)\n     * ```\n     * @default 1\n     * @see {@link Container#visible} For toggling visibility\n     * @see {@link Container#renderable} For render control\n     */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite.\n     *\n     * This can be any valid {@link ColorSource}.\n     * @example\n     * ```ts\n     * // Basic color tinting\n     * container.tint = 0xff0000; // Red tint\n     * container.tint = 'red';    // Same as above\n     * container.tint = '#00ff00'; // Green\n     * container.tint = 'rgb(0,0,255)'; // Blue\n     *\n     * // Remove tint\n     * container.tint = 0xffffff; // White = no tint\n     * container.tint = null;     // Also removes tint\n     * ```\n     * @default 0xFFFFFF\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#visible} For visibility control\n     */\n    get tint(): number\n    {\n        // convert bgr to rgb..\n        return bgr2rgb(this.localColor);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n     *\n     * Setting to 'normal' will reset to default blending.\n     * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n     * @example\n     * ```ts\n     * // Basic blend modes\n     * sprite.blendMode = 'add';        // Additive blending\n     * sprite.blendMode = 'multiply';   // Multiply colors\n     * sprite.blendMode = 'screen';     // Screen blend\n     *\n     * // Reset blend mode\n     * sprite.blendMode = 'normal';     // Normal blending\n     * ```\n     * @default 'normal'\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#tint} For color adjustments\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /**\n     * The visibility of the object. If false the object will not be drawn,\n     * and the transform will not be updated.\n     * @example\n     * ```ts\n     * // Basic visibility toggle\n     * sprite.visible = false; // Hide sprite\n     * sprite.visible = true;  // Show sprite\n     * ```\n     * @default true\n     * @see {@link Container#renderable} For render-only control\n     * @see {@link Container#alpha} For transparency\n     */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 0b010 : 0;\n\n        if ((this.localDisplayStatus & 0b010) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 0 : 0b100;\n\n        if ((this.localDisplayStatus & 0b100) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /**\n     * Controls whether this object can be rendered. If false the object will not be drawn,\n     * but the transform will still be updated. This is different from visible, which skips\n     * transform updates.\n     * @example\n     * ```ts\n     * // Basic render control\n     * sprite.renderable = false; // Skip rendering\n     * sprite.renderable = true;  // Enable rendering\n     * ```\n     * @default true\n     * @see {@link Container#visible} For skipping transform updates\n     * @see {@link Container#alpha} For transparency\n     */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 0b001 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /**\n     * Whether or not the object should be rendered.\n     * @advanced\n     */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * ```ts\n     * container.destroy();\n     * container.destroy(true);\n     * container.destroy({ children: true });\n     * container.destroy({ children: true, texture: true, textureSource: true });\n     * ```\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        // remove children is faster than removeChild..\n\n        let oldChildren: ContainerChild[];\n\n        // we add this check as calling removeChildren on particle container will throw an error\n        // As we know it does cannot have any children, check before calling the function.\n        if (this.children.length)\n        {\n            oldChildren = this.removeChildren(0, this.children.length);\n        }\n\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._origin = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        if (destroyChildren && oldChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n\nextensions.mixin(\n    Container,\n    childrenHelperMixin,\n    getFastGlobalBoundsMixin,\n    toLocalGlobalMixin,\n    onRenderMixin,\n    measureMixin,\n    effectsMixin,\n    findMixin,\n    sortMixin,\n    cullingMixin,\n    cacheAsTextureMixin,\n    getGlobalMixin,\n    collectRenderablesMixin,\n);\n", "/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @enum {number}\n * @category ticker\n * @standard\n */\nexport enum UPDATE_PRIORITY\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link PrepareBase} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n", "import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n", "import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * The callback receives the Ticker instance as its parameter, providing access to timing properties.\n * @example\n * ```ts\n * ticker.add((ticker) => {\n *    // Access deltaTime (dimensionless scalar ~1.0 at 60fps)\n *    sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *    // Access deltaMS (milliseconds elapsed)\n *    const progress = ticker.deltaMS / animationDuration;\n * });\n * ```\n * @category ticker\n * @standard\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * Used for managing animation frames and timing in a PixiJS application.\n *\n * It provides a way to add listeners that will be called on each frame,\n * allowing for smooth animations and updates.\n *\n * ## Time Units\n * - `deltaTime`: Dimensionless scalar (typically ~1.0 at 60 FPS) for frame-independent animations\n * - `deltaMS`: Milliseconds elapsed (capped and speed-scaled) for time-based calculations\n * - `elapsedMS`: Raw milliseconds elapsed (uncapped, unscaled) for measurements\n * - `lastTime`: Timestamp in milliseconds since epoch (performance.now() format)\n *\n * Animation frames are requested\n * only when necessary, e.g., when the ticker is started and the emitter has listeners.\n * @example\n * ```ts\n * // Basic ticker usage with different time units\n * const ticker = new Ticker();\n * ticker.add((ticker) => {\n *     // Frame-independent animation using dimensionless deltaTime\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *     // Time-based animation using deltaMS (milliseconds)\n *     sprite.x += (100 / 1000) * ticker.deltaMS; // 100 pixels per second\n * });\n * ticker.start();\n *\n * // Control update priority\n * ticker.add(\n *     (ticker) => {\n *         // High priority updates run first\n *         physics.update(ticker.deltaTime);\n *     },\n *     undefined,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // One-time updates\n * ticker.addOnce(() => {\n *     console.log('Runs on next frame only');\n * });\n * ```\n * @see {@link TickerPlugin} For use with Application\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @see {@link TickerCallback} For listener function type\n * @category ticker\n * @standard\n */\nexport class Ticker\n{\n    /**\n     * Target frame rate in frames per millisecond.\n     * Used for converting deltaTime to a scalar time delta.\n     * @example\n     * ```ts\n     * // Default is 0.06 (60 FPS)\n     * console.log(Ticker.targetFPMS); // 0.06\n     *\n     * // Calculate target frame duration\n     * const frameDuration = 1 / Ticker.targetFPMS; //  16.67ms\n     *\n     * // Use in custom timing calculations\n     * const deltaTime = elapsedMS * Ticker.targetFPMS;\n     * ```\n     * @remarks\n     * - Default is 0.06 (equivalent to 60 FPS)\n     * - Used in deltaTime calculations\n     * - Affects all ticker instances\n     * @default 0.06\n     * @see {@link Ticker#deltaTime} For time scaling\n     * @see {@link Ticker#FPS} For actual frame rate\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method {@link Ticker#start|start}\n     * automatically when a listener is added.\n     * @example\n     * ```ts\n     * // Default behavior (manual start)\n     * const ticker = new Ticker();\n     * ticker.autoStart = false;\n     * ticker.add(() => {\n     *     // Won't run until ticker.start() is called\n     * });\n     *\n     * // Auto-start behavior\n     * const autoTicker = new Ticker();\n     * autoTicker.autoStart = true;\n     * autoTicker.add(() => {\n     *     // Runs immediately when added\n     * });\n     * ```\n     * @default false\n     * @see {@link Ticker#start} For manually starting the ticker\n     * @see {@link Ticker#stop} For manually stopping the ticker\n     */\n    public autoStart = false;\n    /**\n     * Scalar representing the delta time factor.\n     * This is a dimensionless value representing the fraction of a frame at the target framerate.\n     * At 60 FPS, this value is typically around 1.0.\n     *\n     * This is NOT in milliseconds - it's a scalar multiplier for frame-independent animations.\n     * For actual milliseconds, use {@link Ticker#deltaMS}.\n     * @example\n     * ```ts\n     * // Frame-independent animation using deltaTime scalar\n     * ticker.add((ticker) => {\n     *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime\n     *     sprite.rotation += 0.1 * ticker.deltaTime;\n     * });\n     * ```\n     */\n    public deltaTime: number = 1;\n    /**\n     * Scalar time elapsed in milliseconds from last frame to this frame.\n     * Provides precise timing for animations and updates.\n     *\n     * This value is capped by setting {@link Ticker#minFPS|minFPS}\n     * and is scaled with {@link Ticker#speed|speed}.\n     *\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     *\n     * Defaults to target frame time\n     *\n     * > [!NOTE] The cap may be exceeded by scaling.\n     * @example\n     * ```ts\n     * // Animation timing\n     * ticker.add((ticker) => {\n     *     // Use millisecond timing for precise animations\n     *     const progress = (ticker.deltaMS / animationDuration);\n     *     sprite.alpha = Math.min(1, progress);\n     * });\n     * ```\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from the last frame to this frame.\n     * This value is not capped or scaled and provides raw timing information.\n     *\n     * Unlike {@link Ticker#deltaMS}, this value is unmodified by speed scaling or FPS capping.\n     * @example\n     * ```ts\n     * ticker.add((ticker) => {\n     *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n     * });\n     * ```\n     */\n    public elapsedMS: number;\n    /**\n     * The last time update was invoked, in milliseconds since epoch.\n     * Similar to performance.now() timestamp format.\n     *\n     * Used internally for calculating time deltas between frames.\n     * @example\n     * ```ts\n     * ticker.add((ticker) => {\n     *     const currentTime = performance.now();\n     *     const timeSinceLastFrame = currentTime - ticker.lastTime;\n     *     console.log(`Time since last frame: ${timeSinceLastFrame}ms`);\n     * });\n     * ```\n     */\n    public lastTime: number = -1;\n    /**\n     * Factor of current {@link Ticker#deltaTime|deltaTime}.\n     * Used to scale time for slow motion or fast-forward effects.\n     * @example\n     * ```ts\n     * // Basic speed adjustment\n     * ticker.speed = 0.5; // Half speed (slow motion)\n     * ticker.speed = 2.0; // Double speed (fast forward)\n     *\n     * // Temporary speed changes\n     * function slowMotion() {\n     *     const normalSpeed = ticker.speed;\n     *     ticker.speed = 0.2;\n     *     setTimeout(() => {\n     *         ticker.speed = normalSpeed;\n     *     }, 1000);\n     * }\n     * ```\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     *\n     * `true` if {@link Ticker#start|start} has been called.\n     * `false` if {@link Ticker#stop|Stop} has been called.\n     *\n     * While `false`, this value may change to `true` in the\n     * event of {@link Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     * @example\n     * ```ts\n     * // Check ticker state\n     * const ticker = new Ticker();\n     * console.log(ticker.started); // false\n     *\n     * // Start and verify\n     * ticker.start();\n     * console.log(ticker.started); // true\n     * ```\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /** Conditionally cancels a pending animation frame. */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events.\n     * @param fn - The listener function to add. Receives the Ticker instance as parameter\n     * @param context - The context for the listener\n     * @param priority - The priority of the listener\n     * @example\n     * ```ts\n     * // Access time properties through the ticker parameter\n     * ticker.add((ticker) => {\n     *     // Use deltaTime (dimensionless scalar) for frame-independent animations\n     *     sprite.rotation += 0.1 * ticker.deltaTime;\n     *\n     *     // Use deltaMS (milliseconds) for time-based calculations\n     *     const progress = ticker.deltaMS / animationDuration;\n     *\n     *     // Use elapsedMS for raw timing measurements\n     *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n     * });\n     * ```\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only executed once on the next frame.\n     * @example\n     * ```ts\n     * // Basic one-time update\n     * ticker.addOnce(() => {\n     *     console.log('Runs next frame only');\n     * });\n     *\n     * // With specific context\n     * const game = {\n     *     init(ticker) {\n     *         this.loadResources();\n     *         console.log('Game initialized');\n     *     }\n     * };\n     * ticker.addOnce(game.init, game);\n     *\n     * // With priority\n     * ticker.addOnce(\n     *     () => {\n     *         // High priority one-time setup\n     *         physics.init();\n     *     },\n     *     undefined,\n     *     UPDATE_PRIORITY.HIGH\n     * );\n     * ```\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)\n     * @returns This instance of a ticker\n     * @see {@link Ticker#add} For continuous updates\n     * @see {@link Ticker#remove} For removing handlers\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @example\n     * ```ts\n     * // Basic removal\n     * const onTick = () => {\n     *     sprite.rotation += 0.1;\n     * };\n     * ticker.add(onTick);\n     * ticker.remove(onTick);\n     *\n     * // Remove with context\n     * const game = {\n     *     update(ticker) {\n     *         this.physics.update(ticker.deltaTime);\n     *     }\n     * };\n     * ticker.add(game.update, game);\n     * ticker.remove(game.update, game);\n     *\n     * // Remove all matching handlers\n     * // (if same function was added multiple times)\n     * ticker.add(onTick);\n     * ticker.add(onTick);\n     * ticker.remove(onTick); // Removes all instances\n     * ```\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     * @see {@link Ticker#add} For adding handlers\n     * @see {@link Ticker#addOnce} For one-time handlers\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list.\n     * @example\n     * ```ts\n     * // Check number of active listeners\n     * const ticker = new Ticker();\n     * console.log(ticker.count); // 0\n     *\n     * // Add some listeners\n     * ticker.add(() => {});\n     * ticker.add(() => {});\n     * console.log(ticker.count); // 2\n     *\n     * // Check after cleanup\n     * ticker.destroy();\n     * console.log(ticker.count); // 0\n     * ```\n     * @readonly\n     * @see {@link Ticker#add} For adding listeners\n     * @see {@link Ticker#remove} For removing listeners\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /**\n     * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.\n     * @example\n     * ```ts\n     * // Basic manual start\n     * const ticker = new Ticker();\n     * ticker.add(() => {\n     *     // Animation code here\n     * });\n     * ticker.start();\n     * ```\n     * @see {@link Ticker#stop} For stopping the ticker\n     * @see {@link Ticker#autoStart} For automatic starting\n     * @see {@link Ticker#started} For checking ticker state\n     */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /**\n     * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.\n     * @example\n     * ```ts\n     * // Basic stop\n     * const ticker = new Ticker();\n     * ticker.stop();\n     * ```\n     * @see {@link Ticker#start} For starting the ticker\n     * @see {@link Ticker#started} For checking ticker state\n     * @see {@link Ticker#destroy} For cleaning up the ticker\n     */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /**\n     * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.\n     * @example\n     * ```ts\n     * // Clean up with active listeners\n     * const ticker = new Ticker();\n     * ticker.add(() => {});\n     * ticker.destroy(); // Removes all listeners\n     * ```\n     * @see {@link Ticker#stop} For stopping without destroying\n     * @see {@link Ticker#remove} For removing specific listeners\n     */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update.\n     *\n     * An update entails setting the\n     * current {@link Ticker#elapsedMS|elapsedMS},\n     * the current {@link Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     *\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @example\n     * ```ts\n     * // Basic manual update\n     * const ticker = new Ticker();\n     * ticker.update(performance.now());\n     * ```\n     * @param currentTime - The current time of execution (defaults to performance.now())\n     * @see {@link Ticker#deltaTime} For frame delta value\n     * @see {@link Ticker#elapsedMS} For raw elapsed time\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * > [!NOTE] This does not factor in the value of\n     * > {@link Ticker#speed|speed}, which is specific\n     * > to scaling {@link Ticker#deltaTime|deltaTime}.\n     * @example\n     * ```ts\n     * // Basic FPS monitoring\n     * ticker.add(() => {\n     *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);\n     * });\n     * ```\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link Ticker#update|update}.\n     *\n     * This value is used to cap {@link Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link Ticker#FPS|FPS}.\n     *\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @example\n     * ```ts\n     * // Set minimum acceptable frame rate\n     * const ticker = new Ticker();\n     * ticker.minFPS = 30; // Never go below 30 FPS\n     *\n     * // Use with maxFPS for frame rate clamping\n     * ticker.minFPS = 30;\n     * ticker.maxFPS = 60;\n     *\n     * // Monitor delta capping\n     * ticker.add(() => {\n     *     // Delta time will be capped based on minFPS\n     *     console.log(`Delta time: ${ticker.deltaTime}`);\n     * });\n     * ```\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link Ticker#update|update}.\n     *\n     * This will effect the measured value of {@link Ticker#FPS|FPS}.\n     *\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @example\n     * ```ts\n     * // Set minimum acceptable frame rate\n     * const ticker = new Ticker();\n     * ticker.maxFPS = 60; // Never go above 60 FPS\n     *\n     * // Use with maxFPS for frame rate clamping\n     * ticker.minFPS = 30;\n     * ticker.maxFPS = 60;\n     *\n     * // Monitor delta capping\n     * ticker.add(() => {\n     *     // Delta time will be capped based on maxFPS\n     *     console.log(`Delta time: ${ticker.deltaTime}`);\n     * });\n     * ```\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoSource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @type {Ticker}\n     * @readonly\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link PrepareBase} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @type {Ticker}\n     * @readonly\n     * @advanced\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n", "import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\n/**\n * Updates the bounds of a quad (a rectangular area) based on the provided texture and anchor point.\n *\n * This function calculates the minimum and maximum x and y coordinates of the bounds, taking into\n * account the texture's original dimensions and any trimming that may have been applied to it.\n * @param {BoundsData} bounds - The bounds object to be updated. It contains minX, maxX, minY, and maxY properties.\n * @param {ObservablePoint} anchor - The anchor point of the texture, which affects the positioning of the bounds.\n * @param {Texture} texture - The texture whose dimensions and trimming information are used to update the bounds.\n * @internal\n */\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture\n): void\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    // If the texture has trimming information, adjust the bounds accordingly\n    if (trim)\n    {\n        // Calculate the source width and height from the trim\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        // Update the bounds using the trim's x and y offsets and the anchor point\n        bounds.minX = trim.x - (anchor._x * width);\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = trim.y - (anchor._y * height);\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n    // If there is no trimming, calculate the bounds based solely on the texture's original dimensions\n    else\n    {\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { type GCable, type GCData } from '../../rendering/renderers/shared/GCSystem';\nimport { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type GPUDataOwner, type Renderer } from '../../rendering/renderers/types';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container, type ContainerOptions } from '../container/Container';\nimport { type RenderLayer } from '../layers/RenderLayer';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * A GPU Data object\n * @internal\n */\nexport interface GPUData\n{\n    destroy: () => void;\n}\n\n/** @internal */\nexport interface GPUDataContainer<GPU_DATA extends GPUData = any>\n{\n    _gpuData: Record<number, GPU_DATA>;\n    unload: () => void;\n}\n\n/**\n * Options for the construction of a ViewContainer.\n * @category scene\n * @advanced\n */\nexport interface ViewContainerOptions extends ContainerOptions, PixiMixins.ViewContainerOptions\n{\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    autoGarbageCollect?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface ViewContainer<GPU_DATA extends GPUData = any> extends\n    PixiMixins.ViewContainer, Container, GPUDataOwner<GPU_DATA>, GCable {}\n\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @category scene\n * @advanced\n */\nexport abstract class ViewContainer<GPU_DATA extends GPUData = any> extends Container implements View, GCable\n{\n    /** @internal */\n    public override readonly renderPipeId: string;\n    /** @internal */\n    public readonly canBundle = true;\n    /** @internal */\n    public override allowChildren = false;\n\n    /** @internal */\n    public _roundPixels: 0 | 1 = 0;\n    /** @internal */\n    public _lastUsed = -1;\n\n    /** @internal */\n    public _gpuData: Record<number, GPU_DATA> = Object.create(null);\n    /** @internal */\n    public _gcData?: GCData;\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    public autoGarbageCollect = true;\n    /** @internal */\n    public _gcLastUsed = -1;\n\n    protected _bounds: Bounds = new Bounds(0, 1, 0, 0);\n    protected _boundsDirty = true;\n\n    /**\n     * The local bounds of the view in its own coordinate space.\n     * Bounds are automatically updated when the view's content changes.\n     * @example\n     * ```ts\n     * // Get bounds dimensions\n     * const bounds = view.bounds;\n     * console.log(`Width: ${bounds.maxX - bounds.minX}`);\n     * console.log(`Height: ${bounds.maxY - bounds.minY}`);\n     * ```\n     * @returns The rectangular bounds of the view\n     * @see {@link Bounds} For bounds operations\n     */\n    public get bounds()\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this.updateBounds();\n\n        this._boundsDirty = false;\n\n        return this._bounds;\n    }\n\n    /** @private */\n    protected abstract updateBounds(): void;\n\n    /**\n     * Whether or not to round the x/y position of the sprite.\n     * @example\n     * ```ts\n     * // Enable pixel rounding for crisp rendering\n     * view.roundPixels = true;\n     * ```\n     * @default false\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    constructor(options: ViewContainerOptions)\n    {\n        super(options);\n        this.autoGarbageCollect = options.autoGarbageCollect ?? true;\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Uses the view's bounds for hit testing.\n     * @example\n     * ```ts\n     * // Basic point check\n     * const localPoint = { x: 50, y: 25 };\n     * const contains = view.containsPoint(localPoint);\n     * console.log('Point is inside:', contains);\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the view's bounds\n     * @see {@link ViewContainer#bounds} For the bounds used in hit testing\n     * @see {@link Container#toLocal} For converting global coordinates to local\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n        const { x, y } = point;\n\n        return (x >= bounds.minX\n            && x <= bounds.maxX\n            && y >= bounds.minY\n            && y <= bounds.maxY);\n    }\n\n    /** @private */\n    public abstract batched: boolean;\n\n    /** @private */\n    protected onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /** Unloads the GPU data from the view. */\n    public unload(): void\n    {\n        this.emit('unload', this);\n        for (const key in this._gpuData)\n        {\n            this._gpuData[key]?.destroy();\n        }\n        this._gpuData = Object.create(null);\n        this.onViewUpdate();\n    }\n\n    public override destroy(options?: DestroyOptions): void\n    {\n        this.unload();\n        super.destroy(options);\n\n        this._bounds = null;\n    }\n\n    /**\n     * Collects renderables for the view container.\n     * @param instructionSet - The instruction set to collect renderables for.\n     * @param renderer - The renderer to collect renderables for.\n     * @param currentLayer - The current render layer.\n     * @internal\n     */\n    public override collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n        const pipe = rp[this.renderPipeId];\n\n        if (pipe?.addRenderable)\n        {\n            pipe.addRenderable(this, instructionSet);\n        }\n\n        this.didViewUpdate = false;\n\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n        renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n}\n\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { deprecation } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\nimport { type BatchableSprite } from './BatchableSprite';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for configuring a Sprite instance. Defines the texture, anchor point, and rendering behavior.\n * @example\n * ```ts\n * // Create a basic sprite with texture\n * const sprite = new Sprite({\n *     texture: Texture.from('sprite.png')\n * });\n *\n * // Create a centered sprite with rounded position\n * const centeredSprite = new Sprite({\n *     texture: Texture.from('centered.png'),\n *     anchor: 0.5,        // Center point\n *     roundPixels: true,  // Crisp rendering\n *     x: 100,            // Position from ViewContainerOptions\n *     y: 100\n * });\n *\n * // Create a sprite with specific anchor points\n * const anchoredSprite = new Sprite({\n *     texture: Texture.from('corner.png'),\n *     anchor: {\n *         x: 1,  // Right-aligned\n *         y: 0   // Top-aligned\n *     }\n * });\n * ```\n * @extends ViewContainerOptions\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface SpriteOptions extends PixiMixins.SpriteOptions, ViewContainerOptions\n{\n    /**\n     * The texture to use for the sprite. If not provided, uses Texture.EMPTY\n     * @default Texture.EMPTY\n     * @example\n     * ```ts\n     * // Create a sprite with a texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('path/to/image.png')\n     * });\n     * // Update the texture later\n     * sprite.texture = Texture.from('path/to/another-image.png');\n     * ```\n     */\n    texture?: Texture;\n\n    /**\n     * The anchor point of the sprite (0-1 range).\n     * Controls the origin point for rotation, scaling, and positioning.\n     * Can be a number for uniform anchor or a PointData for separate x/y values.\n     * @default 0\n     * @example\n     * ```ts\n     * // Centered anchor\n     * anchor: 0.5\n     * // Separate x/y anchor\n     * anchor: { x: 0.5, y: 0.5 }\n     * // Right-aligned anchor\n     * anchor: { x: 1, y: 0 }\n     * ```\n     */\n    anchor?: PointData | number;\n\n    /**\n     * Whether or not to round the x/y position to whole pixels.\n     * Useful for crisp pixel art style rendering.\n     * @default false\n     * @example\n     * ```ts\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png'),\n     *     roundPixels: true // Ensures crisp rendering\n     * });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Sprite extends PixiMixins.Sprite, ViewContainer<BatchableSprite> {}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n * Sprites can display images, handle input events, and be transformed in various ways.\n * @example\n * ```ts\n * // Create a sprite directly from an image path\n * const sprite = Sprite.from('assets/image.png');\n * sprite.position.set(100, 100);\n * app.stage.addChild(sprite);\n *\n * // Create from a spritesheet (more efficient)\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n *\n * // Create with specific options\n * const configuredSprite = new Sprite({\n *     texture: Texture.from('sprite.png'),\n *     anchor: 0.5,           // Center anchor point\n *     position: { x: 100, y: 100 },\n *     scale: { x: 2, y: 2 }, // Double size\n *     rotation: Math.PI / 4   // 45 degrees\n * });\n *\n * // Animate sprite properties\n * app.ticker.add(() => {\n *     sprite.rotation += 0.1;      // Rotate\n *     sprite.scale.x = Math.sin(performance.now() / 1000) + 1; // Pulse scale\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link SpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class Sprite extends ViewContainer<BatchableSprite>\n{\n    /**\n     * Creates a new sprite based on a source texture, image, video, or canvas element.\n     * This is a convenience method that automatically creates and manages textures.\n     * @example\n     * ```ts\n     * // Create from path or URL\n     * const sprite = Sprite.from('assets/image.png');\n     *\n     * // Create from existing texture\n     * const sprite = Sprite.from(texture);\n     *\n     * // Create from canvas\n     * const canvas = document.createElement('canvas');\n     * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n     * ```\n     * @param source - The source to create the sprite from. Can be a path to an image, a texture,\n     * or any valid texture source (canvas, video, etc.)\n     * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n     * @returns A new sprite based on the source\n     * @see {@link Texture.from} For texture creation details\n     * @see {@link Assets} For asset loading and management\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    /** @internal */\n    public override readonly renderPipeId: string = 'sprite';\n\n    /** @internal */\n    public batched = true;\n    /** @internal */\n    public readonly _anchor: ObservablePoint;\n\n    /** @internal */\n    public _texture: Texture;\n\n    private readonly _visualBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        if (this._width)\n        {\n            this._setWidth(this._width, this._texture.orig.width);\n        }\n\n        if (this._height)\n        {\n            this._setHeight(this._height, this._texture.orig.height);\n        }\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The texture that is displayed by the sprite. When changed, automatically updates\n     * the sprite dimensions and manages texture event listeners.\n     * @example\n     * ```ts\n     * // Create sprite with texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png')\n     * });\n     *\n     * // Update texture\n     * sprite.texture = Texture.from('newSprite.png');\n     *\n     * // Use texture from spritesheet\n     * const sheet = await Assets.load('spritesheet.json');\n     * sprite.texture = sheet.textures['frame1.png'];\n     *\n     * // Reset to empty texture\n     * sprite.texture = Texture.EMPTY;\n     * ```\n     * @see {@link Texture} For texture creation and management\n     * @see {@link Assets} For asset loading\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The bounds of the sprite, taking into account the texture's trim area.\n     * @example\n     * ```ts\n     * const texture = new Texture({\n     *     source: new TextureSource({ width: 300, height: 300 }),\n     *     frame: new Rectangle(196, 66, 58, 56),\n     *     trim: new Rectangle(4, 4, 58, 56),\n     *     orig: new Rectangle(0, 0, 64, 64),\n     *     rotate: 2,\n     * });\n     * const sprite = new Sprite(texture);\n     * const visualBounds = sprite.visualBounds;\n     * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n     */\n    get visualBounds()\n    {\n        updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n\n        return this._visualBounds;\n    }\n\n    /**\n     * @deprecated\n     * @ignore\n     */\n    get sourceBounds()\n    {\n        // #if _DEBUG\n        deprecation('8.6.1', 'Sprite.sourceBounds is deprecated, use visualBounds instead.');\n        // #endif\n\n        return this.visualBounds;\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const bounds = this._bounds;\n\n        const { width, height } = texture.orig;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * sprite.destroy();\n     * sprite.destroy(true);\n     * sprite.destroy({ texture: true, textureSource: true });\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._visualBounds as null) = null;\n        (this._bounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * - The default is `(0,0)`, this means the sprite's origin is the top left.\n     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * ```ts\n     * // Center the anchor point\n     * sprite.anchor = 0.5; // Sets both x and y to 0.5\n     * sprite.position.set(400, 300); // Sprite will be centered at this position\n     *\n     * // Set specific x/y anchor points\n     * sprite.anchor = {\n     *     x: 1, // Right edge\n     *     y: 0  // Top edge\n     * };\n     *\n     * // Using individual coordinates\n     * sprite.anchor.set(0.5, 1); // Center-bottom\n     *\n     * // For rotation around center\n     * sprite.anchor.set(0.5);\n     * sprite.rotation = Math.PI / 4; // 45 degrees around center\n     *\n     * // For scaling from center\n     * sprite.anchor.set(0.5);\n     * sprite.scale.set(2); // Scales from center point\n     * ```\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set width directly\n     * sprite.width = 200;\n     * console.log(sprite.scale.x); // Scale adjusted to match width\n     *\n     * // Set width while preserving aspect ratio\n     * const ratio = sprite.height / sprite.width;\n     * sprite.width = 300;\n     * sprite.height = 300 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.width = sprite.texture.orig.width;\n     * ```\n     */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set height directly\n     * sprite.height = 150;\n     * console.log(sprite.scale.y); // Scale adjusted to match height\n     *\n     * // Set height while preserving aspect ratio\n     * const ratio = sprite.width / sprite.height;\n     * sprite.height = 200;\n     * sprite.width = 200 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.height = sprite.texture.orig.height;\n     * ```\n     */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n     * This is faster than getting width and height separately as it only calculates the bounds once.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * const size = sprite.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * sprite.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the Sprite\n     * @see {@link Sprite#width} For getting just the width\n     * @see {@link Sprite#height} For getting just the height\n     * @see {@link Sprite#setSize} For setting both width and height\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * sprite.setSize(100, 200); // Width: 100, Height: 200\n     *\n     * // Set uniform size\n     * sprite.setSize(100); // Sets both width and height to 100\n     *\n     * // Set size with object\n     * sprite.setSize({\n     *     width: 200,\n     *     height: 300\n     * });\n     *\n     * // Reset to texture size\n     * sprite.setSize(\n     *     sprite.texture.orig.width,\n     *     sprite.texture.orig.height\n     * );\n     * ```\n     * @param value - This can be either a number or a {@link Size} object\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link Sprite#width} For setting width only\n     * @see {@link Sprite#height} For setting height only\n     * @see {@link Sprite#texture} For the source dimensions\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this._texture.orig.width);\n        height !== undefined && this._setHeight(height, this._texture.orig.height);\n    }\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a CanvasSource.\n * @category rendering\n * @advanced\n */\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /**\n     * Should the canvas be resized to preserve its screen width and height regardless\n     * of the resolution of the renderer, this is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\n/**\n * A texture source that uses a canvas as its resource.\n * It automatically resizes the canvas based on the width, height, and resolution.\n * It also provides a 2D rendering context for drawing.\n * @category rendering\n * @advanced\n */\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    private _context2D: CanvasRenderingContext2D;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        this.resizeCanvas();\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity && 'style' in this.resource)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n\n    /**\n     * Returns the 2D rendering context for the canvas.\n     * Caches the context after creating it.\n     * @returns The 2D rendering context of the canvas.\n     */\n    get context2D(): CanvasRenderingContext2D\n    {\n        return this._context2D || (this._context2D = this.resource.getContext('2d') as CanvasRenderingContext2D);\n    }\n}\n", "import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    /** @internal */\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n", "import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * The options to use when creating a new filter.\n * @category filters\n * @advanced\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     *\n     * If given, the shader should have a uniform named `uBackTexture`, which is where the pixels of the\n     * area being rendered to can be sampled from.\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/**\n * Filter options mixed with shader resources. A filter needs a shader and some resources to work.\n * @category filters\n * @advanced\n * @see {@link FilterOptions}\n */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @category filters\n * @advanced\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @category filters\n * @advanced\n * @example\n * import { Filter } from 'pixi.js';\n *\n * const customFilter = new Filter({\n *     glProgram: new GlProgram({\n *         fragment,\n *         vertex,\n *     }),\n *     resources: {\n *         timeUniforms: {\n *             uTime: { value: 0.0, type: 'f32' },\n *         },\n *     },\n * });\n *\n * // Apply the filter\n * sprite.filters = [customFilter];\n *\n * // Update uniform\n * app.ticker.add((ticker) => {\n *     filter.resources.timeUniforms.uniforms.uTime += 0.04 * ticker.deltaTime;\n * });\n */\nexport class Filter extends Shader\n{\n    /** The default filter settings */\n    public static defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        // this is where the filter system will attach the filter texture\n        this.addResource('uTexture', 0, 1);\n\n        if (options.blendRequired)\n        {\n            // this is where the filter system will attach the back texture\n            this.addResource('uBackTexture', 0, 3);\n        }\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["uid", "tempMatrix", "UPDATE_PRIORITY", "_Ticker", "count", "_State", "_Filter"]
}
