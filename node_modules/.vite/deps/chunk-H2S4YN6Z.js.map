{
  "version": 3,
  "sources": ["../../pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts", "../../tiny-lru/dist/tiny-lru.js", "../../pixi.js/src/scene/text/canvas/utils/parseTaggedText.ts", "../../pixi.js/src/scene/text/canvas/utils/textTokenization.ts", "../../pixi.js/src/scene/text/canvas/utils/measureTaggedText.ts", "../../pixi.js/src/scene/text/canvas/utils/wordWrap.ts", "../../pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts", "../../pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts", "../../pixi.js/src/scene/text/TextStyle.ts", "../../pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts", "../../pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts", "../../pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts", "../../pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts", "../../pixi.js/src/scene/text-bitmap/BitmapFontManager.ts", "../../pixi.js/src/scene/text-bitmap/BitmapFont.ts"],
  "sourcesContent": ["import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/utils/types';\n\n/**\n * @category text\n * @advanced\n */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @category text\n * @advanced\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @category text\n * @advanced\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @category text\n * @advanced\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n", "/**\n * tiny-lru\n *\n * @copyright 2026 Jason Mulligan <jason.mulligan@avoidwork.com>\n * @license BSD-3-Clause\n * @version 11.4.7\n */\n/**\n * A high-performance Least Recently Used (LRU) cache implementation with optional TTL support.\n * Items are automatically evicted when the cache reaches its maximum size,\n * removing the least recently used items first. All core operations (get, set, delete) are O(1).\n *\n * @class LRU\n * @example\n * // Create a cache with max 100 items\n * const cache = new LRU(100);\n * cache.set('key1', 'value1');\n * console.log(cache.get('key1')); // 'value1'\n *\n * @example\n * // Create a cache with TTL\n * const cache = new LRU(100, 5000); // 5 second TTL\n * cache.set('key1', 'value1');\n * // After 5 seconds, key1 will be expired\n */\nclass LRU {\n\t/**\n\t * Creates a new LRU cache instance.\n\t * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.\n\t *\n\t * @constructor\n\t * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.\n\t * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.\n\t * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n\t * @example\n\t * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access\n\t * @see {@link lru} For parameter validation\n\t * @since 1.0.0\n\t */\n\tconstructor (max = 0, ttl = 0, resetTtl = false) {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.max = max;\n\t\tthis.resetTtl = resetTtl;\n\t\tthis.size = 0;\n\t\tthis.ttl = ttl;\n\t}\n\n\t/**\n\t * Removes all items from the cache.\n\t *\n\t * @method clear\n\t * @memberof LRU\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.clear();\n\t * console.log(cache.size); // 0\n\t * @since 1.0.0\n\t */\n\tclear () {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.size = 0;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes an item from the cache by key.\n\t *\n\t * @method delete\n\t * @memberof LRU\n\t * @param {string} key - The key of the item to delete.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * cache.delete('key1');\n\t * console.log(cache.has('key1')); // false\n\t * @see {@link LRU#has}\n\t * @see {@link LRU#clear}\n\t * @since 1.0.0\n\t */\n\tdelete (key) {\n\t\tif (this.has(key)) {\n\t\t\tconst item = this.items[key];\n\n\t\t\tdelete this.items[key];\n\t\t\tthis.size--;\n\n\t\t\tif (item.prev !== null) {\n\t\t\t\titem.prev.next = item.next;\n\t\t\t}\n\n\t\t\tif (item.next !== null) {\n\t\t\t\titem.next.prev = item.prev;\n\t\t\t}\n\n\t\t\tif (this.first === item) {\n\t\t\t\tthis.first = item.next;\n\t\t\t}\n\n\t\t\tif (this.last === item) {\n\t\t\t\tthis.last = item.prev;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of [key, value] pairs for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method entries\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.\n\t * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.entries()); // [['a', 1], ['b', 2]]\n\t * console.log(cache.entries(['a'])); // [['a', 1]]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#values}\n\t * @since 11.1.0\n\t */\n\tentries (keys = this.keys()) {\n\t\tconst result = new Array(keys.length);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key = keys[i];\n\t\t\tresult[i] = [key, this.get(key)];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Removes the least recently used item from the cache.\n\t *\n\t * @method evict\n\t * @memberof LRU\n\t * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('old', 'value').set('new', 'value');\n\t * cache.evict(); // Removes 'old' item\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tevict (bypass = false) {\n\t\tif (bypass || this.size > 0) {\n\t\t\tconst item = this.first;\n\n\t\t\tdelete this.items[item.key];\n\n\t\t\tif (--this.size === 0) {\n\t\t\t\tthis.first = null;\n\t\t\t\tthis.last = null;\n\t\t\t} else {\n\t\t\t\tthis.first = item.next;\n\t\t\t\tthis.first.prev = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the expiration timestamp for a given key.\n\t *\n\t * @method expiresAt\n\t * @memberof LRU\n\t * @param {string} key - The key to check expiration for.\n\t * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.\n\t * @example\n\t * const cache = new LRU(100, 5000); // 5 second TTL\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\texpiresAt (key) {\n\t\tlet result;\n\n\t\tif (this.has(key)) {\n\t\t\tresult = this.items[key].expiry;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves a value from the cache by key. Updates the item's position to most recently used.\n\t *\n\t * @method get\n\t * @memberof LRU\n\t * @param {string} key - The key to retrieve.\n\t * @returns {*} The value associated with the key, or undefined if not found or expired.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.get('key1')); // 'value1'\n\t * console.log(cache.get('nonexistent')); // undefined\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\tget (key) {\n\t\tconst item = this.items[key];\n\n\t\tif (item !== undefined) {\n\t\t\t// Check TTL only if enabled to avoid unnecessary Date.now() calls\n\t\t\tif (this.ttl > 0) {\n\t\t\t\tif (item.expiry <= Date.now()) {\n\t\t\t\t\tthis.delete(key);\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fast LRU update without full set() overhead\n\t\t\tthis.moveToEnd(item);\n\n\t\t\treturn item.value;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Checks if a key exists in the cache.\n\t *\n\t * @method has\n\t * @memberof LRU\n\t * @param {string} key - The key to check for.\n\t * @returns {boolean} True if the key exists, false otherwise.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.has('key1')); // true\n\t * console.log(cache.has('nonexistent')); // false\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#delete}\n\t * @since 9.0.0\n\t */\n\thas (key) {\n\t\treturn key in this.items;\n\t}\n\n\t/**\n\t * Efficiently moves an item to the end of the LRU list (most recently used position).\n\t * This is an internal optimization method that avoids the overhead of the full set() operation\n\t * when only LRU position needs to be updated.\n\t *\n\t * @method moveToEnd\n\t * @memberof LRU\n\t * @param {Object} item - The cache item with prev/next pointers to reposition.\n\t * @private\n\t * @since 11.3.5\n\t */\n\tmoveToEnd (item) {\n\t\t// If already at the end, nothing to do\n\t\tif (this.last === item) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove item from current position in the list\n\t\tif (item.prev !== null) {\n\t\t\titem.prev.next = item.next;\n\t\t}\n\n\t\tif (item.next !== null) {\n\t\t\titem.next.prev = item.prev;\n\t\t}\n\n\t\t// Update first pointer if this was the first item\n\t\tif (this.first === item) {\n\t\t\tthis.first = item.next;\n\t\t}\n\n\t\t// Add item to the end\n\t\titem.prev = this.last;\n\t\titem.next = null;\n\n\t\tif (this.last !== null) {\n\t\t\tthis.last.next = item;\n\t\t}\n\n\t\tthis.last = item;\n\n\t\t// Handle edge case: if this was the only item, it's also first\n\t\tif (this.first === null) {\n\t\t\tthis.first = item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of all keys in the cache, ordered from least to most recently used.\n\t *\n\t * @method keys\n\t * @memberof LRU\n\t * @returns {string[]} Array of keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * cache.get('a'); // Move 'a' to most recent\n\t * console.log(cache.keys()); // ['b', 'a']\n\t * @see {@link LRU#values}\n\t * @see {@link LRU#entries}\n\t * @since 9.0.0\n\t */\n\tkeys () {\n\t\tconst result = new Array(this.size);\n\t\tlet x = this.first;\n\t\tlet i = 0;\n\n\t\twhile (x !== null) {\n\t\t\tresult[i++] = x.key;\n\t\t\tx = x.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets a value in the cache and returns any evicted item.\n\t *\n\t * @method setWithEvicted\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.\n\t * @example\n\t * const cache = new LRU(2);\n\t * cache.set('a', 1).set('b', 2);\n\t * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#evict}\n\t * @since 11.3.0\n\t */\n\tsetWithEvicted (key, value, resetTtl = this.resetTtl) {\n\t\tlet evicted = null;\n\n\t\tif (this.has(key)) {\n\t\t\tthis.set(key, value, true, resetTtl);\n\t\t} else {\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tevicted = {...this.first};\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\tlet item = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn evicted;\n\t}\n\n\t/**\n\t * Sets a value in the cache. Updates the item's position to most recently used.\n\t *\n\t * @method set\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1')\n\t *      .set('key2', 'value2')\n\t *      .set('key3', 'value3');\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tset (key, value, bypass = false, resetTtl = this.resetTtl) {\n\t\tlet item = this.items[key];\n\n\t\tif (bypass || item !== undefined) {\n\t\t\t// Existing item: update value and position\n\t\t\titem.value = value;\n\n\t\t\tif (bypass === false && resetTtl) {\n\t\t\t\titem.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;\n\t\t\t}\n\n\t\t\t// Always move to end, but the bypass parameter affects TTL reset behavior\n\t\t\tthis.moveToEnd(item);\n\t\t} else {\n\t\t\t// New item: check for eviction and create\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\titem = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of all values in the cache for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method values\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.\n\t * @returns {Array<*>} Array of values corresponding to the keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.values()); // [1, 2]\n\t * console.log(cache.values(['a'])); // [1]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#entries}\n\t * @since 11.1.0\n\t */\n\tvalues (keys = this.keys()) {\n\t\tconst result = new Array(keys.length);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tresult[i] = this.get(keys[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Factory function to create a new LRU cache instance with parameter validation.\n *\n * @function lru\n * @param {number} [max=1000] - Maximum number of items to store. Must be >= 0. Use 0 for unlimited size.\n * @param {number} [ttl=0] - Time to live in milliseconds. Must be >= 0. Use 0 for no expiration.\n * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n * @returns {LRU} A new LRU cache instance.\n * @throws {TypeError} When parameters are invalid (negative numbers or wrong types).\n * @example\n * // Create cache with factory function\n * const cache = lru(100, 5000, true);\n * cache.set('key', 'value');\n *\n * @example\n * // Error handling\n * try {\n *   const cache = lru(-1); // Invalid max\n * } catch (error) {\n *   console.error(error.message); // \"Invalid max value\"\n * }\n * @see {@link LRU}\n * @since 1.0.0\n */\nfunction lru (max = 1000, ttl = 0, resetTtl = false) {\n\tif (isNaN(max) || max < 0) {\n\t\tthrow new TypeError(\"Invalid max value\");\n\t}\n\n\tif (isNaN(ttl) || ttl < 0) {\n\t\tthrow new TypeError(\"Invalid ttl value\");\n\t}\n\n\tif (typeof resetTtl !== \"boolean\") {\n\t\tthrow new TypeError(\"Invalid resetTtl value\");\n\t}\n\n\treturn new LRU(max, ttl, resetTtl);\n}export{LRU,lru};", "import type { TextStyle, TextStyleOptions } from '../../TextStyle';\n\n/**\n * Represents a run of text with a specific style.\n * Used internally for tagged text rendering.\n * @internal\n */\nexport interface TextStyleRun\n{\n    /** The text content of this run */\n    text: string;\n    /** The computed style for this run (base style merged with tag overrides) */\n    style: TextStyle;\n}\n\n/**\n * Checks whether the given style has tagStyles defined with at least one entry.\n * @param style - The TextStyle to check\n * @returns True if tagStyles is defined and has entries\n * @internal\n */\nexport function hasTagStyles(style: TextStyle): boolean\n{\n    return !!style.tagStyles && Object.keys(style.tagStyles).length > 0;\n}\n\n/**\n * Checks whether the text contains potential tag markup.\n * This is a quick check before attempting to parse.\n * @param text - The text to check\n * @returns True if text contains '<' character\n * @internal\n */\nexport function hasTagMarkup(text: string): boolean\n{\n    return text.includes('<');\n}\n\n/**\n * Creates a merged TextStyle from a base style and tag style overrides.\n * @param baseStyle - The base TextStyle\n * @param overrides - Style overrides from the tag\n * @returns A new TextStyle with merged properties\n * @internal\n */\nfunction createMergedStyle(baseStyle: TextStyle, overrides: TextStyleOptions): TextStyle\n{\n    return baseStyle.clone().assign(overrides);\n}\n\n/**\n * Parses text with tag markup into an array of styled runs.\n * Supports simple open/close tags like `<red>text</red>`.\n * Nested tags are supported via a stack - inner tags inherit from outer tags.\n * Unknown tags (not in tagStyles) are treated as literal text.\n * @param text - The text to parse\n * @param style - The base TextStyle containing tagStyles\n * @returns Array of TextStyleRun objects\n * @internal\n */\nexport function parseTaggedText(text: string, style: TextStyle): TextStyleRun[]\n{\n    const runs: TextStyleRun[] = [];\n    const tagStyles = style.tagStyles;\n\n    // If no tagStyles or no potential tags, return single run with base style\n    if (!hasTagStyles(style) || !hasTagMarkup(text))\n    {\n        runs.push({ text, style });\n\n        return runs;\n    }\n\n    // Stack of active styles (for nested tags)\n    const styleStack: TextStyle[] = [style];\n    // Stack of active tag names (to match closing tags)\n    const tagStack: string[] = [];\n\n    let currentText = '';\n    let i = 0;\n\n    while (i < text.length)\n    {\n        const char = text[i];\n\n        if (char === '<')\n        {\n            // Find the closing bracket\n            const closeIndex = text.indexOf('>', i);\n\n            if (closeIndex === -1)\n            {\n                // No closing bracket - treat as literal\n                currentText += char;\n                i++;\n                continue;\n            }\n\n            const tagContent = text.slice(i + 1, closeIndex);\n\n            // Check if it's a closing tag\n            if (tagContent.startsWith('/'))\n            {\n                const closingTagName = tagContent.slice(1).trim();\n\n                // Check if this closing tag matches the most recent opening tag\n                if (tagStack.length > 0 && tagStack[tagStack.length - 1] === closingTagName)\n                {\n                    // Flush current text with current style\n                    if (currentText.length > 0)\n                    {\n                        runs.push({\n                            text: currentText,\n                            style: styleStack[styleStack.length - 1]\n                        });\n                        currentText = '';\n                    }\n\n                    // Pop the style and tag stacks\n                    styleStack.pop();\n                    tagStack.pop();\n                    i = closeIndex + 1;\n                    continue;\n                }\n                else\n                {\n                    // Mismatched closing tag - treat as literal\n                    currentText += text.slice(i, closeIndex + 1);\n                    i = closeIndex + 1;\n                    continue;\n                }\n            }\n            else\n            {\n                // Opening tag\n                const tagName = tagContent.trim();\n\n                // Check if this tag is in tagStyles\n                if (tagStyles[tagName])\n                {\n                    // Flush current text with current style\n                    if (currentText.length > 0)\n                    {\n                        runs.push({\n                            text: currentText,\n                            style: styleStack[styleStack.length - 1]\n                        });\n                        currentText = '';\n                    }\n\n                    // Create merged style from current style and tag overrides\n                    const currentStyle = styleStack[styleStack.length - 1];\n                    const mergedStyle = createMergedStyle(currentStyle, tagStyles[tagName]);\n\n                    styleStack.push(mergedStyle);\n                    tagStack.push(tagName);\n                    i = closeIndex + 1;\n                    continue;\n                }\n                else\n                {\n                    // Unknown tag - treat as literal\n                    currentText += text.slice(i, closeIndex + 1);\n                    i = closeIndex + 1;\n                    continue;\n                }\n            }\n        }\n        else\n        {\n            currentText += char;\n            i++;\n        }\n    }\n\n    // Flush any remaining text\n    if (currentText.length > 0)\n    {\n        runs.push({\n            text: currentText,\n            style: styleStack[styleStack.length - 1]\n        });\n    }\n\n    return runs;\n}\n\n/**\n * Extracts plain text from tagged text (strips all tags).\n * Useful for cache keys and debugging.\n * @param text - The tagged text\n * @param style - The TextStyle containing tagStyles\n * @returns Plain text with tags removed\n * @internal\n */\nexport function getPlainText(text: string, style: TextStyle): string\n{\n    if (!hasTagStyles(style) || !hasTagMarkup(text))\n    {\n        return text;\n    }\n\n    const runs = parseTaggedText(text, style);\n\n    return runs.map((run) => run.text).join('');\n}\n", "import type { TextStyleWhiteSpace } from '../../TextStyle';\n\n/**\n * Cache of new line character codes.\n * @internal\n */\nexport const NEWLINES: number[] = [\n    0x000A, // line feed\n    0x000D, // carriage return\n];\n\n/**\n * Set of new line character codes for fast lookup.\n * @internal\n */\nexport const NEWLINES_SET = new Set(NEWLINES);\n\n/**\n * Cache of breaking space character codes.\n * @internal\n */\nexport const BREAKING_SPACES: number[] = [\n    0x0009, // character tabulation\n    0x0020, // space\n    0x2000, // en quad\n    0x2001, // em quad\n    0x2002, // en space\n    0x2003, // em space\n    0x2004, // three-per-em space\n    0x2005, // four-per-em space\n    0x2006, // six-per-em space\n    0x2008, // punctuation space\n    0x2009, // thin space\n    0x200A, // hair space\n    0x205F, // medium mathematical space\n    0x3000, // ideographic space\n];\n\n/**\n * Set of breaking space character codes for fast lookup.\n * @internal\n */\nexport const BREAKING_SPACES_SET = new Set(BREAKING_SPACES);\n\n/**\n * Regex to split text while capturing newline sequences.\n * @internal\n */\nexport const NEWLINE_SPLIT_REGEX = /(\\r\\n|\\r|\\n)/;\n\n/**\n * Regex to split text on newlines without capturing.\n * @internal\n */\nexport const NEWLINE_MATCH_REGEX = /(?:\\r\\n|\\r|\\n)/;\n\n/**\n * Determines if char is a newline.\n * @param char - The character\n * @returns True if newline, False otherwise.\n * @internal\n */\nexport function isNewline(char: string): boolean\n{\n    if (typeof char !== 'string')\n    {\n        return false;\n    }\n\n    return NEWLINES_SET.has(char.charCodeAt(0));\n}\n\n/**\n * Determines if char is a breaking whitespace.\n *\n * It allows one to determine whether char should be a breaking whitespace\n * For example certain characters in CJK langs or numbers.\n * It must return a boolean.\n * @param char - The character\n * @param _nextChar - The next character (unused, for override compatibility)\n * @returns True if whitespace, False otherwise.\n * @internal\n */\nexport function isBreakingSpace(char: string, _nextChar?: string): boolean\n{\n    if (typeof char !== 'string')\n    {\n        return false;\n    }\n\n    return BREAKING_SPACES_SET.has(char.charCodeAt(0));\n}\n\n/**\n * Determines whether we should collapse breaking spaces.\n * @param whiteSpace - The TextStyle property whiteSpace\n * @returns Should collapse\n * @internal\n */\nexport function collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n{\n    return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n}\n\n/**\n * Determines whether we should collapse newLine chars.\n * @param whiteSpace - The white space\n * @returns should collapse\n * @internal\n */\nexport function collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n{\n    return (whiteSpace === 'normal');\n}\n\n/**\n * Trims breaking whitespaces from the right side of a string.\n * @param text - The text\n * @returns Trimmed string\n * @internal\n */\nexport function trimRight(text: string): string\n{\n    if (typeof text !== 'string')\n    {\n        return '';\n    }\n\n    let i = text.length - 1;\n\n    while (i >= 0 && isBreakingSpace(text[i]))\n    {\n        i--;\n    }\n\n    // Only slice if we found trailing spaces\n    return i < text.length - 1 ? text.slice(0, i + 1) : text;\n}\n\n/**\n * Splits a string into words, breaking-spaces and newLine characters\n * @param text - The text\n * @returns A tokenized array\n * @internal\n */\nexport function tokenize(text: string): string[]\n{\n    const tokens: string[] = [];\n    const tokenChars: string[] = [];\n\n    if (typeof text !== 'string')\n    {\n        return tokens;\n    }\n\n    for (let i = 0; i < text.length; i++)\n    {\n        const char = text[i];\n        const nextChar = text[i + 1];\n\n        if (isBreakingSpace(char, nextChar) || isNewline(char))\n        {\n            if (tokenChars.length > 0)\n            {\n                tokens.push(tokenChars.join(''));\n                tokenChars.length = 0;\n            }\n\n            // treat \\r\\n as a single new line token\n            if (char === '\\r' && nextChar === '\\n')\n            {\n                tokens.push('\\r\\n');\n                i++;\n            }\n            else\n            {\n                tokens.push(char);\n            }\n\n            continue;\n        }\n\n        tokenChars.push(char);\n    }\n\n    if (tokenChars.length > 0)\n    {\n        tokens.push(tokenChars.join(''));\n    }\n\n    return tokens;\n}\n\n/**\n * Splits a token into character groups that should not be broken apart.\n * Adjacent characters that can't be broken are combined into single groups.\n * @param token - The token to split\n * @param breakWords - Whether word breaking is enabled\n * @param splitFn - Function to split token into characters (default: grapheme segmenter)\n * @param canBreakCharsFn - Function to check if chars can be broken\n * @returns Array of character groups\n * @internal\n */\nexport function getCharacterGroups(\n    token: string,\n    breakWords: boolean,\n    splitFn: (s: string) => string[],\n    canBreakCharsFn: (char: string, nextChar: string, token: string, index: number, breakWords: boolean) => boolean,\n): string[]\n{\n    const characters = splitFn(token);\n    const groups: string[] = [];\n\n    for (let j = 0; j < characters.length; j++)\n    {\n        let char = characters[j];\n        let lastChar = char;\n\n        // Combine chars that shouldn't be split\n        let k = 1;\n\n        while (characters[j + k])\n        {\n            const nextChar = characters[j + k];\n\n            if (!canBreakCharsFn(lastChar, nextChar, token, j, breakWords))\n            {\n                char += nextChar;\n                lastChar = nextChar;\n                k++;\n            }\n            else\n            {\n                break;\n            }\n        }\n        j += k - 1;\n        groups.push(char);\n    }\n\n    return groups;\n}\n", "import { parseTaggedText, type TextStyleRun } from './parseTaggedText';\nimport {\n    collapseNewlines,\n    collapseSpaces,\n    getCharacterGroups,\n    isBreakingSpace,\n    isNewline,\n    NEWLINE_SPLIT_REGEX,\n    tokenize,\n    trimRight,\n} from './textTokenization';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle } from '../../TextStyle';\nimport type {\n    CanBreakCharsFn,\n    FontMetrics,\n    MeasureTextFn,\n    WordWrapSplitFn,\n} from './types';\n\n/**\n * Function type for measuring font metrics.\n * @internal\n */\ntype MeasureFontFn = (font: string) => FontMetrics;\n\n/**\n * Result of measuring tagged text.\n * @internal\n */\ninterface TaggedMeasurementResult\n{\n    /** Total width including stroke and shadow */\n    width: number;\n    /** Total height including shadow */\n    height: number;\n    /** Array of line text (for compatibility) */\n    lines: string[];\n    /** Per-line widths */\n    lineWidths: number[];\n    /** Base line height from style */\n    lineHeight: number;\n    /** Maximum line width */\n    maxLineWidth: number;\n    /** Font properties from base style */\n    fontProperties: FontMetrics;\n    /** Per-line style runs */\n    runsByLine: TextStyleRun[][];\n    /** Per-line ascent values */\n    lineAscents: number[];\n    /** Per-line descent values */\n    lineDescents: number[];\n    /** Per-line heights */\n    lineHeights: number[];\n    /** Whether any run has drop shadow */\n    hasDropShadow: boolean;\n}\n\n/**\n * Styled token with continuation flag for word wrapping.\n * @internal\n */\ninterface StyledToken\n{\n    token: string;\n    style: TextStyle;\n    continuesFromPrevious: boolean;\n}\n\n/**\n * Regex to replace newlines with spaces.\n * @internal\n */\nconst NEWLINE_TO_SPACE_REGEX = /\\r\\n|\\r|\\n/g;\n\n/**\n * Measures tagged text with multiple styles.\n * Handles per-run font measurement and per-line metrics.\n * @param text - The tagged text to measure\n * @param style - The base text style containing tagStyles\n * @param wordWrap - Whether to apply word wrapping\n * @param context - The canvas 2D context\n * @param measureTextFn - Function to measure text width\n * @param measureFontFn - Function to measure font metrics\n * @param canBreakCharsFn - Function to check if characters can be broken\n * @param wordWrapSplitFn - Function to split words into characters\n * @returns TaggedMeasurementResult with all measurement data\n * @internal\n */\nexport function measureTaggedText(\n    text: string,\n    style: TextStyle,\n    wordWrap: boolean,\n    context: ICanvasRenderingContext2D,\n    measureTextFn: MeasureTextFn,\n    measureFontFn: MeasureFontFn,\n    canBreakCharsFn: CanBreakCharsFn,\n    wordWrapSplitFn: WordWrapSplitFn,\n): TaggedMeasurementResult\n{\n    // Parse text into runs\n    const runs = parseTaggedText(text, style);\n\n    // Collapse newlines to spaces in 'normal' mode (matching regular text behavior)\n    const shouldCollapseNewlines = collapseNewlines(style.whiteSpace);\n\n    if (shouldCollapseNewlines)\n    {\n        for (let i = 0; i < runs.length; i++)\n        {\n            const run = runs[i];\n\n            runs[i] = { text: run.text.replace(NEWLINE_TO_SPACE_REGEX, ' '), style: run.style };\n        }\n    }\n\n    // First, we need to handle newlines and word wrap\n    // Split runs by newlines first\n    const runsByLine: TextStyleRun[][] = [];\n    let currentLineRuns: TextStyleRun[] = [];\n\n    for (const run of runs)\n    {\n        // Split run text by newlines\n        const parts = run.text.split(NEWLINE_SPLIT_REGEX);\n\n        for (let i = 0; i < parts.length; i++)\n        {\n            const part = parts[i];\n\n            if (part === '\\r\\n' || part === '\\r' || part === '\\n')\n            {\n                // Push current line and start a new one\n                runsByLine.push(currentLineRuns);\n                currentLineRuns = [];\n            }\n            else if (part.length > 0)\n            {\n                currentLineRuns.push({ text: part, style: run.style });\n            }\n        }\n    }\n    // Don't forget the last line\n    if (currentLineRuns.length > 0 || runsByLine.length === 0)\n    {\n        runsByLine.push(currentLineRuns);\n    }\n\n    // Apply word wrap if enabled\n    const wrappedRunsByLine = wordWrap\n        ? wordWrapTaggedLines(\n            runsByLine,\n            style,\n            context,\n            measureTextFn,\n            canBreakCharsFn,\n            wordWrapSplitFn,\n        )\n        : runsByLine;\n\n    // Measure each line\n    const lineWidths: number[] = [];\n    const lineAscents: number[] = [];\n    const lineDescents: number[] = [];\n    const lineHeightsArr: number[] = [];\n    const lines: string[] = [];\n    let maxLineWidth = 0;\n\n    // Get base font properties for fallback\n    const baseFont = style._fontString;\n    const baseFontProps = measureFontFn(baseFont);\n\n    // Fallback in case UA disallows canvas data extraction\n    if (baseFontProps.fontSize === 0)\n    {\n        baseFontProps.fontSize = style.fontSize as number;\n        baseFontProps.ascent = style.fontSize as number;\n    }\n\n    let lastFont = '';\n    let hasDropShadow = !!style.dropShadow;\n\n    for (const lineRuns of wrappedRunsByLine)\n    {\n        let lineWidth = 0;\n        let lineAscent = baseFontProps.ascent;\n        let lineDescent = baseFontProps.descent;\n        let lineText = '';\n\n        for (const run of lineRuns)\n        {\n            const runFont = run.style._fontString;\n            const runFontProps = measureFontFn(runFont);\n\n            if (runFont !== lastFont)\n            {\n                context.font = runFont;\n                lastFont = runFont;\n            }\n\n            const runWidth = measureTextFn(run.text, run.style.letterSpacing, context);\n\n            lineWidth += runWidth;\n            lineAscent = Math.max(lineAscent, runFontProps.ascent);\n            lineDescent = Math.max(lineDescent, runFontProps.descent);\n            lineText += run.text;\n\n            if (!hasDropShadow && run.style.dropShadow)\n            {\n                hasDropShadow = true;\n            }\n        }\n\n        // Handle empty lines\n        if (lineRuns.length === 0)\n        {\n            lineAscent = baseFontProps.ascent;\n            lineDescent = baseFontProps.descent;\n        }\n\n        lineWidths.push(lineWidth);\n        lineAscents.push(lineAscent);\n        lineDescents.push(lineDescent);\n        lines.push(lineText);\n\n        // Calculate line height - use style.lineHeight if set, otherwise use measured metrics\n        const computedLineHeight = style.lineHeight || (lineAscent + lineDescent);\n\n        lineHeightsArr.push(computedLineHeight + style.leading);\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    // Calculate total dimensions\n    const strokeWidth = style._stroke?.width || 0;\n\n    // Calculate base width - use wordWrapWidth for non-left alignment when wrapping\n    const useWrapWidth = wordWrap && style.align !== 'left' && style.align !== 'justify';\n    const alignWidth = useWrapWidth ? Math.max(maxLineWidth, style.wordWrapWidth) : maxLineWidth;\n    const width = alignWidth + strokeWidth + (style.dropShadow ? style.dropShadow.distance : 0);\n\n    // Calculate total height from per-line heights\n    let baseHeight = 0;\n\n    for (let i = 0; i < lineHeightsArr.length; i++)\n    {\n        baseHeight += lineHeightsArr[i];\n    }\n\n    // Add stroke width to height for first line (to match non-tagged behavior)\n    baseHeight = Math.max(baseHeight, lineHeightsArr[0] + strokeWidth);\n    const height = baseHeight + (style.dropShadow ? style.dropShadow.distance : 0);\n\n    // Use the base style's line height for the lineHeight property (for backwards compat)\n    const baseLineHeight = style.lineHeight || baseFontProps.fontSize;\n\n    return {\n        width,\n        height,\n        lines,\n        lineWidths,\n        lineHeight: baseLineHeight + style.leading,\n        maxLineWidth,\n        fontProperties: baseFontProps,\n        runsByLine: wrappedRunsByLine,\n        lineAscents,\n        lineDescents,\n        lineHeights: lineHeightsArr,\n        hasDropShadow,\n    };\n}\n\n/**\n * Applies word wrapping to tagged text lines.\n * Breaks runs at word boundaries while maintaining style information.\n * @param runsByLine - Array of run arrays, one per line\n * @param style - The base text style\n * @param context - The canvas 2D context\n * @param measureTextFn - Function to measure text width\n * @param canBreakCharsFn - Function to check if characters can be broken\n * @param wordWrapSplitFn - Function to split words into characters\n * @returns New runsByLine array with word wrap applied\n * @internal\n */\nexport function wordWrapTaggedLines(\n    runsByLine: TextStyleRun[][],\n    style: TextStyle,\n    context: ICanvasRenderingContext2D,\n    measureTextFn: MeasureTextFn,\n    canBreakCharsFn: CanBreakCharsFn,\n    wordWrapSplitFn: WordWrapSplitFn,\n): TextStyleRun[][]\n{\n    const { letterSpacing, whiteSpace, wordWrapWidth, breakWords } = style;\n\n    // How to handle whitespaces\n    const shouldCollapseSpaces = collapseSpaces(whiteSpace);\n\n    // Adjust for letterSpacing (see _wordWrap for explanation)\n    const adjustedWrapWidth = wordWrapWidth + letterSpacing;\n\n    // Cache for token width measurements and font tracking to avoid redundant work\n    const tokenWidthCache: Record<string, number> = {};\n    let lastFont = '';\n\n    const measureTokenWidth = (token: string, tokenStyle: TextStyle): number =>\n    {\n        const cacheKey = `${token}|${tokenStyle.styleKey}`;\n        let width = tokenWidthCache[cacheKey];\n\n        if (width === undefined)\n        {\n            const font = tokenStyle._fontString;\n\n            if (font !== lastFont)\n            {\n                context.font = font;\n                lastFont = font;\n            }\n            width = measureTextFn(token, tokenStyle.letterSpacing, context)\n                + tokenStyle.letterSpacing;\n            tokenWidthCache[cacheKey] = width;\n        }\n\n        return width;\n    };\n\n    const result: TextStyleRun[][] = [];\n\n    // Process each line from the input\n    for (const lineRuns of runsByLine)\n    {\n        // Tokenize all runs on this line into styled tokens\n        const styledTokens = tokenizeTaggedRuns(lineRuns);\n\n        // Track if we pushed content directly to result (for word groups)\n        const resultStartLength = result.length;\n\n        // Helper to calculate the total width of a word group starting at index\n        // A word group is a sequence of tokens where each subsequent token has continuesFromPrevious: true\n        const getWordGroupWidth = (startIndex: number): number =>\n        {\n            let totalWidth = 0;\n            let j = startIndex;\n\n            do\n            {\n                const { token: groupToken, style: groupStyle } = styledTokens[j];\n\n                totalWidth += measureTokenWidth(groupToken, groupStyle);\n                j++;\n            }\n            while (j < styledTokens.length && styledTokens[j].continuesFromPrevious);\n\n            return totalWidth;\n        };\n\n        // Helper to get all tokens in a word group\n        const getWordGroupTokens = (startIndex: number): Array<{ token: string; style: TextStyle }> =>\n        {\n            const tokens: Array<{ token: string; style: TextStyle }> = [];\n            let j = startIndex;\n\n            do\n            {\n                tokens.push({ token: styledTokens[j].token, style: styledTokens[j].style });\n                j++;\n            }\n            while (j < styledTokens.length && styledTokens[j].continuesFromPrevious);\n\n            return tokens;\n        };\n\n        // Now apply word wrap logic to these tokens\n        let currentLineRuns: TextStyleRun[] = [];\n        let currentWidth = 0;\n        let canPrependSpaces = !shouldCollapseSpaces;\n\n        // Track the current \"building\" run (to merge adjacent tokens with same style)\n        let buildingRun: TextStyleRun | null = null;\n\n        const flushBuildingRun = (): void =>\n        {\n            if (buildingRun && buildingRun.text.length > 0)\n            {\n                currentLineRuns.push(buildingRun);\n            }\n            buildingRun = null;\n        };\n\n        const startNewLine = (): void =>\n        {\n            flushBuildingRun();\n            // Trim trailing spaces from last run on line\n            if (currentLineRuns.length > 0)\n            {\n                const lastRun = currentLineRuns[currentLineRuns.length - 1];\n\n                lastRun.text = trimRight(lastRun.text);\n                if (lastRun.text.length === 0)\n                {\n                    currentLineRuns.pop();\n                }\n            }\n            result.push(currentLineRuns);\n            currentLineRuns = [];\n            currentWidth = 0;\n            canPrependSpaces = false;\n        };\n\n        for (let i = 0; i < styledTokens.length; i++)\n        {\n            const { token, style: tokenStyle, continuesFromPrevious } = styledTokens[i];\n\n            const tokenWidth = measureTokenWidth(token, tokenStyle);\n\n            // Handle collapsing spaces\n            if (shouldCollapseSpaces)\n            {\n                const currIsSpace = isBreakingSpace(token);\n                const lastChar = buildingRun?.text[buildingRun.text.length - 1]\n                    ?? currentLineRuns[currentLineRuns.length - 1]?.text.slice(-1)\n                    ?? '';\n                const lastIsSpace = lastChar ? isBreakingSpace(lastChar) : false;\n\n                if (currIsSpace && lastIsSpace)\n                {\n                    continue;\n                }\n            }\n\n            // Check if this token starts a word group (not a continuation)\n            const startsWordGroup = !continuesFromPrevious;\n\n            // Calculate word group width if this starts a new word group\n            const wordGroupWidth = startsWordGroup ? getWordGroupWidth(i) : tokenWidth;\n\n            // Word group is longer than the wrap width\n            if (wordGroupWidth > adjustedWrapWidth && startsWordGroup)\n            {\n                // Flush any existing content to a new line\n                if (currentWidth > 0)\n                {\n                    startNewLine();\n                }\n\n                // Break the long word group if allowed\n                if (breakWords)\n                {\n                    // Get all tokens in this word group\n                    const wordGroupTokens = getWordGroupTokens(i);\n\n                    // Process each token in the word group\n                    for (let g = 0; g < wordGroupTokens.length; g++)\n                    {\n                        const groupToken = wordGroupTokens[g].token;\n                        const groupStyle = wordGroupTokens[g].style;\n                        const charGroups = getCharacterGroups(\n                            groupToken,\n                            breakWords,\n                            wordWrapSplitFn,\n                            canBreakCharsFn,\n                        );\n\n                        for (const char of charGroups)\n                        {\n                            const charWidth = measureTokenWidth(char, groupStyle);\n\n                            // eslint-disable-next-line max-depth\n                            if (charWidth + currentWidth > adjustedWrapWidth)\n                            {\n                                startNewLine();\n                            }\n\n                            // Add char to building run\n                            // eslint-disable-next-line max-depth\n                            if (!buildingRun || buildingRun.style !== groupStyle)\n                            {\n                                flushBuildingRun();\n                                buildingRun = { text: char, style: groupStyle };\n                            }\n                            else\n                            {\n                                buildingRun.text += char;\n                            }\n                            currentWidth += charWidth;\n                        }\n                    }\n\n                    // Skip all the tokens we just processed\n                    i += wordGroupTokens.length - 1;\n                }\n                else\n                {\n                    // Can't break - put whole word group on its own line\n                    const wordGroupTokens = getWordGroupTokens(i);\n\n                    flushBuildingRun();\n                    result.push(wordGroupTokens.map((t) => ({ text: t.token, style: t.style })));\n                    canPrependSpaces = false;\n\n                    // Skip all the tokens we just processed\n                    i += wordGroupTokens.length - 1;\n                }\n            }\n            // Word group would exceed line width (but fits on its own line)\n            else if (wordGroupWidth + currentWidth > adjustedWrapWidth && startsWordGroup)\n            {\n                // Don't start new line with just a space\n                if (isBreakingSpace(token))\n                {\n                    canPrependSpaces = false;\n                    continue;\n                }\n\n                startNewLine();\n\n                // Start new building run with this token\n                buildingRun = { text: token, style: tokenStyle };\n                currentWidth = tokenWidth;\n            }\n            // Token is a continuation of a word group - always add it (don't wrap mid-word when breakWords: false)\n            else if (continuesFromPrevious && !breakWords)\n            {\n                // Add to building run or start new one\n                if (!buildingRun || buildingRun.style !== tokenStyle)\n                {\n                    flushBuildingRun();\n                    buildingRun = { text: token, style: tokenStyle };\n                }\n                else\n                {\n                    buildingRun.text += token;\n                }\n                currentWidth += tokenWidth;\n            }\n            // Token fits on current line (or is a continuation with breakWords: true)\n            else\n            {\n                const isSpace = isBreakingSpace(token);\n\n                // Don't prepend spaces to line start unless allowed\n                if (currentWidth === 0 && isSpace && !canPrependSpaces)\n                {\n                    continue;\n                }\n\n                // Add to building run or start new one\n                if (!buildingRun || buildingRun.style !== tokenStyle)\n                {\n                    flushBuildingRun();\n                    buildingRun = { text: token, style: tokenStyle };\n                }\n                else\n                {\n                    buildingRun.text += token;\n                }\n                currentWidth += tokenWidth;\n            }\n        }\n\n        // Flush final content\n        flushBuildingRun();\n        if (currentLineRuns.length > 0)\n        {\n            // Trim trailing spaces\n            const lastRun = currentLineRuns[currentLineRuns.length - 1];\n\n            lastRun.text = trimRight(lastRun.text);\n            if (lastRun.text.length === 0)\n            {\n                currentLineRuns.pop();\n            }\n        }\n\n        // Push final line if it has content, or if we haven't pushed anything yet.\n        // The second condition (result.length === resultStartLength) ensures we preserve\n        // explicit blank lines from the input text. Without this, a line containing only\n        // whitespace would be trimmed away entirely, collapsing consecutive newlines.\n        if (currentLineRuns.length > 0 || result.length === resultStartLength)\n        {\n            result.push(currentLineRuns);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Tokenizes an array of TextStyleRuns into individual styled tokens.\n * Each token is a word, space, or newline with its associated style.\n * Tracks whether adjacent tokens across run boundaries form a continuous word.\n * @param runs - The runs to tokenize\n * @returns Array of styled tokens with continuation flags\n * @internal\n */\nexport function tokenizeTaggedRuns(\n    runs: TextStyleRun[]\n): StyledToken[]\n{\n    const styledTokens: StyledToken[] = [];\n    let lastTokenWasWord = false;\n\n    for (const run of runs)\n    {\n        const tokens = tokenize(run.text);\n        let isFirstTokenInRun = true;\n\n        for (const token of tokens)\n        {\n            const isSpace = isBreakingSpace(token) || isNewline(token);\n\n            // Token continues from previous word if:\n            // 1. It's the first token in this run\n            // 2. The previous run's last token was a word (not space)\n            // 3. This token is also a word (not space)\n            const continuesFromPrevious = isFirstTokenInRun && lastTokenWasWord && !isSpace;\n\n            styledTokens.push({ token, style: run.style, continuesFromPrevious });\n\n            lastTokenWasWord = !isSpace;\n            isFirstTokenInRun = false;\n        }\n    }\n\n    return styledTokens;\n}\n", "import {\n    collapseNewlines,\n    collapseSpaces,\n    getCharacterGroups,\n    isBreakingSpace,\n    isNewline,\n    tokenize,\n    trimRight,\n} from './textTokenization';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle } from '../../TextStyle';\nimport type { CanBreakCharsFn, MeasureTextFn, WordWrapSplitFn } from './types';\n\ntype CharacterWidthCache = Record<string, number>;\n/**\n * Function type for checking if words can be broken.\n * @internal\n */\ntype CanBreakWordsFn = (token: string, breakWords: boolean) => boolean;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * Gets & sets the widths of calculated characters in a cache object\n * @param key - The key\n * @param letterSpacing - The letter spacing\n * @param cache - The cache\n * @param context - The canvas context\n * @param measureTextFn - Function to measure text\n * @returns The cached or measured width.\n * @internal\n */\nfunction getFromCache(\n    key: string,\n    letterSpacing: number,\n    cache: CharacterWidthCache,\n    context: ICanvasRenderingContext2D,\n    measureTextFn: MeasureTextFn,\n): number\n{\n    let width = cache[key];\n\n    if (typeof width !== 'number')\n    {\n        width = measureTextFn(key, letterSpacing, context) + letterSpacing;\n        cache[key] = width;\n    }\n\n    return width;\n}\n\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n * @param text - String to apply word wrapping to\n * @param style - the style to use when wrapping\n * @param canvas - specification of the canvas to use for measuring.\n * @param measureTextFn - Function to measure text width\n * @param canBreakWordsFn - Function to check if words can be broken\n * @param canBreakCharsFn - Function to check if characters can be broken\n * @param wordWrapSplitFn - Function to split words into characters\n * @returns New string with new lines applied where required\n * @internal\n */\nexport function wordWrap(\n    text: string,\n    style: TextStyle,\n    canvas: ICanvas,\n    measureTextFn: MeasureTextFn,\n    canBreakWordsFn: CanBreakWordsFn,\n    canBreakCharsFn: CanBreakCharsFn,\n    wordWrapSplitFn: WordWrapSplitFn,\n): string\n{\n    const context = canvas.getContext('2d', contextSettings);\n\n    context.font = style._fontString;\n\n    let width = 0;\n    let line = '';\n    const linesArray: string[] = [];\n\n    const cache: CharacterWidthCache = Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n\n    // How to handle whitespaces\n    const shouldCollapseSpaces = collapseSpaces(whiteSpace);\n    const shouldCollapseNewlines = collapseNewlines(whiteSpace);\n\n    // whether or not spaces may be added to the beginning of lines\n    let canPrependSpaces = !shouldCollapseSpaces;\n\n    // There is letterSpacing after every char except the last one\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n    // so for convenience the above needs to be compared to width + 1 extra letterSpace\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n    // ________________________________________________\n    // And then the final space is simply no appended to each line\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n    // break text into words, spaces and newline chars\n    const tokens = tokenize(text);\n\n    for (let i = 0; i < tokens.length; i++)\n    {\n        // get the word, space or newlineChar\n        let token = tokens[i];\n\n        // if word is a new line\n        if (isNewline(token))\n        {\n            // keep the new line\n            if (!shouldCollapseNewlines)\n            {\n                linesArray.push(trimRight(line));\n                canPrependSpaces = !shouldCollapseSpaces;\n                line = '';\n                width = 0;\n                continue;\n            }\n\n            // if we should collapse new lines\n            // we simply convert it into a space\n            token = ' ';\n        }\n\n        // if we should collapse repeated whitespaces\n        if (shouldCollapseSpaces)\n        {\n            // check both this and the last tokens for spaces\n            const currIsBreakingSpace = isBreakingSpace(token);\n            const lastIsBreakingSpace = isBreakingSpace(line[line.length - 1]);\n\n            if (currIsBreakingSpace && lastIsBreakingSpace)\n            {\n                continue;\n            }\n        }\n\n        // get word width from cache if possible\n        const tokenWidth = getFromCache(token, letterSpacing, cache, context, measureTextFn);\n\n        // word is longer than desired bounds\n        if (tokenWidth > wordWrapWidth)\n        {\n            // if we are not already at the beginning of a line\n            if (line !== '')\n            {\n                // start newlines for overflow words\n                linesArray.push(trimRight(line));\n                line = '';\n                width = 0;\n            }\n\n            // break large word over multiple lines\n            if (canBreakWordsFn(token, style.breakWords))\n            {\n                // break word into character groups that shouldn't be split\n                const charGroups = getCharacterGroups(token, style.breakWords, wordWrapSplitFn, canBreakCharsFn);\n\n                // loop the character groups\n                for (const char of charGroups)\n                {\n                    const characterWidth = getFromCache(char, letterSpacing, cache, context, measureTextFn);\n\n                    if (characterWidth + width > wordWrapWidth)\n                    {\n                        linesArray.push(trimRight(line));\n                        canPrependSpaces = false;\n                        line = '';\n                        width = 0;\n                    }\n\n                    line += char;\n                    width += characterWidth;\n                }\n            }\n\n            // run word out of the bounds\n            else\n            {\n                // if there are words in this line already\n                // finish that line and start a new one\n                if (line.length > 0)\n                {\n                    linesArray.push(trimRight(line));\n                    line = '';\n                    width = 0;\n                }\n\n                // give it its own line\n                linesArray.push(trimRight(token));\n                canPrependSpaces = false;\n                line = '';\n                width = 0;\n            }\n        }\n\n        // word could fit\n        else\n        {\n            // word won't fit because of existing words\n            // start a new line\n            if (tokenWidth + width > wordWrapWidth)\n            {\n                // if its a space we don't want it\n                canPrependSpaces = false;\n\n                // add a new line\n                linesArray.push(trimRight(line));\n\n                // start a new line\n                line = '';\n                width = 0;\n            }\n\n            // don't add spaces to the beginning of lines\n            if (line.length > 0 || !isBreakingSpace(token) || canPrependSpaces)\n            {\n                // add the word to the current line\n                line += token;\n\n                // update width counter\n                width += tokenWidth;\n            }\n        }\n    }\n\n    const trimmedLine = trimRight(line);\n\n    if (trimmedLine.length > 0)\n    {\n        linesArray.push(trimmedLine);\n    }\n\n    return linesArray.join('\\n');\n}\n", "import { lru } from 'tiny-lru';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { measureTaggedText } from './utils/measureTaggedText';\nimport { hasTagMarkup, hasTagStyles, type TextStyleRun } from './utils/parseTaggedText';\nimport { isBreakingSpace as isBreakingSpaceUtil, NEWLINE_MATCH_REGEX } from './utils/textTokenization';\nimport { wordWrap } from './utils/wordWrap';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle } from '../TextStyle';\nimport type { FontMetrics } from './utils/types';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        /**\n         * Creates a new Intl.Segmenter object.\n         * @returns A new Intl.Segmenter object.\n         */\n        new(): ISegmenter;\n    };\n}\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { CanvasTextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = CanvasTextMetrics.measureText('Your text', style);\n * @category text\n * @advanced\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * Per-line style runs for tagged text rendering.\n     * Each element is an array of runs for that line.\n     * Only populated when text contains tag markup.\n     * @internal\n     */\n    public runsByLine?: TextStyleRun[][];\n\n    /**\n     * Per-line ascent values for tagged text with mixed fonts.\n     * Represents the max ascent across all runs on each line.\n     * Only populated when text contains tag markup.\n     * @internal\n     */\n    public lineAscents?: number[];\n\n    /**\n     * Per-line descent values for tagged text with mixed fonts.\n     * Represents the max descent across all runs on each line.\n     * Only populated when text contains tag markup.\n     * @internal\n     */\n    public lineDescents?: number[];\n\n    /**\n     * Per-line heights for tagged text with mixed fonts.\n     * Each line may have different height based on the fonts used.\n     * Only populated when text contains tag markup.\n     * @internal\n     */\n    public lineHeights?: number[];\n\n    /**\n     * Whether any run in the tagged text has a drop shadow.\n     * Cached during measurement to avoid per-render iteration.\n     * Only populated when text contains tag markup.\n     * @internal\n     */\n    public hasDropShadow?: boolean;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|q';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) =>\n            {\n                const segments = segmenter.segment(s);\n                const result = [];\n\n                let i = 0;\n\n                for (const segment of segments)\n                {\n                    result[i++] = (segment.segment);\n                }\n\n                return result;\n            };\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see CanvasTextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result === undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see CanvasTextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@link TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    /** Cache for measured text metrics */\n    private static readonly _measurementCache = lru<CanvasTextMetrics>(1000);\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param fontProperties - the font properties object from TextMetrics.measureFont\n     * @param taggedData - optional object containing tagged text specific data\n     * @param taggedData.runsByLine - per-line style runs for tagged text\n     * @param taggedData.lineAscents - per-line ascent values for tagged text\n     * @param taggedData.lineDescents - per-line descent values for tagged text\n     * @param taggedData.lineHeights - per-line height values for tagged text\n     * @param taggedData.hasDropShadow - whether any run has a drop shadow\n     */\n    constructor(\n        text: string,\n        style: TextStyle,\n        width: number,\n        height: number,\n        lines: string[],\n        lineWidths: number[],\n        lineHeight: number,\n        maxLineWidth: number,\n        fontProperties: FontMetrics,\n        taggedData?: {\n            runsByLine?: TextStyleRun[][],\n            lineAscents?: number[],\n            lineDescents?: number[],\n            lineHeights?: number[],\n            hasDropShadow?: boolean,\n        },\n    )\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n\n        if (taggedData)\n        {\n            this.runsByLine = taggedData.runsByLine;\n            this.lineAscents = taggedData.lineAscents;\n            this.lineDescents = taggedData.lineDescents;\n            this.lineHeights = taggedData.lineHeights;\n            this.hasDropShadow = taggedData.hasDropShadow;\n        }\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;\n\n        // check if we have already measured this text with the same style\n        if (CanvasTextMetrics._measurementCache.has(textKey))\n        {\n            return CanvasTextMetrics._measurementCache.get(textKey);\n        }\n\n        // Check if we need to use tagged text measurement\n        const isTagged = hasTagStyles(style) && hasTagMarkup(text);\n\n        if (isTagged)\n        {\n            const result = measureTaggedText(\n                text,\n                style,\n                wordWrap,\n                CanvasTextMetrics._context,\n                CanvasTextMetrics._measureText,\n                CanvasTextMetrics.measureFont,\n                CanvasTextMetrics.canBreakChars,\n                CanvasTextMetrics.wordWrapSplit,\n            );\n\n            const measurements = new CanvasTextMetrics(\n                text,\n                style,\n                result.width,\n                result.height,\n                result.lines,\n                result.lineWidths,\n                result.lineHeight,\n                result.maxLineWidth,\n                result.fontProperties,\n                {\n                    runsByLine: result.runsByLine,\n                    lineAscents: result.lineAscents,\n                    lineDescents: result.lineDescents,\n                    lineHeights: result.lineHeights,\n                    hasDropShadow: result.hasDropShadow,\n                },\n            );\n\n            CanvasTextMetrics._measurementCache.set(textKey, measurements);\n\n            return measurements;\n        }\n\n        const font = style._fontString;\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n            fontProperties.descent = 0;\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n\n        const outputText = wordWrap\n            ? CanvasTextMetrics._wordWrap(text, style, canvas)\n            : text;\n        const lines = outputText.split(NEWLINE_MATCH_REGEX);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width ?? 0;\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        // Calculate base width - use wordWrapWidth for non-left alignment when wrapping\n        const baseWidth = CanvasTextMetrics._getAlignWidth(maxLineWidth, style, wordWrap);\n        const width = CanvasTextMetrics._adjustWidthForStyle(baseWidth, style);\n\n        // Calculate height\n        const baseHeight = Math.max(lineHeight, fontProperties.fontSize + strokeWidth)\n            + ((lines.length - 1) * (lineHeight + style.leading));\n        const height = CanvasTextMetrics._adjustHeightForStyle(baseHeight, style);\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // cache the measurements\n        CanvasTextMetrics._measurementCache.set(textKey, measurements);\n\n        return measurements;\n    }\n\n    /**\n     * Adjusts the measured width to account for stroke and drop shadow.\n     * @param baseWidth - The base content width\n     * @param style - The text style\n     * @returns The adjusted width\n     */\n    private static _adjustWidthForStyle(baseWidth: number, style: TextStyle): number\n    {\n        const strokeWidth = style._stroke?.width || 0;\n        let width = baseWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        return width;\n    }\n\n    /**\n     * Adjusts the measured height to account for drop shadow.\n     * @param baseHeight - The base content height\n     * @param style - The text style\n     * @returns The adjusted height\n     */\n    private static _adjustHeightForStyle(baseHeight: number, style: TextStyle): number\n    {\n        let height = baseHeight;\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        return height;\n    }\n\n    /**\n     * Calculates the base width for alignment purposes.\n     * When word wrap is enabled with center/right alignment, uses wordWrapWidth.\n     * @param maxLineWidth - The maximum line width\n     * @param style - The text style\n     * @param wordWrapEnabled - Whether word wrap is enabled\n     * @returns The width to use for alignment calculations\n     */\n    private static _getAlignWidth(maxLineWidth: number, style: TextStyle, wordWrapEnabled: boolean): number\n    {\n        const useWrapWidth = wordWrapEnabled && style.align !== 'left' && style.align !== 'justify';\n\n        return useWrapWidth ? Math.max(maxLineWidth, style.wordWrapWidth) : maxLineWidth;\n    }\n\n    /**\n     * Measures the rendered width of a string, accounting for letter spacing and using the provided context.\n     * @param text - The text to measure\n     * @param letterSpacing - Letter spacing in pixels\n     * @param context - Canvas 2D context\n     * @returns The measured width of the text with spacing\n     * @internal\n     */\n    public static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    ): number\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -(metrics.actualBoundingBoxLeft ?? 0);\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight ?? 0;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        return wordWrap(\n            text,\n            style,\n            canvas,\n            CanvasTextMetrics._measureText,\n            CanvasTextMetrics.canBreakWords,\n            CanvasTextMetrics.canBreakChars,\n            CanvasTextMetrics.wordWrapSplit,\n        );\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        return isBreakingSpaceUtil(char, _nextChar);\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const ascent = metrics.actualBoundingBoxAscent ?? 0;\n        const descent = metrics.actualBoundingBoxDescent ?? 0;\n\n        const properties = {\n            ascent,\n            descent,\n            fontSize: ascent + descent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (_cx)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n", "import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n * @internal\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { type Filter } from '../../filters/Filter';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport { toFillStyle, toStrokeStyle } from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { fontStringFromTextStyle } from './canvas/utils/fontStringFromTextStyle';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\n/**\n * The alignment of the text.\n *\n * - 'left': Aligns text to the left edge.\n * - 'center': Centers text horizontally.\n * - 'right': Aligns text to the right edge.\n * - 'justify': Justifies text, aligning both left and right edges.\n * @example\n * ```ts\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   align: 'center', // or 'left', 'right', 'justify'\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\n/**\n * The fill style input for text styles.\n *\n * This can be:\n * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n * - A hex number like 0xff0000 for red\n * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n * - A FillGradient for gradient fills\n * - A FillPattern for pattern/texture fills\n * @example\n * ```ts\n * // Simple Fills\n * new TextStyle({ fill: 'red' }); // Color string\n * new TextStyle({ fill: 0x00ff00 }); // Hex color\n * new TextStyle({ fill: 'rgb(255,0,0)' }); // RGB string\n * // Gradients\n * new TextStyle({\n *     fill: new FillGradient({\n *         end: { x: 1, y: 1 },\n *         stops: [\n *             { color: 0xff0000, offset: 0 }, // Red at start\n *             { color: 0x0000ff, offset: 1 }, // Blue at end\n *         ]\n *     }),\n * });\n * // Patterns\n * new TextStyle({\n *    fill: new FillPattern(Assets.get('pattern.png'))\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\n/**\n * The font style input for text styles. Controls the slant or italicization of the text.\n * @example\n * ```ts\n * // Create text with normal font style\n * const normalText = new Text({\n *     text: 'Normal Style Text',\n *     style: {\n *         fontStyle: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create italic text\n * const italicText = new Text({\n *     text: 'Italic Style Text',\n *     style: {\n *         fontStyle: 'italic',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Create oblique text\n * const obliqueText = new Text({\n *     text: 'Oblique Style Text',\n *     style: {\n *         fontStyle: 'oblique',\n *         fontSize: 24,\n *         fontFamily: 'Times New Roman'\n *     }\n * });\n *\n * // Dynamic style changes\n * let isItalic = false;\n * text.style = {\n *     ...text.style,\n *     fontStyle: isItalic ? 'italic' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular upright text with no slant\n * - 'italic': True italics using specifically designed italic glyphs\n * - 'oblique': Slanted version of the regular glyphs\n * @remarks\n * - 'italic' uses specially designed glyphs with cursive characteristics\n * - 'oblique' is a mechanical slant of the normal glyphs\n * - Not all fonts include true italic designs; some may fall back to oblique\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style | MDN font-style}\n * @category text\n * @standard\n */\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\n/**\n * The font variant input for text styles. Controls the capitalization and presentation of letters.\n * Used to enable special rendering like small caps.\n * @example\n * ```ts\n * // Create text with normal font variant\n * const normalText = new Text({\n *     text: 'Normal Text',\n *     style: {\n *         fontVariant: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create text with small-caps variant\n * const smallCapsText = new Text({\n *     text: 'Small Caps Text',\n *     style: {\n *         fontVariant: 'small-caps',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Use in a TextStyle instance\n * const style = new TextStyle({\n *     fontVariant: 'small-caps',\n *     fontSize: 32,\n *     fill: 0x4a4a4a\n * });\n *\n * // Update variant dynamically\n * text.style = {\n *     ...text.style,\n *     fontVariant: text.style.fontVariant === 'normal' ? 'small-caps' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular text rendering with standard capitalization\n * - 'small-caps': Renders lowercase letters as smaller versions of capital letters\n * @remarks\n * Small caps are only available if the font supports them.\n * Not all fonts include true small caps glyphs.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant | MDN font-variant}\n * @category text\n * @standard\n */\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n/**\n * The font weight input for text styles. Controls the thickness or boldness of the text.\n * @example\n * ```ts\n * // Create text with different font weights\n * const normalText = new Text({\n *     text: 'Normal Weight',\n *     style: { fontWeight: 'normal' }\n * });\n *\n * const boldText = new Text({\n *     text: 'Bold Weight',\n *     style: { fontWeight: 'bold' }\n * });\n *\n * // Using numeric weights\n * const lightText = new Text({\n *     text: 'Light Weight',\n *     style: { fontWeight: '300' }\n * });\n *\n * const mediumText = new Text({\n *     text: 'Medium Weight',\n *     style: { fontWeight: '500' }\n * });\n *\n * const heavyText = new Text({\n *     text: 'Heavy Weight',\n *     style: { fontWeight: '900' }\n * });\n *\n * // Responsive weight changes\n * const adaptiveText = new Text({\n *     text: 'Adaptive Weight',\n *     style: { fontWeight: window.innerWidth > 600 ? 'bold' : 'normal' }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Standard weight (equivalent to 400)\n * - 'bold': Bold weight (equivalent to 700)\n * - 'bolder': One weight darker than the parent element\n * - 'lighter': One weight lighter than the parent element\n * - '100': Thin (Hairline)\n * - '200': Extra Light (Ultra Light)\n * - '300': Light\n * - '400': Normal\n * - '500': Medium\n * - '600': Semi Bold (Demi Bold)\n * - '700': Bold\n * - '800': Extra Bold (Ultra Bold)\n * - '900': Heavy (Black)\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight | MDN font-weight}\n * @category text\n * @standard\n */\nexport type TextStyleFontWeight =\n    | 'normal' // Standard weight (400)\n    | 'bold' // Bold weight (700)\n    | 'bolder' // Relative weight increase\n    | 'lighter' // Relative weight decrease\n    | '100' // Thin\n    | '200' // Extra Light\n    | '300' // Light\n    | '400' // Normal\n    | '500' // Medium\n    | '600' // Semi Bold\n    | '700' // Bold\n    | '800' // Extra Bold\n    | '900'; // Heavy\n/**\n * The line join style for text strokes. Determines how lines connect at corners.\n * @example\n * ```ts\n * // Create text with miter joins (sharp corners)\n * const sharpText = new Text({\n *     text: 'Sharp Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'miter'  // Sharp corners\n *         }\n *     }\n * });\n *\n * // Create text with round joins\n * const roundText = new Text({\n *     text: 'Rounded Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'round'  // Smooth rounded corners\n *         }\n *     }\n * });\n *\n * // Create text with beveled joins\n * const bevelText = new Text({\n *     text: 'Beveled Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'bevel'  // Flattened corners\n *         }\n *     }\n * });\n * ```\n * Available values:\n * - 'miter': Creates sharp corners by extending the outer edges until they meet\n * - 'round': Creates smooth, rounded corners using a circular arc\n * - 'bevel': Creates flattened corners by filling an additional triangle between the outer edges\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin | MDN lineJoin}\n * @category text\n * @standard\n */\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\n/**\n * The text baseline for text styles.\n *\n * This can be:\n * - 'alphabetic': The alphabetic baseline\n * - 'top': The top of the text\n * - 'hanging': The hanging baseline\n * - 'middle': The middle of the text\n * - 'ideographic': The ideographic baseline\n * - 'bottom': The bottom of the text\n * @category text\n * @standard\n */\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\n/**\n * Controls how whitespace (spaces, tabs, and line breaks) is handled within the text.\n * This affects text wrapping and spacing behavior.\n * @example\n * ```ts\n * // Normal mode (collapse spaces and newlines)\n * const normalText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'normal',\n *         fontSize: 24\n *     }\n * }); // Renders as: \"Hello World New Line\"\n *\n * // Pre mode (preserve all whitespace)\n * const preText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre',\n *         fontSize: 24\n *     }\n * }); // Preserves spaces and line breaks exactly\n *\n * // Pre-line mode (preserve newlines, collapse spaces)\n * const preLineText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         fontSize: 24\n *     }\n * }); // Preserves line breaks, collapses multiple spaces\n *\n * // With word wrap enabled\n * const wrappedText = new Text({\n *     text: 'A long text with    multiple spaces\\nand line breaks',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         fontSize: 24\n *     }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Collapses all whitespace (spaces, tabs, line breaks) into a single space\n * - 'pre': Preserves all whitespace characters exactly as written\n * - 'pre-line': Preserves line breaks but collapses multiple spaces into a single space\n * @remarks\n * - 'normal' is best for single-line text or when you want to ignore formatting\n * - 'pre' is useful for code blocks or when exact spacing is important\n * - 'pre-line' is good for formatted text where you want to keep line breaks but clean up spaces\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space | MDN white-space}\n * @see {@link TextStyle#wordWrap} For controlling text wrapping\n * @category text\n * @standard\n */\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * Defines a drop shadow effect for text rendering.\n * Drop shadows add depth and emphasis to text by creating a shadow offset from the text.\n * @example\n * ```ts\n * // Create text with basic drop shadow\n * const text = new Text({\n *     text: 'Shadow Text',\n *     style: {\n *         fontSize: 48,\n *         dropShadow: {\n *             alpha: 0.5,         // 50% opacity shadow\n *             angle: Math.PI / 6, // 30 degrees\n *             blur: 4,            // Soft shadow edge\n *             color: '#000000',   // Black shadow\n *             distance: 6         // Shadow offset\n *         }\n *     }\n * });\n *\n * // Dynamic shadow updates\n * text.style.dropShadow = {\n *     alpha: Math.sin(Date.now() / 1000) * 0.5 + 0.5, // Pulsing opacity\n *     angle: Date.now() / 1000,                        // Rotating angle\n *     blur: 4,\n *     color: '#000000',\n *     distance: 6\n * };\n * ```\n * @category text\n * @standard\n */\nexport type TextDropShadow = {\n    /**\n     * The opacity of the drop shadow.\n     * - Range: 0 to 1\n     * - 0 = fully transparent\n     * - 1 = fully opaque\n     * @example\n     * ```ts\n     * // Set drop shadow opacity to 50%\n     * dropShadow: {\n     *    alpha: 0.5\n     * }\n     * ```\n     * @default 1\n     */\n    alpha: number;\n\n    /**\n     * The angle of the drop shadow in radians.\n     * - 0 = right\n     * - Math.PI/2 = down\n     * - Math.PI = left\n     * - Math.PI*1.5 = up\n     * @example\n     * ```ts\n     * // Set drop shadow angle to 30 degrees\n     * dropShadow: {\n     *    angle: Math.PI / 6 // 30 degrees\n     * }\n     * ```\n     * @default Math.PI/6 (30 degrees)\n     */\n    angle: number;\n\n    /**\n     * The blur radius of the shadow.\n     * - 0 = sharp shadow\n     * - Higher values = softer shadow\n     * @example\n     * ```ts\n     * // Set drop shadow blur radius to 10 pixels\n     * dropShadow: {\n     *   blur: 10\n     * }\n     * ```\n     * @default 0\n     */\n    blur: number;\n\n    /**\n     * The color of the drop shadow.\n     * Accepts any valid CSS color string, hex number, or RGB/RGBA values.\n     * @example '#000000', 'rgba(0,0,0,0.5)', 0x000000\n     * @default 'black'\n     */\n    color: ColorSource;\n\n    /**\n     * The distance of the drop shadow from the text.\n     * Measured in pixels.\n     * @example\n     * ```ts\n     * // Set drop shadow distance to 5 pixels\n     * dropShadow: {\n     *   distance: 5\n     * }\n     * ```\n     * @default 5\n     */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances. Defines the visual appearance and layout of text.\n * @example\n * ```ts\n * // Basic text style\n * const basicStyle = new TextStyle({\n *     fontSize: 24,\n *     fill: 'black',\n *     fontFamily: 'Arial'\n * });\n *\n * // Rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: ['Arial', 'Helvetica', 'sans-serif'],\n *     fontSize: 36,\n *     fontWeight: 'bold',\n *     fill: 'red',\n *     stroke: { color: '#4a1850', width: 5 },\n *     align: 'center',\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     textBaseline: 'middle'\n * });\n * ```\n * @see {@link TextStyle} For the main style class\n * @category text\n * @standard\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @default 'left'\n     */\n    align?: TextStyleAlign;\n    /**\n     * Whether to allow line breaks within words.\n     * Requires wordWrap to be true.\n     * @example\n     * ```ts\n     * // Enable word breaking\n     * const style = new TextStyle({\n     *    breakWords: true,\n     *    wordWrap: true,\n     *    wordWrapWidth: 200\n     * });\n     * ```\n     * @default false\n     */\n    breakWords?: boolean;\n    /**\n     * Drop shadow configuration for the text.\n     * Can be boolean or a TextDropShadow object.\n     * @default null\n     */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * Fill style for the text.\n     * Can be a color, gradient, or pattern.\n     * @default 'black'\n     */\n    fill?: FillInput;\n    /**\n     * Font family or families to use.\n     * Can be single name or array of fallbacks.\n     * @example\n     * ```ts\n     * // Single font family\n     * fontFamily: 'Arial'\n     * // Multiple font families\n     * fontFamily: ['Helvetica', 'Arial', 'sans-serif']\n     * ```\n     * @default 'Arial'\n     */\n    fontFamily?: string | string[];\n    /**\n     * Font size in pixels or as string.\n     *\n     * Equivalents are '26px','20pt','160%' or '1.6em')\n     * @example\n     * ```ts\n     * // Numeric size\n     * fontSize: 26\n     * // String size\n     * fontSize: '26px'\n     * // Percentage size\n     * fontSize: '160%' // 1.6 times the parent element's font size\n     * // Em size\n     * fontSize: '1.6em' // 1.6 times the parent element's font size\n     * @default 26\n     */\n    fontSize?: number | string;\n    /**\n     * Font style (normal, italic, oblique).\n     * @default 'normal'\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * Font variant (normal, small-caps).\n     * @default 'normal'\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * Font weight (normal, bold, bolder, lighter, 100-900).\n     * @default 'normal'\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Padding around the text.\n     *\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /**\n     * Stroke style for text outline.\n     * @default null\n     */\n    stroke?: StrokeInput;\n    /**\n     * Vertical alignment baseline.\n     * @default 'alphabetic'\n     */\n    textBaseline?: TextStyleTextBaseline;\n    /**\n     * Whether to trim transparent edges.\n     * > [!NOTE] This is an expensive operation and should only be used when necessary.\n     * @default false\n     */\n    trim?: boolean;\n    /**\n     * How to handle whitespace.\n     *\n     * It needs wordWrap to be set to true for this to have an effect.\n     * @default 'pre'\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n    /**\n     * Array of filters to apply to the text.\n     *\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default undefined\n     */\n    filters?: Filter[] | readonly Filter[];\n    /**\n     * Custom styles to apply to specific tags within the text.\n     * Allows for rich text formatting using simple tag markup like `<red>text</red>`.\n     *\n     * Tags are only parsed when this property has entries. If `tagStyles` is empty or undefined,\n     * `<` characters in text are treated as literal.\n     *\n     * Nested tags are supported via a style stack - inner tags inherit from outer tags\n     * but can override specific properties.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: '<red>Red</red>, <blue>Blue</blue>, <big>Big</big>',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 'white',\n     *         tagStyles: {\n     *             red: { fill: 'red' },\n     *             blue: { fill: 'blue' },\n     *             big: { fontSize: 48 }\n     *         }\n     *     }\n     * });\n     * ```\n     * @default undefined\n     */\n    tagStyles?: Record<string, TextStyleOptions>;\n}\n\n/**\n * A TextStyle Object contains information to decorate Text objects.\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @example\n * ```ts\n * // Create a basic text style\n * const style = new TextStyle({\n *     fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *     fontSize: 36,\n *     fill: 0xff1010,\n *     align: 'center'\n * });\n *\n * // Create a rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 32,\n *     fill: 'white',\n *     stroke: {\n *         color: '#4a1850',\n *         width: 5\n *     },\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     align: 'center'\n * });\n *\n * // Share style between multiple text objects\n * const text1 = new Text({\n *     text: 'Hello',\n *     style: richStyle\n * });\n *\n * const text2 = new Text({\n *     text: 'World',\n *     style: richStyle\n * });\n *\n * // Update style dynamically - affects all text objects\n * richStyle.fontSize = 48;\n * richStyle.fill = 0x00ff00;\n * ```\n *\n * Key Features:\n * - Shared styling between multiple text objects\n * - Rich text formatting options\n * - Gradient and pattern fills\n * - Drop shadows and strokes\n * - Word wrapping and alignment\n * - Dynamic updates\n * @category text\n * @standard\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /**\n     * Default drop shadow settings used when enabling drop shadows on text.\n     * These values are used as the base configuration when drop shadows are enabled without specific settings.\n     * @example\n     * ```ts\n     * // Customize default settings globally\n     * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows\n     * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows\n     * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default\n     * ```\n     */\n    public static defaultDropShadow: TextDropShadow = {\n        alpha: 1,\n        angle: Math.PI / 6,\n        blur: 0,\n        color: 'black',\n        distance: 5\n    };\n\n    /**\n     * Unique identifier for the TextStyle class.\n     * This is used to track instances and ensure uniqueness.\n     * @internal\n     */\n    public uid = uid('textStyle');\n    /**\n     * Internal tick counter used to track updates and changes.\n     * This is incremented whenever the style is modified, allowing for efficient change detection.\n     * @internal\n     */\n    public _tick = 0;\n\n    /**\n     * Default text style settings used when creating new text objects.\n     * These values serve as the base configuration and can be customized globally.\n     * @example\n     * ```ts\n     * // Customize default text style globally\n     * TextStyle.defaultTextStyle.fontSize = 16;\n     * TextStyle.defaultTextStyle.fill = 0x333333;\n     * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];\n     * ```\n     */\n    public static defaultTextStyle: TextStyleOptions = {\n        align: 'left',\n        breakWords: false,\n        dropShadow: null,\n        fill: 'black',\n        fontFamily: 'Arial',\n        fontSize: 26,\n        fontStyle: 'normal',\n        fontVariant: 'normal',\n        fontWeight: 'normal',\n        leading: 0,\n        letterSpacing: 0,\n        lineHeight: 0,\n        padding: 0,\n        stroke: null,\n        textBaseline: 'alphabetic',\n        trim: false,\n        whiteSpace: 'pre',\n        wordWrap: false,\n        wordWrapWidth: 100\n    };\n\n    // colors!!\n    /** @internal */\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    /** @internal */\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n    private _filters: readonly Filter[];\n\n    private _padding: number;\n\n    private _trim: boolean;\n    private _cachedFontString: string | null = null;\n    /** @internal */\n    public _tagStyles: Record<string, TextStyleOptions> | undefined;\n\n    /**\n     * When set, gradient fills use these bounds instead of the text's own measured dimensions.\n     * Used by SplitText to make character gradients span the full text width.\n     * @internal\n     */\n    public _gradientBounds?: { width: number; height: number };\n\n    /**\n     * When set, gradient fills are offset by this amount within the gradient bounds.\n     * Used by SplitText to position each character's gradient correctly.\n     * @internal\n     */\n    public _gradientOffset?: { x: number; y: number };\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        // When style is a TextStyle instance, use its toObject() values instead of the spread\n        // which copies proxy objects bound to the wrong instance.\n        const isTextStyle = style instanceof TextStyle;\n        const existingStyle = style as TextStyle;\n\n        if (isTextStyle)\n        {\n            style = existingStyle._toObject();\n        }\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        // Initialize tagStyles separately (not in defaultTextStyle to avoid shared reference)\n        this._tagStyles = style.tagStyles ?? undefined;\n\n        this.update();\n        this._tick = 0;\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n\n    set align(value: TextStyleAlign)\n    {\n        if (this._align === value) return;\n\n        this._align = value;\n        this.update();\n    }\n\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n\n    set breakWords(value: boolean)\n    {\n        if (this._breakWords === value) return;\n\n        this._breakWords = value;\n        this.update();\n    }\n\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (this._dropShadow === value) return;\n\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n\n    set fontFamily(value: string | string[])\n    {\n        if (this._fontFamily === value) return;\n\n        this._fontFamily = value;\n        this.update();\n    }\n\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n\n    set fontSize(value: string | number)\n    {\n        if (this._fontSize === value) return;\n\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        if (this._fontStyle === value) return;\n\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n\n    set fontVariant(value: TextStyleFontVariant)\n    {\n        if (this._fontVariant === value) return;\n\n        this._fontVariant = value;\n        this.update();\n    }\n\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n\n    set fontWeight(value: TextStyleFontWeight)\n    {\n        if (this._fontWeight === value) return;\n\n        this._fontWeight = value;\n        this.update();\n    }\n\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n\n    set leading(value: number)\n    {\n        if (this._leading === value) return;\n\n        this._leading = value;\n        this.update();\n    }\n\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n\n    set letterSpacing(value: number)\n    {\n        if (this._letterSpacing === value) return;\n\n        this._letterSpacing = value;\n        this.update();\n    }\n\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n\n    set lineHeight(value: number)\n    {\n        if (this._lineHeight === value) return;\n\n        this._lineHeight = value;\n        this.update();\n    }\n\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     * > [!NOTE] This will NOT affect the positioning or bounds of the text.\n     */\n    get padding(): number { return this._padding; }\n\n    set padding(value: number)\n    {\n        if (this._padding === value) return;\n\n        this._padding = value;\n        this.update();\n    }\n\n    /**\n     * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default null\n     */\n    get filters(): readonly Filter[] { return this._filters; }\n\n    set filters(value: Filter[])\n    {\n        if (this._filters === value) return;\n\n        this._filters = Object.freeze(value);\n        this.update();\n    }\n\n    /**\n     * Trim transparent borders from the text texture.\n     * > [!IMPORTANT] PERFORMANCE WARNING:\n     * > This is a costly operation as it requires scanning pixel alpha values.\n     * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.\n     */\n    get trim(): boolean { return this._trim; }\n\n    set trim(value: boolean)\n    {\n        if (this._trim === value) return;\n\n        this._trim = value;\n        this.update();\n    }\n\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n\n    set textBaseline(value: TextStyleTextBaseline)\n    {\n        if (this._textBaseline === value) return;\n\n        this._textBaseline = value;\n        this.update();\n    }\n\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n\n    set whiteSpace(value: TextStyleWhiteSpace)\n    {\n        if (this._whiteSpace === value) return;\n\n        this._whiteSpace = value;\n        this.update();\n    }\n\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n\n    set wordWrap(value: boolean)\n    {\n        if (this._wordWrap === value) return;\n\n        this._wordWrap = value;\n        this.update();\n    }\n\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n\n    set wordWrapWidth(value: number)\n    {\n        if (this._wordWrapWidth === value) return;\n\n        this._wordWrapWidth = value;\n        this.update();\n    }\n\n    /**\n     * The fill style that will be used to color the text.\n     * This can be:\n     * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n     * - A hex number like 0xff0000 for red\n     * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n     * - A FillGradient for gradient fills\n     * - A FillPattern for pattern/texture fills\n     *\n     * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n     * while gradients at any other angle are spread across the entire text body as a whole.\n     * @example\n     * // Vertical gradient applied per line\n     * const verticalGradient = new FillGradient(0, 0, 0, 1)\n     *     .addColorStop(0, 0xff0000)\n     *     .addColorStop(1, 0x0000ff);\n     *\n     * const text = new Text({\n     *     text: 'Line 1\\nLine 2',\n     *     style: { fill: verticalGradient }\n     * });\n     *\n     * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n     * @type {string|number|FillStyle|FillGradient|FillPattern}\n     */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    /**\n     * Custom styles to apply to specific tags within the text.\n     * Allows for rich text formatting using simple tag markup like `<red>text</red>`.\n     *\n     * Tags are only parsed when this property has entries. If `tagStyles` is undefined,\n     * `<` characters in text are treated as literal.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: '<red>Red</red>, <blue>Blue</blue>',\n     *     style: {\n     *         fill: 'white',\n     *         tagStyles: {\n     *             red: { fill: 'red' },\n     *             blue: { fill: 'blue' }\n     *         }\n     *     }\n     * });\n     * ```\n     */\n    public get tagStyles(): Record<string, TextStyleOptions> | undefined\n    {\n        return this._tagStyles;\n    }\n\n    public set tagStyles(value: Record<string, TextStyleOptions> | undefined)\n    {\n        if (this._tagStyles === value) return;\n\n        this._tagStyles = value ?? undefined;\n        this.update();\n    }\n\n    public update()\n    {\n        this._tick++;\n        this._cachedFontString = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    /**\n     * Assigns partial style options to this TextStyle instance.\n     * Uses public setters to ensure proper value transformation.\n     * @param values - Partial style options to assign\n     * @returns This TextStyle instance for chaining\n     */\n    public assign(values: Partial<TextStyleOptions>): this\n    {\n        for (const key in values)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = values[key as keyof typeof values] as any;\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `${this.uid}-${this._tick}`;\n    }\n\n    /**\n     * Returns the CSS font string for this style, cached for performance.\n     * @internal\n     * @returns CSS font string\n     */\n    public get _fontString(): string\n    {\n        if (this._cachedFontString === null)\n        {\n            this._cachedFontString = fontStringFromTextStyle(this);\n        }\n\n        return this._cachedFontString;\n    }\n\n    /**\n     * Returns an object with the same values as this TextStyle instance.\n     * @returns Object with the same values as this TextStyle instance\n     * @example\n     * ```ts\n     * const style = new TextStyle({\n     *     fontSize: 24,\n     *     fill: 0xff0000,\n     *     stroke: { color: 0x0000ff, width: 2 }\n     * });\n     * const object = style.toObject();\n     * console.log(object);\n     * // { fontSize: 24, fill: 0xff0000, stroke: { color: 0x0000ff, width: 2 } }\n     * ```\n     */\n    protected _toObject(): Required<TextStyleOptions>\n    {\n        return {\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill ? { ...this._fill } : undefined,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke ? { ...this._stroke } : undefined,\n            textBaseline: this.textBaseline,\n            trim: this.trim,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            filters: this._filters ? [...this._filters] : undefined,\n            tagStyles: this._tagStyles ? { ...this._tagStyles } : undefined,\n        };\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle(this._toObject());\n    }\n\n    /**\n     * Returns the final padding for the text style, taking into account any filters applied.\n     * Used internally for correct measurements\n     * @internal\n     * @returns {number} The final padding for the text style.\n     */\n    public _getFinalPadding(): number\n    {\n        let filterPadding = 0;\n\n        if (this._filters)\n        {\n            for (let i = 0; i < this._filters.length; i++)\n            {\n                filterPadding += this._filters[i].padding;\n            }\n        }\n\n        return Math.max(this._padding, filterPadding);\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * // Destroy the text style and its textures\n     * textStyle.destroy({ texture: true, textureSource: true });\n     * textStyle.destroy(true);\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                if (target[property as keyof T] === newValue) return true;\n\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance: oldStyle.dropShadowDistance ?? defaults.distance\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0)\n        {\n            throw new Error('Invalid fill value. Expected an array of colors for gradient fill.');\n        }\n\n        if (oldStyle.fill.length !== oldStyle.fillGradientStops.length)\n        {\n            // #if _DEBUG\n            warn('The number of fill colors must match the number of fill gradient stops.');\n            // #endif\n        }\n\n        const gradientFill = new FillGradient({\n            start: { x: 0, y: 0 },\n            end: { x: 0, y: 1 },\n            textureSpace: 'local'\n        });\n\n        const fillGradientStops = oldStyle.fillGradientStops.slice();\n        const fills: number[] = oldStyle.fill\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fillGradientStops.forEach((stop, index) =>\n        {\n            gradientFill.addColorStop(stop, fills[index]);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n", "import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\nimport type { CanvasTextMetrics } from '../CanvasTextMetrics';\n\n// 5 decimal places\nconst PRECISION = 100000;\n\n/**\n * Converts a PixiJS fill style into a Canvas-compatible fill style.\n * Handles solid colors, textures, patterns, and gradients.\n * @param fillStyle - The PixiJS fill style to convert\n * @param context - The canvas rendering context\n * @param textMetrics - Metrics about the text being rendered\n * @param padding - Padding to add to the text metrics (used to ensure that the gradient accommodates the stroke width)\n * @param offsetX - X offset for gradient positioning (used for tagged text runs)\n * @param offsetY - Y offset for gradient positioning (used for tagged text runs)\n * @returns Canvas-compatible fill style (string, CanvasGradient, or CanvasPattern)\n * @internal\n */\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D,\n    textMetrics?: CanvasTextMetrics,\n    padding = 0,\n    offsetX = 0,\n    offsetY = 0\n): string | CanvasGradient | CanvasPattern\n{\n    // Solid color fill\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    // Basic texture fill\n    else if (!fillStyle.fill)\n    {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.source.pixelWidth, fillStyle.texture.source.pixelHeight);\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Pattern fill\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.source.pixelWidth,\n            fillPattern.texture.source.pixelHeight\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Gradient fill\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        const isLinear = fillGradient.type === 'linear';\n        const isLocal = fillGradient.textureSpace === 'local';\n\n        let width = 1;\n        let height = 1;\n\n        // Use text dimensions if in local space\n        if (isLocal && textMetrics)\n        {\n            width = textMetrics.width + padding;\n            height = textMetrics.height + padding;\n        }\n\n        let gradient: CanvasGradient;\n        let isNearlyVertical = false;\n\n        if (isLinear)\n        {\n            const { start, end } = fillGradient;\n\n            gradient = context.createLinearGradient(\n                (start.x * width) + offsetX,\n                (start.y * height) + offsetY,\n                (end.x * width) + offsetX,\n                (end.y * height) + offsetY\n            );\n\n            // Check if gradient is nearly vertical (10% threshold)\n            isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);\n        }\n        else\n        {\n            const { center, innerRadius, outerCenter, outerRadius } = fillGradient;\n\n            gradient = context.createRadialGradient(\n                (center.x * width) + offsetX,\n                (center.y * height) + offsetY,\n                innerRadius * width,\n                (outerCenter.x * width) + offsetX,\n                (outerCenter.y * height) + offsetY,\n                outerRadius * width\n            );\n        }\n\n        // For vertical gradients in local space, repeat gradient per text line\n        if (isNearlyVertical && isLocal && textMetrics)\n        {\n            const ratio = (textMetrics.lineHeight) / height;\n\n            for (let i = 0; i < textMetrics.lines.length; i++)\n            {\n                const start = ((i * textMetrics.lineHeight) + (padding / 2)) / height;\n\n                fillGradient.colorStops.forEach((stop) =>\n                {\n                    // Convert to global space\n                    let globalStop = start + (stop.offset * ratio);\n\n                    globalStop = Math.max(0, Math.min(1, globalStop));\n\n                    gradient.addColorStop(\n                        // fix to 5 decimal places to avoid floating point precision issues\n                        Math.floor(globalStop * PRECISION) / PRECISION,\n                        Color.shared.setValue(stop.color).toHex()\n                    );\n                });\n            }\n        }\n        else\n        {\n            // Standard global space gradient handling\n            fillGradient.colorStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n        }\n\n        return gradient;\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n", "import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/utils/types';\n\n/** @internal */\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n    textureStyle?: TextureStyle | TextureStyleOptions\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @category text\n * @internal\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentMaxCharHeight = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n    private readonly _textureStyle?: TextureStyle;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        if (dynamicOptions.textureStyle)\n        {\n            this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle\n                ? dynamicOptions.textureStyle\n                : new TextureStyle(dynamicOptions.textureStyle);\n        }\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = CanvasTextMetrics.graphemeSegmenter(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        let currentMaxCharHeight = this._currentMaxCharHeight;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += currentMaxCharHeight;\n\n                // reset the line x and height..\n                currentMaxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + currentMaxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentX = 0;\n                    currentY = 0;\n                    currentMaxCharHeight = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._currentMaxCharHeight = currentMaxCharHeight;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        if (this._textureStyle)\n        {\n            texture.source.style = this._textureStyle;\n        }\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        let removeShadow = false;\n\n        if (style.stroke && strokeThickness)\n        {\n            removeShadow = true;\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        const { shadowBlur, shadowOffsetX, shadowOffsetY } = context;\n\n        if (style._fill)\n        {\n            if (removeShadow)\n            {\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (removeShadow)\n        {\n            context.shadowBlur = shadowBlur;\n            context.shadowOffsetX = shadowOffsetX;\n            context.shadowOffsetY = shadowOffsetY;\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n", "import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\n/**\n * The layout data for a bitmap text.\n * This contains the width, height, scale, offsetY and lines of text.\n * Each line contains its width, character positions, characters, space width and spaces index.\n * @category text\n * @internal\n */\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\n/**\n * @param chars\n * @param style\n * @param font\n * @param trimEnd\n * @internal\n */\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n    const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;\n\n    const breakWords = style.wordWrap && style.breakWords;\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += adjustedLineHeight;\n    };\n\n    const checkIsOverflow = (lineWidth: number) =>\n        lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                nextLine();\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);\n\n            if (addWordToNextLine)\n            {\n                nextWord(currentWord);\n                nextLine();\n            }\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n", "/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n", "import { lru } from 'tiny-lru';\nimport { Cache } from '../../assets/cache/Cache';\nimport { type TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n * The options for installing a new BitmapFont. Once installed, the font will be available\n * for use in BitmapText objects through the fontFamily property of TextStyle.\n * @example\n * ```ts\n * import { BitmapFont, BitmapText } from 'pixi.js';\n *\n * // Basic font installation\n * BitmapFont.install({\n *     name: 'BasicFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: '#ffffff'\n *     }\n * });\n *\n * // Advanced font installation\n * BitmapFont.install({\n *     name: 'AdvancedFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ff0000',\n *         stroke: { color: '#000000', width: 2 }\n *     },\n *     // Include specific character ranges\n *     chars: [\n *         ['a', 'z'],           // lowercase letters\n *         ['A', 'Z'],           // uppercase letters\n *         ['0', '9'],           // numbers\n *         '!@#$%^&*()_+-=[]{}' // symbols\n *     ],\n *     resolution: 2,            // High-DPI support\n *     padding: 4,              // Glyph padding\n *     skipKerning: false,      // Enable kerning\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n *\n * // Using the installed font\n * const text = new BitmapText({\n *     text: 'Hello World',\n *     style: {\n *         fontFamily: 'AdvancedFont',\n *         fontSize: 48\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontInstallOptions\n{\n    /**\n     * The name of the font. This will be used as the fontFamily in text styles to access this font.\n     * Must be unique across all installed bitmap fonts.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'MyCustomFont',\n     *     style: { fontFamily: 'Arial' }\n     * });\n     * ```\n     */\n    name?: string;\n\n    /**\n     * Characters included in the font set. You can specify individual characters or ranges.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     * @example\n     * ```ts\n     * // Different ways to specify characters\n     * BitmapFont.install({\n     *     name: 'RangeFont',\n     *     chars: [\n     *         ['a', 'z'],              // Range of characters\n     *         '0123456789',            // String of characters\n     *         [['0', '9'], ['A', 'Z']] // Multiple ranges\n     *     ]\n     * });\n     * ```\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs. Higher values create sharper text at the cost of memory.\n     * Useful for supporting high-DPI displays.\n     * @default 1\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'HiDPIFont',\n     *     resolution: window.devicePixelRatio || 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Balances visual quality with texture space.\n     * - Lower values: More compact, but may have visual artifacts\n     * - Higher values: Better quality, but uses more texture space\n     * @default 4\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'PaddedFont',\n     *     padding: 8 // More padding for better quality\n     * });\n     * ```\n     */\n    padding?: number;\n\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * - true: Faster generation, but text may have inconsistent spacing\n     * - false: Better text appearance, but slower generation\n     * @default false\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'FastFont',\n     *     skipKerning: true // Prioritize performance\n     * });\n     * ```\n     */\n    skipKerning?: boolean;\n\n    /**\n     * Style options to render the BitmapFont with.\n     * Supports all TextStyle properties including fill, stroke, and shadow effects.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'StyledFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: 'white',\n     *         stroke: { color: '#000000', width: 2 },\n     *         dropShadow: {\n     *             color: '#000000',\n     *             blur: 2,\n     *             distance: 3\n     *         }\n     *     }\n     * });\n     * ```\n     */\n    style?: TextStyle | TextStyleOptions;\n\n    /**\n     * Optional texture style to use when creating the font textures.\n     * Controls how the font textures are rendered and filtered.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'CrispFont',\n     *     textureStyle: {\n     *         scaleMode: 'nearest',\n     *     }\n     * });\n     * ```\n     */\n    textureStyle?: TextureStyle | TextureStyleOptions;\n\n    /**\n     * Whether to allow overriding the fill color with a tint at runtime.\n     *\n     * When enabled, the font can be dynamically tinted using the `tint` property of BitmapText,\n     * allowing a single font to display multiple colors without creating separate font textures.\n     * This is memory efficient but requires the font to be rendered with white fill color.\n     *\n     * When disabled, the fill color is permanently baked into the font texture. This allows\n     * any fill color but prevents runtime tinting - each color variation requires a separate font.\n     * @default false (automatically determined based on style)\n     *\n     * **Requirements for tinting:**\n     * - Fill color must be white (`0xFFFFFF` or `'#ffffff'`)\n     * - No stroke effects\n     * - No drop shadows (or only black shadows)\n     * - No gradient or pattern fills\n     *\n     * **Performance considerations:**\n     * -  Enabled: One font texture, multiple colors via tinting (memory efficient)\n     * -  Disabled: Separate font texture per color (higher memory usage)\n     * @example\n     * ```ts\n     * // Correct usage - white fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'TintableFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFFFFFF  // Must be white for tinting\n     *     },\n     *     dynamicFill: true\n     * });\n     *\n     * // Use the font with different colors via tinting\n     * const redText = new BitmapText({\n     *     text: 'Red Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'red }, // Red tint\n     * });\n     *\n     * const blueText = new BitmapText({\n     *     text: 'Blue Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'blue' }, // Blue tint\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Incorrect usage - colored fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'BadTintFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000  //  Red fill won't tint properly\n     *     },\n     *     dynamicFill: true  //  Will not work as expected\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Alternative - baked colors (no tinting)\n     * BitmapFont.install({\n     *     name: 'BakedColorFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000,  // Any color works\n     *         stroke: { color: 0x000000, width: 2 }  // Strokes allowed\n     *     },\n     *     dynamicFill: false  // Color is baked in\n     * });\n     * ```\n     */\n    dynamicFill?: boolean;\n}\n\n/** @advanced */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @type {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n        textureStyle: null,\n    };\n\n    /** Cache for measured text layouts to avoid recalculating them multiple times. */\n    public readonly measureCache = lru<BitmapTextLayoutData>(1000);\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            fontFamilyKey = `${style.styleKey}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const styleCopy = Object.create(style);\n            // Override the lineHeight, let the BitmapFont calculate the lineHeight\n            // from the fontMetrics instead using a custom lineHeight from BitmapText parameter\n\n            (styleCopy as any)._lineHeight = 0;\n\n            const fnt = new DynamicBitmapFont({\n                style: styleCopy,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        const id = `${text}-${style.styleKey}-${trimEnd}`;\n\n        // Check if we have a cached layout\n        if (this.measureCache.has(id))\n        {\n            return this.measureCache.get(id);\n        }\n\n        const segments = CanvasTextMetrics.graphemeSegmenter(text);\n\n        // Generate the layout data\n        const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);\n\n        this.measureCache.set(id, layoutData);\n\n        return layoutData;\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false,\n            textureStyle: options.textureStyle,\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n\n    /**\n     * Determines if a style can use tinting instead of baking colors into the bitmap.\n     * Tinting is more efficient as it allows reusing the same bitmap with different colors.\n     * @param style - The text style to evaluate\n     * @returns true if the style can use tinting, false if colors must be baked in\n     * @private\n     */\n    private _canUseTintForStyle(style: TextStyle): boolean\n    {\n        // Exclude strokes, non black shadows and ensure\n        // we have a non gradient or pattern fill,\n        // and the fill color is white\n        return !style._stroke\n            && (!style.dropShadow || style.dropShadow.color === 0x000000)\n            && !style._fill.fill\n            && style._fill.color === 0xFFFFFF;\n    }\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @category text\n * @advanced\n * @class\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nexport const BitmapFontManager = new BitmapFontManagerClass();\n", "import { groupD8 } from '../../maths/matrix/groupD8';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/utils/types';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont. Used when loading or creating bitmap fonts from existing textures and data.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     // Font data containing character metrics and layout info\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *             // ... other characters\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         // Optional distance field info for MSDF/SDF fonts\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     // Array of textures containing the font glyphs\n *     textures: [\n *         Texture.from('font.png')\n *     ]\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontOptions\n{\n    /**\n     * The bitmap font data containing character metrics, layout information,\n     * and font properties. This includes character positions, dimensions,\n     * kerning data, and general font settings.\n     */\n    data: BitmapFontData;\n\n    /**\n     * Array of textures containing the font glyphs. Each texture corresponds\n     * to a page in the font data. For simple fonts this is typically just\n     * one texture, but complex fonts may split glyphs across multiple textures.\n     */\n    textures: Texture[];\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * This class handles both pre-loaded bitmap fonts and dynamically generated ones.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     textures: [Texture.from('font.png')]\n * });\n *\n * // Install a font for global use\n * BitmapFont.install({\n *     name: 'MyCustomFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ffffff',\n *         stroke: { color: '#000000', width: 2 }\n *     }\n * });\n *\n * // Uninstall when no longer needed\n * BitmapFont.uninstall('MyCustomFont');\n * ```\n * @category text\n * @standard\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /**\n     * The URL from which the font was loaded, if applicable.\n     * This is useful for tracking font sources and reloading.\n     * @example\n     * ```ts\n     * console.log(font.url); // 'fonts/myFont.fnt'\n     * ```\n     */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const {\n                frame: textureFrame,\n                source: textureSource,\n                rotate: textureRotate,\n            } = textures[charData.page];\n\n            // Transform character coordinates based on texture rotation\n            const frame = groupD8.transformRectCoords(\n                charData,\n                textureFrame,\n                textureRotate,\n                new Rectangle()\n            );\n\n            const texture = new Texture({\n                frame,\n                orig: new Rectangle(0, 0, charData.width, charData.height),\n                source: textureSource,\n                rotate: textureRotate,\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates and installs a bitmap font with the specified options.\n     * The font will be cached and available for use in BitmapText objects.\n     * @param options - Setup options for font generation\n     * @returns Installed font instance\n     * @example\n     * ```ts\n     * // Install a basic font\n     * BitmapFont.install({\n     *     name: 'Title',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: '#ffffff'\n     *     }\n     * });\n     *\n     * // Install with advanced options\n     * BitmapFont.install({\n     *     name: 'Custom',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: '#00ff00',\n     *         stroke: { color: '#000000', width: 2 }\n     *     },\n     *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],\n     *     resolution: 2,\n     *     padding: 4,\n     *     textureStyle: {\n     *         scaleMode: 'nearest'\n     *     }\n     * });\n     * ```\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * This frees up memory and resources associated with the font.\n     * @param name - The name of the bitmap font to uninstall\n     * @example\n     * ```ts\n     * // Remove a font when it's no longer needed\n     * BitmapFont.uninstall('MyCustomFont');\n     *\n     * // Clear multiple fonts\n     * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);\n     * ```\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n"],
  "mappings": "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",
  "names": ["wordWrap", "contextSettings", "_CanvasTextMetrics", "wordWrap", "measurements", "isBreakingSpaceUtil", "_TextStyle", "_DynamicBitmapFont", "pageData", "i", "j"]
}
