{
  "version": 3,
  "sources": ["../../pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts", "../../pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts", "../../pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts", "../../pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts", "../../pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts", "../../pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts", "../../pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts", "../../pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts"],
  "sourcesContent": ["/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n", "/** @internal */\nexport const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\n/** @internal */\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n\n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n", "import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\n/** @internal */\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @category rendering\n * @advanced\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n", "// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\n/** @internal */\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n", "import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\n/**\n * @param uboElements\n * @param parserCode\n * @param arrayGenerationFunction\n * @param singleSettersMap\n * @internal\n */\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n", "import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\n/** @internal */\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\n/** @internal */\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @category rendering\n * @advanced\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n        this.removeAllListeners();\n    }\n}\n", "import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in any gaps. We do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of the time users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way,\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n * @internal\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n", "import { STENCIL_MODES } from '../../shared/state/const';\n\n/**\n * The stencil state for the GPU renderer.\n * This is used to define how the stencil buffer should be configured.\n * @category rendering\n * @advanced\n */\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\n/** @internal */\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n};\n"],
  "mappings": "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",
  "names": []
}
