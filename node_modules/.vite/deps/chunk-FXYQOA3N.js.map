{
  "version": 3,
  "sources": ["../../pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts", "../../pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts", "../../pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts", "../../pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/GpuLimitsSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts", "../../pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts", "../../pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts", "../../pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts", "../../pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts", "../../pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts", "../../pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCubeTextureResource.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts", "../../pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts"],
  "sourcesContent": ["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsContextSystem } from '../shared/GraphicsContextSystem';\nimport type { GraphicsAdaptor, GraphicsPipeLike } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    private _maxTextures = 0;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        this._maxTextures = renderer.limits.maxBatchableTextures;\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(this._maxTextures),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipeLike, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext as GraphicsContextSystem;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(\n                    textureBatch.textures,\n                    textureBatch.count,\n                    this._maxTextures\n                );\n\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @category rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer as WebGPURenderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @category rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = shader.gpuProgram;\n\n        this._shader = shader;\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry, program);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                textureBatch.textures,\n                textureBatch.count,\n                renderer.limits.maxBatchableTextures\n            );\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState,\n            batch.topology\n        );\n\n        batch.bindGroup._touch(renderer.gc.now, renderer.tick);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @category rendering\n * @advanced\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getTextureView(texture);\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        this._hash = null;\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { uid } from '../../../../utils/data/uid';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/** @internal */\nexport class GpuBufferData implements GPUData\n{\n    public gpuBuffer: GPUBuffer;\n\n    constructor(gpuBuffer: GPUBuffer)\n    {\n        this.gpuBuffer = gpuBuffer;\n    }\n\n    public destroy()\n    {\n        this.gpuBuffer.destroy();\n        this.gpuBuffer = null;\n    }\n}\n\n/**\n * System plugin to the renderer to manage buffers.\n * @category rendering\n * @advanced\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private readonly _renderer: WebGPURenderer;\n    private readonly _managedBuffers: GCManagedHash<Buffer>;\n\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._managedBuffers = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onBufferUnload.bind(this),\n            name: 'gpuBuffer'\n        });\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        buffer._gcLastUsed = this._renderer.gc.now;\n\n        return (buffer._gpuData[this._renderer.uid] as GpuBufferData)?.gpuBuffer || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this.getGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        this._managedBuffers.removeAll();\n    }\n\n    protected onBufferUnload(buffer: Buffer): void\n    {\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n        buffer._resourceId = uid('resource');\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(\n                buffer.data.buffer as ArrayBuffer,\n                gpuBuffer.getMappedRange(),\n                buffer.data.byteOffset,\n                buffer.data.byteLength\n            );\n\n            gpuBuffer.unmap();\n        }\n\n        buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);\n        if (this._managedBuffers.add(buffer))\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n        }\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        this._managedBuffers.remove(buffer);\n        buffer._updateID = 0;\n        this.createGPUBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.destroy();\n        (this._renderer as null) = null;\n        this._gpu = null;\n    }\n}\n\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GPU object.\n * Contains the GPU adapter and device.\n * @category rendering\n * @advanced\n */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @category rendering\n * @advanced\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     */\n    forceFallbackAdapter: boolean;\n    /** Using shared device and adaptor from other engine */\n    gpu?: GPU;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options))\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.gc.now, this._renderer.tick);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry, program: GpuProgram)\n    {\n        // when binding a buffers for geometry, there is no need to bind a buffer more than once if it is interleaved.\n        // which is often the case for Pixi. This is a performance optimisation.\n        // Instead of looping through the attributes, we instead call getBufferNamesToBind\n        // which returns a list of buffer names that need to be bound.\n        // we can then loop through this list and bind the buffers.\n        // essentially only binding a single time for any buffers that are interleaved.\n        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n\n        for (const i in buffersToBind)\n        {\n            this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry, shader.gpuProgram);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount ?? geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n            this._renderer.renderTarget.mipLevel,\n            this._renderer.renderTarget.layer,\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { type System } from '../shared/system/System';\nimport { type WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the WebGPU Device rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGPURenderer();\n * await renderer.init(); // GPU limits are populated after this call\n *\n * console.log(renderer.limits.maxTextures);\n * console.log(renderer.limits.maxBatchableTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GpuLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n        this.maxBatchableTextures = this.maxTextures;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n", "import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n", "import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n", "import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @category rendering\n * @advanced\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n", "/** @internal */\nexport class UboBatch\n{\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this.data = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n/** @internal */\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        this._bindGroupHash = Object.create(null);\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i]?.destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n\n        this._renderer = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\n// colorTargetCount = 4; // 2 bits // 4 states // value 0-3; // supports 1-4 color targets\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n    colorTargetCount: number,\n): number\n{\n    return (colorMask << 8) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 5) // Next 3 bits for stencilStateId\n         | (renderTarget << 3) // 2 bits for renderTarget\n         | (colorTargetCount << 1) // 2 bits for colorTargetCount\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @category rendering\n * @advanced\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _colorTargetCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n        this._colorTargetCount = renderTarget.colorTargetCount;\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology ||= geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);\n\n        // Apply write mask to all color targets\n        const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        for (let i = 0; i < blendModes.length; i++)\n        {\n            blendModes[i].writeMask = writeMask;\n        }\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            const attributes = Object.values(data[i].attributes);\n\n            const shaderLocation = attributes[0].shaderLocation;\n\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === shaderLocation)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment,\n            this._colorTargetCount,\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n", "import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public colorTargetCount: number;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n", "import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle,\n        mipLevel = 0,\n        layer = 0\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (layer !== 0 && gpuRenderTarget.msaaTextures?.length)\n        {\n            throw new Error('[RenderTargetSystem] Rendering to array layers is not supported with MSAA render targets.');\n        }\n\n        if (mipLevel > 0 && gpuRenderTarget.msaaTextures?.length)\n        {\n            throw new Error('[RenderTargetSystem] Rendering to mip levels is not supported with MSAA render targets.');\n        }\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor, mipLevel, layer);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray,\n        mipLevel = 0,\n        layer = 0\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    if (layer !== 0)\n                    {\n                        // eslint-disable-next-line max-len\n                        throw new Error('[RenderTargetSystem] Rendering to array layers is not supported for canvas targets.');\n                    }\n\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        // Render attachments must be 2d views; for array/cube textures we select a single layer.\n                        dimension: '2d',\n                        baseMipLevel: mipLevel,\n                        mipLevelCount: 1,\n                        baseArrayLayer: layer,\n                        arrayLayerCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView({\n                        dimension: '2d',\n                        baseMipLevel: mipLevel,\n                        mipLevelCount: 1,\n                        baseArrayLayer: layer,\n                        arrayLayerCount: 1,\n                    }),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle,\n        mipLevel = 0,\n        layer = 0\n    )\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor, mipLevel, layer);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport, mipLevel, layer);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always true for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (colorTexture instanceof CanvasSource)\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                    arrayLayerCount: colorTexture.source.arrayLayerCount,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\n/**\n * Data structure for GPU program layout.\n * Contains bind group layouts and pipeline layout.\n * @category rendering\n * @advanced\n */\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @category rendering\n * @advanced\n */\nexport class GpuShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n", "import type { BLEND_MODES } from '../../shared/state/const';\n\n/** @internal */\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.min = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n};\n\nGpuBlendModesToPixi.max = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @category rendering\n * @advanced\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     * @param count - The number of color targets to create\n     */\n    public getColorTargets(state: State, count: number): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        const targets: GPUColorTargetState[] = [];\n        const target = {\n            format: 'bgra8unorm',\n            writeMask: 0,\n            blend,\n        } as GPUColorTargetState;\n\n        for (let i = 0; i < count; i++)\n        {\n            targets[i] = target;\n        }\n\n        return targets;\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n", "import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU, originZOverride = 0)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture, origin: { x: 0, y: 0, z: originZOverride } },\n            resource as ArrayBuffer,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelWidth * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n", "import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n/** @internal */\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU, originZOverride = 0)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i,\n                    origin: { x: 0, y: 0, z: originZOverride },\n                },\n                levelBuffer as BufferSource,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n", "import type { CubeTextureSource } from '../../../shared/texture/sources/CubeTextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nconst FACE_ORDER: (keyof CubeTextureSource['faces'])[] = ['right', 'left', 'top', 'bottom', 'front', 'back'];\n\n/**\n * Creates a cube uploader that delegates to the given uploader registry.\n * @param uploaders - Uploader registry keyed by `uploadMethodId` (must include `image`).\n * @internal\n */\nexport function createGpuUploadCubeTextureResource(\n    uploaders: Record<string, GpuTextureUploader> & { image: GpuTextureUploader }\n): GpuTextureUploader<CubeTextureSource>\n{\n    return {\n        type: 'cube',\n        upload(source: CubeTextureSource, gpuTexture: GPUTexture, gpu: GPU)\n        {\n            const faces = source.faces;\n\n            for (let i = 0; i < FACE_ORDER.length; i++)\n            {\n                const key = FACE_ORDER[i];\n                const face = faces[key];\n\n                const uploader = uploaders[face.uploadMethodId] || uploaders.image;\n\n                uploader.upload(face as any, gpuTexture, gpu, i);\n            }\n        }\n    };\n}\n\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { warn } from '../../../../../utils/logging/warn';\n\nimport type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU, originZOverride = 0)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas | HTMLImageElement;\n\n        if (!resource) return;\n\n        // WebGPU does not support HTMLImageElement\n        // so we need to convert it to a canvas\n        if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        {\n            const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(resource, 0, 0, resource.width, resource.height);\n\n            // replace with the canvas - for future uploads\n            source.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas and replacing resource.');\n            // #endif\n        }\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, origin: { x: 0, y: 0, z: originZOverride }, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n", "import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU, originZOverride?: number)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu, originZOverride);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n", "/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @category rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { createGpuUploadCubeTextureResource } from './uploaders/gpuUploadCubeTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * Stores GPU-specific data for a Texture instance in WebGL context.\n * @internal\n */\nexport class GPUTextureGpuData implements GPUData\n{\n    public gpuTexture: GPUTexture;\n    public textureView: GPUTextureView = null;\n\n    constructor(gpuTexture: GPUTexture)\n    {\n        this.gpuTexture = gpuTexture;\n    }\n\n    /** Destroys this GPU data instance. */\n    public destroy(): void\n    {\n        this.gpuTexture.destroy();\n        this.textureView = null;\n        this.gpuTexture = null;\n    }\n}\n\n/**\n * The system that handles textures for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader>;\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n    private readonly _managedTextures: GCManagedHash<TextureSource>;\n    /**\n     * @deprecated since 8.15.0\n     */\n    public get managedTextures(): Readonly<TextureSource[]> { return Object.values(this._managedTextures.items); }\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        renderer.gc.addCollection(this, '_bindGroupHash', 'hash');\n\n        this._managedTextures = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onSourceUnload.bind(this),\n            name: 'gpuTextureSource'\n        });\n\n        const baseUploaders = {\n            image: gpuUploadImageResource,\n            buffer: gpuUploadBufferImageResource,\n            video: gpuUploadVideoResource,\n            compressed: gpuUploadCompressedTextureResource,\n        };\n\n        this._uploads = {\n            ...baseUploaders,\n            cube: createGpuUploadCubeTextureResource(baseUploaders),\n        };\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource): GPUTexture\n    {\n        return (source._gpuData[this._renderer.uid] as GPUTextureGpuData)?.gpuTexture || this._initSource(source);\n    }\n\n    private _initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height, depthOrArrayLayers: source.arrayLayerCount },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n\n        source._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);\n\n        const added = this._managedTextures.add(source);\n\n        if (added)\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        source._gcLastUsed = this._renderer.gc.now;\n\n        const gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        const gpuTexture = gpuData?.gpuTexture;\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            gpuData.destroy();\n            this._bindGroupHash[source.uid] = null;\n            source._gpuData[this._renderer.uid] = null;\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        source._gcLastUsed = this._renderer.gc.now;\n\n        return (source._gpuData[this._renderer.uid] as GPUTextureGpuData)?.gpuTexture || this.initSource(source);\n    }\n\n    /**\n     * this returns s bind group for a specific texture, the bind group contains\n     * - the texture source\n     * - the texture style\n     * - the texture matrix\n     * This is cached so the bind group should only be created once per texture\n     * @param texture - the texture you want the bindgroup for\n     * @returns the bind group for the texture\n     */\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: Texture)\n    {\n        const source = texture.source;\n\n        this._bindGroupHash[texture.uid] = new BindGroup({\n            0: source,\n            1: source.style,\n            2: new UniformGroup({\n                uTextureMatrix: { type: 'mat3x3<f32>', value: texture.textureMatrix.mapCoord },\n            })\n        });\n\n        return this._bindGroupHash[texture.uid];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        source._gcLastUsed = this._renderer.gc.now;\n        let gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n\n        if (!gpuData)\n        {\n            this.initSource(source);\n            gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        }\n\n        gpuData.textureView ||= gpuData.gpuTexture.createView({ dimension: source.viewDimension });\n\n        return gpuData.textureView;\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        this._managedTextures.destroy();\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n        }\n\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSamplers = null;\n        this._bindGroupHash = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuLimitsSystem } from './GpuLimitsSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuLimitsSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\n/**\n * The WebGPU renderer pipes. These are used to render the scene.\n * @see {@link WebGPURenderer}\n * @internal\n */\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @standard\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBO,IAAM,qBAAN,MACP;EADO,cAAA;AAYH,SAAQ,eAAe;EAAA;EAEhB,cAAc,UACrB;AACI,UAAM,gBAAgB,IAAI,aAAa;MACnC,kBAAkB,EAAE,OAAO,IAAI,OAAA,GAAU,MAAM,cAAA;MAC/C,QAAQ,EAAE,OAAO,IAAI,aAAa,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,MAAM,YAAA;MACvD,QAAQ,EAAE,OAAO,GAAG,MAAM,MAAA;IAAM,CACnC;AAED,SAAK,eAAe,SAAS,OAAO;AAEpC,UAAM,aAAa,4BAA4B;MAC3C,MAAM;MACN,MAAM;QACF;QACA,wBAAwB,KAAK,YAAY;QAEzC;QACA;MAAA;IACJ,CACH;AAED,SAAK,SAAS,IAAI,OAAO;MACrB;MACA,WAAW;;QAEP;MAAA;IACJ,CACH;EACL;EAEO,QAAQ,cAAgC,YAC/C;AACI,UAAM,UAAU,WAAW;AAC3B,UAAM,SAAS,QAAQ,gBAAgB,KAAK;AAC5C,UAAM,WAAW,aAAa;AAC9B,UAAM,gBAAgB,SAAS;AAE/B,UAAM;MACF;MAAS;IAAA,IACT,cAAc,qBAAqB,OAAO;AAK9C,UAAM,UAAU,SAAS;AAEzB,YAAQ,YAAY,QAAQ,UAAU,OAAO,UAAU;AAEvD,UAAM,0BAA0B,SAAS,eAAe;AAExD,YAAQ,aAAa,GAAG,yBAAyB,OAAO,UAAU;AAElE,UAAM,iBAAkB,SACnB,YAAY,aAAa,oBAAoB,OAAO,UAAU,eAAe,IAAI;AAEtF,YAAQ,aAAa,GAAG,gBAAgB,OAAO,UAAU;AAEzD,UAAM,UAAU,aAAa;AAE7B,QAAI,WAAqB;AAEzB,aAAS,IAAI,GAAG,IAAI,aAAa,iBAAiB,KAClD;AACI,YAAM,QAAQ,QAAQ,CAAC;AAEvB,UAAI,MAAM,aAAa,UACvB;AACI,mBAAW,MAAM;AAEjB,gBAAQ;UACJ,QAAQ;UACR,OAAO;UACP,aAAa;UACb,MAAM;QAAA;MAEd;AAEA,aAAO,OAAO,CAAC,IAAI,MAAM;AAEzB,UAAI,CAAC,MAAM,cACX;AACI,cAAM,eAAe,MAAM;AAE3B,cAAM,YAAY;UACd,aAAa;UACb,aAAa;UACb,KAAK;QAAA;AAGT,cAAM,eAAe,SAAS,UAAU;UACpC,MAAM;UAAW,OAAO;UAAY;QAAA;MAE5C;AAEA,cAAQ,aAAa,GAAG,MAAM,WAAW,OAAO,UAAU;AAE1D,cAAQ,kBAAkB,YAAY,MAAM,MAAM,GAAG,MAAM,KAAK;IACpE;EACJ;EAEO,UACP;AACI,SAAK,OAAO,QAAQ,IAAI;AACxB,SAAK,SAAS;EAClB;AACJ;AAvHa,mBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;ACdG,IAAM,iBAAN,MACP;EAWW,OACP;AACI,UAAM,aAAa,4BAA4B;MAC3C,MAAM;MACN,MAAM;QACF;QACA;QACA;MAAA;IACJ,CACH;AAED,SAAK,UAAU,IAAI,OAAO;MACtB;MACA,WAAW;QACP,UAAU,QAAQ,MAAM;QACxB,UAAU,QAAQ,MAAM,QAAQ;QAChC,iBAAiB;UACb,gBAAgB,EAAE,MAAM,eAAe,OAAO,IAAI,OAAA,EAAO;QAAE;MAC/D;IACJ,CACH;EACL;EAEO,QAAQ,UAAoB,MACnC;AACI,UAAM,WAAW,SAAS;AAE1B,QAAI,SAAiB,KAAK;AAE1B,QAAI,CAAC,QACL;AACI,eAAS,KAAK;AAEd,aAAO,OAAO,CAAC,IAAI,SAAS,QAAQ,oBAAoB,KAAK,OAAO;IACxE,WACS,CAAC,OAAO,YACjB;AAEI,WAAK,iCAAiC,KAAK,MAAM;AAGjD;IACJ;AAEA,UAAM,aAAa,OAAO;AAG1B,QAAI,WAAW,0BACf;AACI,aAAO,OAAO,CAAC,IAAI,SAAS,eAAe;IAC/C;AAEA,QAAI,WAAW,yBACf;AACI,YAAM,gBAAgB,SAAS;AAE/B,aAAO,OAAO,CAAC,IAAK,SACf,YAAY,aAAa,oBAAoB,eAAe,IAAI;IACzE;AAEA,aAAS,QAAQ,KAAK;MAClB,UAAU,KAAK;MACf;MACA,OAAO,KAAK;IAAA,CACf;EACL;EAEO,UACP;AACI,SAAK,QAAQ,QAAQ,IAAI;AACzB,SAAK,UAAU;EACnB;AACJ;AApFa,eAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;AChBJ,IAAM,YAAY,MAAM,MAAA;AAOjB,IAAM,kBAAN,MACP;EAYW,MAAM,WAAwB,UAAoB,QACzD;AACI,UAAM,WAAW,UAAU;AAC3B,UAAM,UAAU,SAAS;AACzB,UAAM,UAAU,OAAO;AAEvB,SAAK,UAAU;AACf,SAAK,YAAY;AAEjB,YAAQ,YAAY,UAAU,OAAO;AAErC,cAAU,YAAY;AAGtB,aAAS,SAAS;MACd;MACA;MACA;IAAA;AAGJ,UAAM,0BAA0B,SAAS,eAAe;AAOxD,YAAQ,eAAe,CAAC;AAExB,YAAQ,aAAa,GAAG,yBAAyB,OAAO;EAC5D;EAEO,QAAQ,WAAwB,OACvC;AACI,UAAM,UAAU,KAAK,QAAQ;AAC7B,UAAM,WAAW,UAAU;AAC3B,UAAM,UAAU,SAAS;AAEzB,QAAI,CAAC,MAAM,WACX;AACI,YAAM,eAAe,MAAM;AAE3B,YAAM,YAAY;QACd,aAAa;QACb,aAAa;QACb,SAAS,OAAO;MAAA;IAExB;AAEA,cAAU,YAAY,MAAM;AAE5B,UAAM,eAAe,SAAS,UAAU;MACpC,MAAM;MAAW;MAAS;IAAA;AAG9B,UAAM,WAAW,SAAS,SAAS;MAC/B,KAAK;MACL;MACA;MACA,MAAM;IAAA;AAGV,UAAM,UAAU,OAAO,SAAS,GAAG,KAAK,SAAS,IAAI;AAErD,YAAQ,YAAY,QAAQ;AAE5B,YAAQ,kBAAkB,aAAa,GAAG,YAAY;AACtD,YAAQ,kBAAkB,YAAY,MAAM,MAAM,GAAG,MAAM,KAAK;EACpE;AACJ;AAlFa,gBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;ACPG,IAAM,kBAAN,MACP;EAcI,YAAY,UACZ;AAJA,SAAQ,QAAsC,uBAAO,OAAO,IAAI;AAK5D,SAAK,YAAY;EACrB;EAEU,cAAc,KACxB;AACI,SAAK,OAAO;EAChB;EAEO,aAAa,WAAsB,SAAqB,YAC/D;AACI,cAAU,WAAA;AAEV,UAAM,eAAe,KAAK,MAAM,UAAU,IAAI,KAAK,KAAK,iBAAiB,WAAW,SAAS,UAAU;AAEvG,WAAO;EACX;EAEQ,iBAAiB,OAAkB,SAAqB,YAChE;AACI,UAAM,SAAS,KAAK,KAAK;AACzB,UAAM,cAAc,QAAQ,OAAO,UAAU;AAC7C,UAAM,UAA+B,CAAA;AACrC,UAAM,WAAW,KAAK;AAEtB,eAAW,KAAK,aAChB;AACI,YAAM,WAAyB,MAAM,UAAU,CAAC,KAAK,MAAM,UAAU,YAAY,CAAC,CAAC;AACnF,UAAI;AAGJ,UAAI,SAAS,kBAAkB,gBAC/B;AACI,cAAM,eAAe;AAErB,iBAAS,IAAI,mBAAmB,YAA4B;AAE5D,cAAM,SAAS,aAAa;AAE5B,sBAAc;UACV,QAAQ,SAAS,OAAO,aAAa,MAAM;UAC3C,QAAQ;UACR,MAAM,OAAO,WAAW;QAAA;MAEhC,WACS,SAAS,kBAAkB,UACpC;AACI,cAAM,SAAS;AAEf,sBAAc;UACV,QAAQ,SAAS,OAAO,aAAa,MAAM;UAC3C,QAAQ;UACR,MAAM,OAAO,WAAW;QAAA;MAEhC,WACS,SAAS,kBAAkB,kBACpC;AACI,cAAM,iBAAiB;AAEvB,sBAAc;UACV,QAAQ,SAAS,OAAO,aAAa,eAAe,MAAM;UAC1D,QAAQ,eAAe;UACvB,MAAM,eAAe;QAAA;MAE7B,WACS,SAAS,kBAAkB,kBACpC;AACI,cAAM,UAAU;AAEhB,sBAAc,SAAS,QAAQ,cAAc,OAAO;MACxD,WACS,SAAS,kBAAkB,iBACpC;AACI,cAAM,UAAU;AAEhB,sBAAc,SAAS,QAAQ,eAAe,OAAO;MACzD;AAEA,cAAQ,KAAK;QACT,SAAS,YAAY,CAAC;QACtB,UAAU;MAAA,CACb;IACL;AAEA,UAAM,SAAS,SAAS,OAAO,eAAe,OAAO,EAAE,WAAW,UAAU;AAE5E,UAAM,eAAe,OAAO,gBAAgB;MACxC;MACA;IAAA,CACH;AAED,SAAK,MAAM,MAAM,IAAI,IAAI;AAEzB,WAAO;EACX;EAEO,UACP;AACI,SAAK,QAAQ;AACZ,SAAK,YAAqB;EAC/B;AACJ;AArHa,gBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;ACfG,IAAM,gBAAN,MACP;EAGI,YAAY,WACZ;AACI,SAAK,YAAY;EACrB;EAEO,UACP;AACI,SAAK,UAAU,QAAA;AACf,SAAK,YAAY;EACrB;AACJ;AAOO,IAAM,kBAAN,MACP;EAeI,YAAY,UACZ;AACI,SAAK,YAAY;AACjB,SAAK,kBAAkB,IAAI,cAAc;MACrC;MACA,MAAM;MACN,UAAU,KAAK,eAAe,KAAK,IAAI;MACvC,MAAM;IAAA,CACT;EACL;EAEU,cAAc,KACxB;AACI,SAAK,OAAO;EAChB;EAEO,aAAa,QACpB;;AACI,WAAO,cAAc,KAAK,UAAU,GAAG;AAEvC,aAAQ,YAAO,SAAS,KAAK,UAAU,GAAG,MAAlC,mBAAuD,cAAa,KAAK,gBAAgB,MAAM;EAC3G;EAEO,aAAa,QACpB;AACI,UAAM,YAAY,KAAK,aAAa,MAAM;AAE1C,UAAM,OAAO,OAAO;AAGpB,QAAI,OAAO,aAAa,MACxB;AACI,aAAO,YAAY;AAGnB,WAAK,KAAK,OAAO,MAAM;QACnB;QAAW;QAAG,KAAK;QAAQ;;SAEzB,OAAO,eAAe,KAAK,cAAc,IAAK,CAAC;MAAA;IAEzD;AAEA,WAAO;EACX;;EAGO,aACP;AACI,SAAK,gBAAgB,UAAA;EACzB;EAEU,eAAe,QACzB;AACI,WAAO,IAAI,UAAU,KAAK,cAAc,IAAI;AAC5C,WAAO,IAAI,UAAU,KAAK,gBAAgB,IAAI;EAClD;EAEO,gBAAgB,QACvB;AACI,UAAM,YAAY,KAAK,KAAK,OAAO,aAAa,OAAO,UAAU;AAEjE,WAAO,YAAY;AACnB,WAAO,cAAc,IAAI,UAAU;AAEnC,QAAI,OAAO,MACX;AAEI;QACI,OAAO,KAAK;QACZ,UAAU,eAAA;QACV,OAAO,KAAK;QACZ,OAAO,KAAK;MAAA;AAGhB,gBAAU,MAAA;IACd;AAEA,WAAO,SAAS,KAAK,UAAU,GAAG,IAAI,IAAI,cAAc,SAAS;AACjE,QAAI,KAAK,gBAAgB,IAAI,MAAM,GACnC;AACI,aAAO,GAAG,UAAU,KAAK,cAAc,IAAI;AAC3C,aAAO,GAAG,UAAU,KAAK,gBAAgB,IAAI;IACjD;AAEA,WAAO;EACX;EAEU,eAAe,QACzB;AACI,SAAK,gBAAgB,OAAO,MAAM;AAClC,WAAO,YAAY;AACnB,SAAK,gBAAgB,MAAM;EAC/B;EAEO,UACP;AACI,SAAK,gBAAgB,QAAA;AACpB,SAAK,YAAqB;AAC3B,SAAK,OAAO;EAChB;AACJ;AApHa,gBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;AC/BG,IAAM,qBAAN,MACP;EAaI,YAAY,UACZ;AAHA,SAAQ,kBAAkB;AAItB,SAAK,YAAY;EACrB;EAEO,QAAQ,WACf;AACI,QAAI,KAAK,oBAAoB,UAAW;AACxC,SAAK,kBAAkB;AAEvB,SAAK,UAAU,SAAS,aAAa,SAAS;EAClD;EAEO,UACP;AACK,SAAK,YAAqB;AAC3B,SAAK,kBAAkB;EAC3B;AACJ;AAhCa,mBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;ACsCG,IAAM,kBAAN,MACP;;;;EAgCI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EAEA,MAAa,KAAK,SAClB;AACI,QAAI,KAAK,aAAc,QAAO,KAAK;AAEnC,SAAK,gBAAgB,QAAQ,MAAM,QAAQ,QAAQ,QAAQ,GAAG,IAAI,KAAK,wBAAwB,OAAO,GACjG,KAAK,CAAC,QACP;AACI,WAAK,MAAM;AAEX,WAAK,UAAU,QAAQ,cAAc,KAAK,KAAK,GAAG;IACtD,CAAC;AAEL,WAAO,KAAK;EAChB;;;;;EAMU,cAAc,KACxB;AACI,SAAK,UAAU,MAAM;EACzB;;;;;;;;EASA,MAAc,wBAAwB,SACtC;AAEI,UAAM,UAAU,MAAM,WAAW,IAAA,EAAM,aAAA,EAAe,IAAI,eAAe;MACrE,iBAAiB,QAAQ;MACzB,sBAAsB,QAAQ;IAAA,CACjC;AAED,UAAM,mBAAmB;MACrB;MACA;MACA;IAAA,EACF,OAAO,CAAC,YAAY,QAAQ,SAAS,IAAI,OAAO,CAAC;AAGnD,UAAM,SAAS,MAAM,QAAQ,cAAc;MACvC;IAAA,CACH;AAED,WAAO,EAAE,SAAS,OAAA;EACtB;EAEO,UACP;AACI,SAAK,MAAM;AACX,SAAK,YAAY;EACrB;AACJ;AAhGa,gBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;AARS,gBAWK,iBAAoC;;;;;EAK9C,iBAAiB;;;;;EAKjB,sBAAsB;AAC1B;;;ACxDG,IAAM,mBAAN,MACP;EAsBI,YAAY,UACZ;AARA,SAAQ,kBAA6C,uBAAO,OAAO,IAAI;AACvE,SAAQ,qBAA6C,uBAAO,OAAO,IAAI;AAQnE,SAAK,YAAY;EACrB;EAEO,cACP;AACI,SAAK,kBAAkB,IAAI,QAAQ,CAAC,YACpC;AACI,WAAK,0BAA0B;IACnC,CAAC;AAID,SAAK,iBAAiB,KAAK,UAAU,IAAI,OAAO,qBAAA;EACpD;EAEO,gBAAgB,iBACvB;AACI,SAAK,cAAA;AAEL,SAAK,YAAA;AAEL,SAAK,oBAAoB,KAAK,eAAe,gBAAgB,gBAAgB,UAAU;EAC3F;EAEO,gBACP;AACI,QAAI,KAAK,mBACT;AACI,WAAK,kBAAkB,IAAA;IAC3B;AAEA,SAAK,oBAAoB;EAC7B;EAEO,YAAY,UACnB;AACI,SAAK,kBAAkB,YAAY,SAAS,GAAG,SAAS,GAAG,SAAS,OAAO,SAAS,QAAQ,GAAG,CAAC;EACpG;EAEO,uCACH,UACA,SACA,OACA,UAEJ;AACI,UAAM,WAAW,KAAK,UAAU,SAAS,YAAY,UAAU,SAAS,OAAO,QAAQ;AAEvF,SAAK,YAAY,QAAQ;EAC7B;EAEO,YAAY,UACnB;AACI,QAAI,KAAK,mBAAmB,SAAU;AACtC,SAAK,iBAAiB;AAEtB,SAAK,kBAAkB,YAAY,QAAQ;EAC/C;EAEQ,iBAAiB,OAAe,QACxC;AACI,QAAI,KAAK,mBAAmB,KAAK,MAAM,OAAQ;AAE/C,SAAK,mBAAmB,KAAK,IAAI;AAEjC,SAAK,kBAAkB,gBAAgB,OAAO,KAAK,UAAU,OAAO,aAAa,MAAM,CAAC;EAC5F;EAEQ,gBAAgB,QACxB;AACI,QAAI,KAAK,sBAAsB,OAAQ;AAEvC,SAAK,oBAAoB;AAEzB,UAAM,cAAc,OAAO,KAAK,sBAAsB,IAAI,WAAW;AAErE,SAAK,kBAAkB,eAAe,KAAK,UAAU,OAAO,aAAa,MAAM,GAAG,WAAW;EACjG;EAEO,eAAe,OACtB;AACI,SAAK,gBAAgB,KAAK,IAAI;EAClC;EAEO,aAAa,OAAe,WAAsB,SACzD;AACI,QAAI,KAAK,gBAAgB,KAAK,MAAM,UAAW;AAC/C,SAAK,gBAAgB,KAAK,IAAI;AAE9B,cAAU,OAAO,KAAK,UAAU,GAAG,KAAK,KAAK,UAAU,IAAI;AAI3D,UAAM,eAAe,KAAK,UAAU,UAAU,aAAa,WAAW,SAAS,KAAK;AAGpF,SAAK,kBAAkB,aAAa,OAAO,YAAY;EAC3D;EAEO,YAAY,UAAoB,SACvC;AAOI,UAAM,gBAAgB,KAAK,UAAU,SAAS,qBAAqB,UAAU,OAAO;AAEpF,eAAW,KAAK,eAChB;AACI,WAAK,iBAAiB,SAAS,GAAG,EAAE,GAAG,SAAS,WAAW,cAAc,CAAC,CAAC,EAAE,MAAM;IACvF;AAEA,QAAI,SAAS,aACb;AACI,WAAK,gBAAgB,SAAS,WAAW;IAC7C;EACJ;EAEQ,qBAAqB,QAAgB,UAC7C;AACI,eAAW,KAAK,OAAO,QACvB;AACI,YAAM,YAAY,OAAO,OAAO,CAAC;AAGjC,UAAI,CAAC,UACL;AACI,aAAK,eAAe,SAAS;MACjC;AAEA,WAAK,aAAa,GAAwB,WAAW,OAAO,UAAU;IAC1E;EACJ;EAEQ,eAAe,WACvB;AACI,eAAW,KAAK,UAAU,WAC1B;AACI,YAAM,WAAW,UAAU,UAAU,CAAC;AAEtC,UAAK,SAA0B,gBAC/B;AACI,aAAK,UAAU,IAAI,mBAAmB,QAAwB;MAClE;IACJ;EACJ;EAEO,KAAK,SAUZ;AACI,UAAM,EAAE,UAAU,QAAQ,OAAO,UAAU,MAAM,OAAO,eAAe,SAAA,IAAa;AAEpF,SAAK,uCAAuC,UAAU,OAAO,YAAY,OAAO,QAAQ;AACxF,SAAK,YAAY,UAAU,OAAO,UAAU;AAC5C,SAAK,qBAAqB,QAAQ,QAAQ;AAE1C,QAAI,SAAS,aACb;AACI,WAAK,kBAAkB;QACnB,QAAQ,SAAS,YAAY,KAAK;QAClC,iBAAiB,SAAS;QAC1B,SAAS;MAAA;IAEjB,OAEA;AACI,WAAK,kBAAkB,KAAK,QAAQ,SAAS,QAAA,GAAW,iBAAiB,SAAS,eAAe,SAAS,CAAC;IAC/G;EACJ;EAEO,mBACP;AACI,QAAI,KAAK,mBACT;AACI,WAAK,kBAAkB,IAAA;AACvB,WAAK,oBAAoB;IAC7B;EACJ;EAEO,aACP;AACI,SAAK,iBAAA;AAEL,SAAK,KAAK,OAAO,MAAM,OAAO,CAAC,KAAK,eAAe,OAAA,CAAQ,CAAC;AAE5D,SAAK,wBAAA;AAEL,SAAK,iBAAiB;EAC1B;;;;EAKO,oBACP;AACI,UAAM,aAAc,KAAK,UAAU,aAAa,QAAmC;MAC/E,KAAK,UAAU,aAAa;MAC5B;MACA,CAAC,GAAG,GAAG,GAAG,CAAC;MACX,KAAK,UAAU,aAAa;MAC5B,KAAK,UAAU,aAAa;IAAA;AAGhC,SAAK,oBAAoB,KAAK,eAAe,gBAAgB,UAAU;AAEvE,UAAM,gBAAgB,KAAK;AAC3B,UAAM,oBAAoB,EAAE,GAAG,KAAK,mBAAA;AACpC,UAAM,mBAAmB,KAAK;AAC9B,UAAM,iBAAiB,EAAE,GAAG,KAAK,gBAAA;AAEjC,SAAK,YAAA;AAEL,UAAM,WAAW,KAAK,UAAU,aAAa;AAE7C,SAAK,kBAAkB,YAAY,SAAS,GAAG,SAAS,GAAG,SAAS,OAAO,SAAS,QAAQ,GAAG,CAAC;AAIhG,SAAK,YAAY,aAAa;AAE9B,eAAW,KAAK,mBAChB;AACI,WAAK,iBAAiB,GAAwB,kBAAkB,CAAC,CAAC;IACtE;AAEA,eAAW,KAAK,gBAChB;AACI,WAAK,aAAa,GAAwB,eAAe,CAAC,GAAG,IAAI;IACrE;AAEA,SAAK,gBAAgB,gBAAgB;EACzC;EAEQ,cACR;AACI,aAAS,IAAI,GAAG,IAAI,IAAI,KACxB;AACI,WAAK,gBAAgB,CAAC,IAAI;AAC1B,WAAK,mBAAmB,CAAC,IAAI;IACjC;AAEA,SAAK,oBAAoB;AACzB,SAAK,iBAAiB;EAC1B;EAEO,UACP;AACK,SAAK,YAAqB;AAC3B,SAAK,OAAO;AACZ,SAAK,kBAAkB;AACvB,SAAK,qBAAqB;AAC1B,SAAK,oBAAoB;AACzB,SAAK,iBAAiB;EAC1B;EAEU,cAAc,KACxB;AACI,SAAK,OAAO;EAChB;AACJ;AAtSa,iBAGK,YAAY;EACtB,MAAM,CAAC,cAAc,YAAY;EACjC,MAAM;EACN,UAAU;AACd;;;ACDG,IAAM,kBAAN,MACP;EAgBI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EAEO,gBACP;AACI,SAAK,cAAc,KAAK,UAAU,OAAO,IAAI,OAAO,OAAO;AAC3D,SAAK,uBAAuB,KAAK;EACrC;EAEO,UACP;EAEA;AACJ;AAhCa,gBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;ACxBG,IAAM,mBAAN,MACP;EAkBI,YAAY,UACZ;AARA,SAAQ,4BAGH,uBAAO,OAAO,IAAI;AAMnB,SAAK,YAAY;AAEjB,aAAS,aAAa,qBAAqB,IAAI,IAAI;EACvD;EAEU,qBAAqB,cAC/B;AACI,QAAI,eAAe,KAAK,0BAA0B,aAAa,GAAG;AAElE,QAAI,CAAC,cACL;AACI,qBAAe,KAAK,0BAA0B,aAAa,GAAG,IAAI;QAC9D,aAAa,cAAc;QAC3B,kBAAkB;MAAA;IAE1B;AAEA,SAAK,sBAAsB;AAE3B,SAAK,eAAe,aAAa,aAAa,aAAa,gBAAgB;EAC/E;EAEO,eAAe,aAA4B,kBAClD;AACI,UAAM,eAAe,KAAK,0BAA0B,KAAK,oBAAoB,GAAG;AAEhF,iBAAa,cAAc;AAC3B,iBAAa,mBAAmB;AAEhC,UAAM,WAAW,KAAK;AAEtB,aAAS,SAAS,eAAe,WAAW;AAC5C,aAAS,QAAQ,kBAAkB,oBAAoB,gBAAgB;EAC3E;EAEO,UACP;AACI,SAAK,UAAU,aAAa,qBAAqB,OAAO,IAAI;AAE3D,SAAK,YAAqB;AAE3B,SAAK,sBAAsB;AAC3B,SAAK,4BAA4B;EACrC;AACJ;AAjEa,iBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;ACjBG,IAAM,uBAAsF;EAC/F,KAAK,EAAE,OAAO,GAAG,MAAM,EAAA;EACvB,KAAK,EAAE,OAAO,GAAG,MAAM,EAAA;EACvB,KAAK,EAAE,OAAO,GAAG,MAAM,EAAA;EACvB,KAAK,EAAE,OAAO,GAAG,MAAM,EAAA;EACvB,aAAa,EAAE,OAAO,GAAG,MAAM,EAAA;EAC/B,aAAa,EAAE,OAAO,GAAG,MAAM,EAAA;EAC/B,aAAa,EAAE,OAAO,GAAG,MAAM,EAAA;EAC/B,aAAa,EAAE,OAAO,GAAG,MAAM,EAAA;EAC/B,aAAa,EAAE,OAAO,IAAI,MAAM,GAAA;EAChC,aAAa,EAAE,OAAO,IAAI,MAAM,GAAA;EAChC,aAAa,EAAE,OAAO,IAAI,MAAM,GAAA;EAChC,aAAa,EAAE,OAAO,GAAG,MAAM,EAAA;EAC/B,aAAa,EAAE,OAAO,IAAI,MAAM,GAAA;EAChC,aAAa,EAAE,OAAO,IAAI,MAAM,GAAA;EAChC,aAAa,EAAE,OAAO,IAAI,MAAM,GAAA;EAChC,aAAa,EAAE,OAAO,GAAG,MAAM,EAAA;EAC/B,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,GAAG,MAAM,EAAA;EACjC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,IAAI,MAAM,GAAA;EAClC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,IAAI,MAAM,GAAA;EAClC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,IAAI,MAAM,GAAA;EAClC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,IAAI,MAAM,GAAA;EAClC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,IAAI,MAAM,GAAA;EAClC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;EACjC,eAAe,EAAE,OAAO,IAAI,MAAM,GAAA;EAClC,eAAe,EAAE,OAAO,GAAG,MAAM,GAAA;AACrC;AAMO,SAAS,sBAAsB,aACtC;AACI,QAAM,cAA4B,YAAY,IAAI,CAAC,UAC9C;IACG;IACA,QAAQ;IACR,MAAM;EAAA,EACR;AAEN,MAAI,SAAS;AAEb,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KACxC;AACI,UAAM,aAAa,YAAY,CAAC;AAEhC,QAAI,OAAO,qBAAqB,WAAW,KAAK,IAAI,EAAE;AACtD,UAAM,QAAQ,qBAAqB,WAAW,KAAK,IAAI,EAAE;AAEzD,QAAI,CAAC,qBAAqB,WAAW,KAAK,IAAI,GAC9C;AACI,YAAM,IAAI,MAAM,gDAAgD,WAAW,KAAK,IAAI,EAAE;IAC1F;AAEA,QAAI,WAAW,KAAK,OAAO,GAC3B;AACI,aAAO,KAAK,IAAI,MAAM,KAAK,IAAI,WAAW,KAAK;IACnD;AAEA,aAAS,KAAK,KAAM,SAAU,KAAK,IAAI;AAGvC,eAAW,OAAO;AAElB,eAAW,SAAS;AAEpB,cAAU;EACd;AAGA,WAAS,KAAK,KAAK,SAAS,EAAE,IAAI;AAElC,SAAO,EAAE,aAAa,MAAM,OAAA;AAChC;;;AC1EO,SAAS,sBAAsB,YAAwB,aAC9D;AAEI,QAAM,EAAE,MAAM,MAAA,IAAU,qBAAqB,WAAW,KAAK,IAAI;AAEjE,QAAM,aAAa,QAAQ,QAAQ;AACnC,QAAM,OAAO,WAAW,KAAK,KAAK,QAAQ,KAAK,KAAK,IAAI,cAAc;AAEtE,SAAO;kBACO,WAAW,KAAK,IAAI;WAC3B,gBAAgB,IAAI,aAAa,WAAW,MAAM,EAAE;;;;;;4BAMnC,WAAW,KAAK,QAAQ,OAAO,EAAE;;kCAE3B,OAAO,CAAC;;mBAEvB,IAAI;;eAER,cAAc,IAAI,kBAAkB,SAAS,MAAM,EAAE;;;AAGpE;;;AC3BO,SAAS,0BACZ,aAEJ;AACI,SAAO;IACH;IACA;IACA;IACA;EAAA;AAER;;;ACVO,IAAM,eAAN,cAA2B,UAClC;EAOI,cACA;AACI,UAAM;MACF,mBAAmB;MACnB,iBAAiB;IAAA,CACpB;EACL;AACJ;AAfa,aAGK,YAAY;EACtB,MAAM,CAAC,cAAc,YAAY;EACjC,MAAM;AACV;;;ACfG,IAAM,WAAN,MACP;EAMI,YAAY,EAAE,2BAAAA,2BAAA,GACd;AALA,SAAiB,6BAAqC;AAEtD,SAAO,YAAY;AAIf,SAAK,6BAA6BA;AAClC,SAAK,OAAO,IAAI,aAAa,KAAK;EACtC;EAEO,QACP;AACI,SAAK,YAAY;EACrB;EAEO,cAAc,MACrB;AAEI,QAAI,OAAO,KAAK,6BAA6B,GAC7C;AACI,YAAM,IAAI,MAAM,2CAA2C,OAAO,CAAC,EAAE;IACzE;AAEA,UAAM,QAAQ,KAAK;AAEnB,QAAI,UAAU,QAAS,OAAO;AAE9B,cAAU,KAAK,KAAK,UAAU,KAAK,0BAA0B,IAAI,KAAK;AAEtE,QAAI,UAAU,KAAK,KAAK,SAAS,GACjC;AAEI,YAAM,IAAI,MAAM,2CAA2C;IAC/D;AAEA,SAAK,YAAY;AAEjB,WAAO;EACX;EAEO,SAAS,OAChB;AACI,UAAM,SAAS,KAAK,cAAc,MAAM,MAAM;AAE9C,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,WAAK,KAAM,SAAS,IAAK,CAAC,IAAI,MAAM,CAAC;IACzC;AAEA,WAAO;EACX;EAEO,UACP;AACI,SAAK,OAAO;EAChB;AACJ;;;AClDA,IAAM,4BAA4B;AAG3B,IAAM,sBAAN,MACP;EAoBI,YAAY,UACZ;AAVA,SAAQ,iBAA4C,uBAAO,OAAO,IAAI;AAItE,SAAQ,WAAqB,CAAA;AAE7B,SAAQ,cAA2B,CAAA;AACnC,SAAQ,mBAAqC,CAAA;AAIzC,SAAK,YAAY;AAEjB,SAAK,eAAe,IAAI,SAAS,EAAE,0BAAA,CAA2B;AAE9D,UAAM,eAAgB,MAAM;AAE5B,aAAS,IAAI,GAAG,IAAI,cAAc,KAClC;AACI,UAAI,QAAQ,YAAY,UAAU,YAAY;AAE9C,UAAI,MAAM,EAAG,UAAS,YAAY;AAElC,WAAK,SAAS,KAAK,IAAI,OAAO;QAC1B,MAAM,KAAK,aAAa;QACxB;MAAA,CACH,CAAC;IACN;EACJ;EAEO,YACP;AACI,SAAK,kBAAA;AACL,SAAK,iBAAA;EACT;EAEQ,mBACR;AACI,SAAK,iBAAiB,uBAAO,OAAO,IAAI;AACxC,SAAK,aAAa,MAAA;EACtB;;EAGO,oBAAoB,OAA0B,WACrD;AACI,QAAI,CAAC,aAAa,KAAK,eAAe,MAAM,GAAG,GAC/C;AACI,aAAO,KAAK,eAAe,MAAM,GAAG;IACxC;AAEA,SAAK,UAAU,IAAI,mBAAmB,KAAK;AAE3C,UAAM,OAAO,MAAM,OAAO;AAE1B,UAAM,SAAS,KAAK,aAAa,cAAc,KAAK,MAAM;AAE1D,SAAK,UAAU,IAAI,iBAAiB,OAAO,KAAK,aAAa,MAAM,SAAS,CAAC;AAE7E,SAAK,eAAe,MAAM,GAAG,IAAI,KAAK,cAAc,SAAS,yBAAyB;AAEtF,WAAO,KAAK,eAAe,MAAM,GAAG;EACxC;EAEO,eAAe,OACtB;AACI,SAAK,UAAU,IAAI,mBAAmB,KAAK;AAE3C,UAAM,OAAO,MAAM,OAAO;AAE1B,UAAM,SAAS,KAAK,aAAa,SAAS,IAAI;AAE9C,WAAO,KAAK,mBAAmB,SAAS,yBAAyB;EACrE;EAEO,kBAAkB,MACzB;AACI,UAAM,SAAS,KAAK,aAAa,SAAS,IAAI;AAE9C,WAAO,KAAK,cAAc,SAAS,yBAAyB;EAChE;EAEO,uBAAuB,MAC9B;AACI,UAAM,SAAS,KAAK,aAAa,SAAS,IAAI;AAE9C,UAAM,QAAQ,SAAS;AAEvB,WAAO,KAAK,mBAAmB,KAAK;EACxC;EAEQ,mBAAmB,OAC3B;AACI,QAAI,CAAC,KAAK,iBAAiB,KAAK,GAChC;AACI,YAAM,SAAS,KAAK,SAAS,QAAQ,CAAC;AAEtC,WAAK,iBAAiB,KAAK,IAAI,IAAI,eAAe;QAC9C;QACA,SAAU,QAAQ,IAAK,KAAK;QAC5B,MAAM;MAAA,CACT;IACL;AAEA,WAAO,KAAK,iBAAiB,KAAK;EACtC;EAEQ,cAAc,OACtB;AACI,QAAI,CAAC,KAAK,YAAY,KAAK,GAC3B;AAEI,YAAM,YAAY,IAAI,UAAU;QAC5B,GAAG,KAAK,mBAAmB,KAAK;MAAA,CACnC;AAED,WAAK,YAAY,KAAK,IAAI;IAC9B;AAEA,WAAO,KAAK,YAAY,KAAK;EACjC;EAEQ,oBACR;AACI,UAAM,eAAe,KAAK,UAAU;AAEpC,UAAM,cAAc,KAAK,SAAS,CAAC;AAEnC,gBAAY,OAAO,KAAK,aAAa,SAAS;AAE9C,iBAAa,aAAa,WAAW;AAErC,UAAM,iBAAiB,KAAK,UAAU,IAAI,OAAO,qBAAA;AAEjD,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAC1C;AACI,YAAM,SAAS,KAAK,SAAS,CAAC;AAE9B,qBAAe;QACX,aAAa,aAAa,WAAW;QACrC;QACA,aAAa,aAAa,MAAM;QAChC;QACA,KAAK,aAAa;MAAA;IAE1B;AAGA,SAAK,UAAU,IAAI,OAAO,MAAM,OAAO,CAAC,eAAe,OAAA,CAAQ,CAAC;EACpE;EAEO,UACP;;AACI,aAAS,IAAI,GAAG,IAAI,KAAK,YAAY,QAAQ,KAC7C;AACI,iBAAK,YAAY,CAAC,MAAlB,mBAAqB;IACzB;AAEA,SAAK,cAAc;AACnB,SAAK,iBAAiB;AAEtB,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAC1C;AACI,WAAK,SAAS,CAAC,EAAE,QAAA;IACrB;AACA,SAAK,WAAW;AAEhB,aAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,QAAQ,KAClD;AACI,WAAK,iBAAiB,CAAC,EAAE,QAAA;IAC7B;AAEA,SAAK,mBAAmB;AAExB,SAAK,aAAa,QAAA;AAElB,SAAK,YAAY;EACrB;AACJ;AA7La,oBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;ACJJ,IAAM,qBAAqB;EACvB,cAAc;EACd,aAAa;EACb,cAAc;EACd,iBAAiB;EACjB,kBAAkB;AACtB;AAOA,SAAS,oBACL,gBACA,WACA,OACA,WACA,UAEJ;AACI,SAAQ,kBAAkB,KAClB,aAAa,KACb,SAAS,KACT,aAAa,IACd;AACX;AAOA,SAAS,kBACL,gBACA,kBACA,WACA,cACA,kBAEJ;AACI,SAAQ,aAAa,IACb,kBAAkB,IAClB,gBAAgB,IAChB,oBAAoB,IACrB;AACX;AAsBO,IAAM,iBAAN,MACP;EA0BI,YAAY,UACZ;AAjBA,SAAQ,eAAgD,uBAAO,OAAO,IAAI;AAC1E,SAAQ,sBAA+D,uBAAO,OAAO,IAAI;AACzF,SAAiB,qBAA6D,uBAAO,OAAO,IAAI;AAEhG,SAAQ,aAAuB,uBAAO,OAAO,IAAI;AACjD,SAAiB,mBAA6C,uBAAO,OAAO,IAAI;AAMhF,SAAQ,aAAa;AACrB,SAAQ,oBAAoB;AAC5B,SAAQ,oBAAoB;AAKxB,SAAK,YAAY;EACrB;EAEU,cAAc,KACxB;AACI,SAAK,OAAO;AACZ,SAAK,eAAe,cAAc,QAAQ;AAE1C,SAAK,gBAAA;EACT;EAEO,oBAAoB,kBAC3B;AACI,QAAI,KAAK,sBAAsB,iBAAkB;AAEjD,SAAK,oBAAoB;AAEzB,SAAK,gBAAA;EACT;EAEO,gBAAgB,cACvB;AACI,SAAK,oBAAoB,aAAa;AACtC,SAAK,0BAA0B,aAAa,WAAW,yBAAyB,IAAI;AACpF,SAAK,oBAAoB,aAAa;AACtC,SAAK,gBAAA;EACT;EAEO,aAAa,WACpB;AACI,QAAI,KAAK,eAAe,UAAW;AAEnC,SAAK,aAAa;AAElB,SAAK,gBAAA;EACT;EAEO,eAAe,aACtB;AACI,QAAI,KAAK,iBAAiB,YAAa;AAEvC,SAAK,eAAe;AACpB,SAAK,gBAAgB,sBAAsB,WAAW;AAEtD,SAAK,gBAAA;EACT;EAEO,YAAY,UAAoB,SAAqB,OAAc,aAC1E;AACI,UAAM,WAAW,KAAK,YAAY,UAAU,SAAS,KAAK;AAE1D,gBAAY,YAAY,QAAQ;EACpC;EAEO,YACH,UACA,SACA,OACA,UAEJ;AACI,QAAI,CAAC,SAAS,YACd;AACI,uBAAiB,UAAU,QAAQ,aAAa;AAGhD,WAAK,mBAAmB,QAAQ;IACpC;AAEA,iBAAA,WAAa,SAAS;AAGtB,UAAM,MAAM;MACR,SAAS;MACT,QAAQ;MACR,MAAM;MACN,MAAM;MACN,mBAAmB,QAAQ;IAAA;AAG/B,QAAI,KAAK,WAAW,GAAG,EAAG,QAAO,KAAK,WAAW,GAAG;AAEpD,SAAK,WAAW,GAAG,IAAI,KAAK,gBAAgB,UAAU,SAAS,OAAO,QAAQ;AAE9E,WAAO,KAAK,WAAW,GAAG;EAC9B;EAEQ,gBAAgB,UAAoB,SAAqB,OAAc,UAC/E;AACI,UAAM,SAAS,KAAK,KAAK;AAEzB,UAAM,UAAU,KAAK,2BAA2B,UAAU,OAAO;AAEjE,UAAM,aAAa,KAAK,UAAU,MAAM,gBAAgB,OAAO,KAAK,iBAAiB;AAGrF,UAAM,YAAY,KAAK,iBAAiB,cAAc,qBAAqB,IAAI,KAAK;AAEpF,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KACvC;AACI,iBAAW,CAAC,EAAE,YAAY;IAC9B;AAEA,UAAM,SAAS,KAAK,UAAU,OAAO,eAAe,OAAO,EAAE;AAE7D,UAAM,aAA0C;;;MAG5C,QAAQ;QACJ,QAAQ,KAAK,WAAW,QAAQ,OAAO,MAAM;QAC7C,YAAY,QAAQ,OAAO;;QAE3B;MAAA;MAEJ,UAAU;QACN,QAAQ,KAAK,WAAW,QAAQ,SAAS,MAAM;QAC/C,YAAY,QAAQ,SAAS;QAC7B,SAAS;MAAA;MAEb,WAAW;QACP;QACA,UAAU,MAAM;MAAA;MAEpB;MACA,aAAa;QACT,OAAO,KAAK;MAAA;;MAGhB,OAAO;IAAA;AAIX,QAAI,KAAK,yBACT;AAEI,iBAAW,eAAe;QACtB,GAAG,KAAK;QACR,QAAQ;QACR,mBAAmB,MAAM;QACzB,cAAc,MAAM,YAAY,SAAS;MAAA;IAEjD;AAEA,UAAM,WAAW,OAAO,qBAAqB,UAAU;AAEvD,WAAO;EACX;EAEQ,WAAW,MACnB;AACI,WAAO,KAAK,aAAa,IAAI,KAAK,KAAK,cAAc,IAAI;EAC7D;EAEQ,cAAc,MACtB;AACI,UAAM,SAAS,KAAK,KAAK;AAEzB,SAAK,aAAa,IAAI,IAAI,OAAO,mBAAmB;MAChD;IAAA,CACH;AAED,WAAO,KAAK,aAAa,IAAI;EACjC;EAEQ,mBAAmB,UAC3B;AACI,UAAM,SAAS,CAAA;AACf,QAAI,QAAQ;AAGZ,UAAM,gBAAgB,OAAO,KAAK,SAAS,UAAU,EAAE,KAAA;AAEvD,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAC1C;AACI,YAAM,YAAY,SAAS,WAAW,cAAc,CAAC,CAAC;AAEtD,aAAO,OAAO,IAAI,UAAU;AAC5B,aAAO,OAAO,IAAI,UAAU;AAC5B,aAAO,OAAO,IAAI,UAAU;AAC5B,aAAO,OAAO,IAAI,UAAU;IAChC;AAEA,UAAM,YAAY,OAAO,KAAK,GAAG;AAEjC,aAAS,aAAa,mBAAmB,WAAW,UAAU;AAE9D,WAAO,SAAS;EACpB;EAEQ,+BAA+B,SACvC;AACI,UAAM,SAAS,CAAA;AACf,QAAI,QAAQ;AAGZ,UAAM,gBAAgB,OAAO,KAAK,QAAQ,aAAa,EAAE,KAAA;AAEzD,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAC1C;AACI,YAAM,YAAY,QAAQ,cAAc,cAAc,CAAC,CAAC;AAExD,aAAO,OAAO,IAAI,UAAU;IAChC;AAEA,UAAM,YAAY,OAAO,KAAK,GAAG;AAEjC,YAAQ,yBAAyB,mBAAmB,WAAW,mBAAmB;AAElF,WAAO,QAAQ;EACnB;;;;;;;;EASO,qBAAqB,UAAoB,SAChD;AACI,UAAM,MAAO,SAAS,cAAc,KAAM,QAAQ;AAElD,QAAI,KAAK,mBAAmB,GAAG,EAAG,QAAO,KAAK,mBAAmB,GAAG;AAEpE,UAAM,OAAO,KAAK,2BAA2B,UAAU,OAAO;AAG9D,UAAM,oBAA4C,uBAAO,OAAO,IAAI;AAEpE,UAAM,gBAAgB,QAAQ;AAE9B,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KACjC;AACI,YAAM,aAAa,OAAO,OAAO,KAAK,CAAC,EAAE,UAAU;AAEnD,YAAM,iBAAiB,WAAW,CAAC,EAAE;AAErC,iBAAW,KAAK,eAChB;AACI,YAAI,cAAc,CAAC,EAAE,aAAa,gBAClC;AACI,4BAAkB,CAAC,IAAI;AACvB;QACJ;MACJ;IACJ;AAEA,SAAK,mBAAmB,GAAG,IAAI;AAE/B,WAAO;EACX;EAEQ,2BAA2B,UAAoB,SACvD;AACI,QAAI,CAAC,QAAQ,uBAAwB,MAAK,+BAA+B,OAAO;AAEhF,UAAM,MAAO,SAAS,cAAc,KAAM,QAAQ;AAElD,QAAI,KAAK,oBAAoB,GAAG,GAChC;AACI,aAAO,KAAK,oBAAoB,GAAG;IACvC;AAEA,UAAM,sBAA+C,CAAA;AAErD,aAAS,QAAQ,QAAQ,CAAC,WAC1B;AACI,YAAM,cAAqC;QACvC,aAAa;QACb,UAAU;QACV,YAAY,CAAA;MAAC;AAGjB,YAAM,wBAAwB,YAAY;AAE1C,iBAAW,KAAK,QAAQ,eACxB;AACI,cAAM,YAAY,SAAS,WAAW,CAAC;AAEvC,aAAK,UAAU,WAAW,OAAO,GACjC;AAGI,eAAK,aAAa,CAAC,qCAAqC,UAAU,OAAO,8CACxB;QACrD;AAEA,YAAI,UAAU,WAAW,QACzB;AACI,sBAAY,cAAc,UAAU;AACpC,sBAAY,WAAW,UAAU,WAAW,aAAa;AAEzD,gCAAsB,KAAK;YACvB,gBAAgB,QAAQ,cAAc,CAAC,EAAE;YACzC,QAAQ,UAAU;YAClB,QAAQ,UAAU;UAAA,CACrB;QACL;MACJ;AAEA,UAAI,sBAAsB,QAC1B;AACI,4BAAoB,KAAK,WAAW;MACxC;IACJ,CAAC;AAED,SAAK,oBAAoB,GAAG,IAAI;AAEhC,WAAO;EACX;EAEQ,kBACR;AACI,UAAM,MAAM;MACR,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;IAAA;AAGT,QAAI,CAAC,KAAK,iBAAiB,GAAG,GAC9B;AACI,WAAK,iBAAiB,GAAG,IAAI,uBAAO,OAAO,IAAI;IACnD;AAEA,SAAK,aAAa,KAAK,iBAAiB,GAAG;EAC/C;EAEO,UACP;AACK,SAAK,YAAqB;AAC3B,SAAK,sBAAsB;EAC/B;AACJ;AA3Wa,eAGK,YAAY;EACtB,MAAM,CAAC,cAAc,YAAY;EACjC,MAAM;AACV;;;ACpFG,IAAM,kBAAN,MACP;EADO,cAAA;AAEH,SAAO,WAA+B,CAAA;AACtC,SAAO,eAAgC,CAAA;AAEvC,SAAO,cAAc;EAAA;AAKzB;;;ACEO,IAAM,yBAAN,MACP;EAIW,KAAK,UAA0B,oBACtC;AACI,SAAK,YAAY;AACjB,SAAK,sBAAsB;EAC/B;EAEO,cACH,4BACA,oBACA,WACA,MACA,YAEJ;AACI,UAAM,WAAW,KAAK;AAEtB,UAAM,iBAAiB,KAAK;MACxB;IAAA;AAGJ,UAAM,iBAAiB,SAAS,QAAQ;MACpC,mBAAmB;IAAA;AAGvB,aAAS,QAAQ,eAAe;MAC5B;QACI,SAAS;QACT,QAAQ;MAAA;MAEZ;QACI,SAAS;QACT,QAAQ;MAAA;MAEZ;IAAA;AAGJ,WAAO;EACX;EAEO,gBACH,cACA,QAAuB,MACvB,YACA,UACA,WAAW,GACX,QAAQ,GAEZ;;AACI,UAAM,qBAAqB,KAAK;AAEhC,UAAM,kBAAkB,mBAAmB,mBAAmB,YAAY;AAE1E,QAAI,UAAU,OAAK,qBAAgB,iBAAhB,mBAA8B,SACjD;AACI,YAAM,IAAI,MAAM,2FAA2F;IAC/G;AAEA,QAAI,WAAW,OAAK,qBAAgB,iBAAhB,mBAA8B,SAClD;AACI,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,UAAM,aAAa,KAAK,cAAc,cAAc,OAAO,YAAY,UAAU,KAAK;AAEtF,oBAAgB,aAAa;AAI7B,SAAK,UAAU,SAAS,gBAAgB,eAAe;AACvD,SAAK,UAAU,QAAQ,gBAAgB,eAAe;AACtD,SAAK,UAAU,QAAQ,YAAY,QAAQ;EAC/C;EAEO,mBACP;AACI,SAAK,UAAU,QAAQ,cAAA;EAC3B;;;;;;;EAQQ,oBAAoB,cAC5B;AACI,UAAM,kBAAkB,KAAK,oBAAoB,mBAAmB,YAAY;AAEhF,QAAI,gBAAgB,SAAS,CAAC,GAC9B;AACI,aAAO,gBAAgB,SAAS,CAAC,EAAE,kBAAA;IACvC;AAEA,WAAO,KAAK,UAAU,QAAQ;MAC1B,aAAa,cAAc,CAAC,EAAE;IAAA;EAEtC;EAEO,cACH,cACA,OACA,YACA,WAAW,GACX,QAAQ,GAEZ;AACI,QAAI,OAAO,UAAU,WACrB;AACI,cAAQ,QAAQ,MAAM,MAAM,MAAM;IACtC;AAEA,UAAM,qBAAqB,KAAK;AAEhC,UAAM,kBAAkB,mBAAmB,mBAAmB,YAAY;AAE1E,UAAM,mBAAmB,aAAa,cAAc;MAChD,CAAC,SAAS,MACV;AACI,cAAM,UAAU,gBAAgB,SAAS,CAAC;AAE1C,YAAI;AACJ,YAAI;AAEJ,YAAI,SACJ;AACI,cAAI,UAAU,GACd;AAEI,kBAAM,IAAI,MAAM,qFAAqF;UACzG;AAEA,gBAAM,iBAAiB,QAAQ,kBAAA;AAE/B,gBAAM,oBAAoB,eAAe,WAAA;AAEzC,iBAAO;QACX,OAEA;AACI,iBAAO,KAAK,UAAU,QAAQ,aAAa,OAAO,EAAE,WAAW;;YAE3D,WAAW;YACX,cAAc;YACd,eAAe;YACf,gBAAgB;YAChB,iBAAiB;UAAA,CACpB;QACL;AAEA,YAAI,gBAAgB,aAAa,CAAC,GAClC;AACI,0BAAgB;AAChB,iBAAO,KAAK,UAAU,QAAQ;YAC1B,gBAAgB,aAAa,CAAC;UAAA;QAEtC;AAEA,cAAM,SAAW,QAAkB,MAAM,QAAQ,UAAU;AAE3D,uBAAA,aAAe,mBAAmB;AAElC,eAAO;UACH;UACA;UACA;UACA,SAAS;UACT;QAAA;MAER;IAAA;AAGJ,QAAI;AAIJ,SAAK,aAAa,WAAW,aAAa,UAAU,CAAC,aAAa,qBAClE;AACI,mBAAa,0BAAA;AACb,mBAAa,oBAAoB,OAAO,cAAc,gBAAgB,OAAO,IAAI;IACrF;AAEA,QAAI,aAAa,qBACjB;AACI,YAAM,gBAAiB,QAAQ,MAAM,UAAU,UAAU;AACzD,YAAM,cAAe,QAAQ,MAAM,QAAQ,UAAU;AAErD,+BAAyB;QACrB,MAAM,KAAK,UAAU,QAChB,aAAa,aAAa,oBAAoB,MAAM,EACpD,WAAW;UACR,WAAW;UACX,cAAc;UACd,eAAe;UACf,gBAAgB;UAChB,iBAAiB;QAAA,CACpB;QACL,gBAAgB;QAChB;QACA,iBAAiB;QACjB;QACA,cAAc;MAAA;IAEtB;AAEA,UAAM,aAAsC;MACxC;MACA;IAAA;AAGJ,WAAO;EACX;EAEO,MACH,cACA,QAAuB,MACvB,YACA,UACA,WAAW,GACX,QAAQ,GAEZ;AACI,QAAI,CAAC,MAAO;AAEZ,UAAM,EAAE,KAAK,QAAA,IAAY,KAAK;AAE9B,UAAM,SAAS,IAAI;AAEnB,UAAM,aAAa,QAAQ,mBAAmB;AAE9C,QAAI,YACJ;AACI,YAAM,iBAAiB,OAAO,qBAAA;AAC9B,YAAM,uBAAuB,KAAK,cAAc,cAAc,OAAO,YAAY,UAAU,KAAK;AAEhG,YAAM,cAAc,eAAe,gBAAgB,oBAAoB;AAEvE,kBAAY,YAAY,SAAS,GAAG,SAAS,GAAG,SAAS,OAAO,SAAS,QAAQ,GAAG,CAAC;AAErF,kBAAY,IAAA;AAEZ,YAAM,cAAc,eAAe,OAAA;AAEnC,aAAO,MAAM,OAAO,CAAC,WAAW,CAAC;IACrC,OAEA;AACI,WAAK,gBAAgB,cAAc,OAAO,YAAY,UAAU,UAAU,KAAK;IACnF;EACJ;EAEO,oBAAoB,cAC3B;AAEI,iBAAa,SAAS;AAEtB,UAAM,kBAAkB,IAAI,gBAAA;AAE5B,oBAAgB,mBAAmB,aAAa,cAAc;AAI9D,iBAAa,cAAc,QAAQ,CAAC,cAAc,MAClD;AACI,UAAI,wBAAwB,cAC5B;AACI,cAAM,UAAU,aAAa,SAAS;UAClC;QAAA;AAGJ,cAAM,YAAa,aAA8B,cAAc,kBAAkB;AAEjF,YACA;AACI,kBAAQ,UAAU;YACd,QAAQ,KAAK,UAAU,IAAI;YAC3B,OAAO,gBAAgB,kBACjB,gBAAgB,WAChB,gBAAgB,oBAChB,gBAAgB;YACtB,QAAQ;YACR;UAAA,CACH;QACL,SACO,GACP;AACI,kBAAQ,MAAM,CAAC;QACnB;AAEA,wBAAgB,SAAS,CAAC,IAAI;MAClC;AAEA,sBAAgB,OAAO,aAAa,OAAO;AAE3C,UAAI,aAAa,OAAO,WACxB;AACI,cAAM,cAAc,IAAI,cAAc;UAClC,OAAO;UACP,QAAQ;UACR,aAAa;UACb,iBAAiB,aAAa,OAAO;QAAA,CACxC;AAED,wBAAgB,aAAa,CAAC,IAAI;MACtC;IACJ,CAAC;AAED,QAAI,gBAAgB,MACpB;AACI,sBAAgB,cAAc;AAE9B,UAAI,aAAa,qBACjB;AACI,qBAAa,oBAAoB,OAAO,cAAc;MAC1D;IACJ;AAEA,WAAO;EACX;EAEO,uBAAuB,iBAC9B;AACI,oBAAgB,SAAS,QAAQ,CAAC,YAClC;AACI,cAAQ,YAAA;IACZ,CAAC;AAED,oBAAgB,aAAa,QAAQ,CAAC,YACtC;AACI,cAAQ,QAAA;IACZ,CAAC;AAED,oBAAgB,aAAa,SAAS;AACtC,oBAAgB,SAAS,SAAS;EACtC;EAEO,0BAA0B,cACjC;AAEI,UAAM,kBAAkB,KAAK,oBAAoB,mBAAmB,YAAY;AAEhF,QAAI,aAAa,uBAAuB,gBAAgB,MACxD;AACI,mBAAa,oBAAoB,OAAO,cAAc;IAC1D;EACJ;EAEO,sBAAsB,cAC7B;AACI,UAAM,kBAAkB,KAAK,oBAAoB,mBAAmB,YAAY;AAEhF,oBAAgB,QAAQ,aAAa;AACrC,oBAAgB,SAAS,aAAa;AAEtC,QAAI,gBAAgB,MACpB;AACI,mBAAa,cAAc,QAAQ,CAAC,cAAc,MAClD;AACI,cAAM,cAAc,gBAAgB,aAAa,CAAC;AAElD,mDAAa;UACT,aAAa,OAAO;UACpB,aAAa,OAAO;UACpB,aAAa,OAAO;;MAE5B,CAAC;IACL;EACJ;AACJ;;;AC3XO,IAAM,wBAAN,cAAoC,mBAC3C;EASI,YAAY,UACZ;AACI,UAAM,QAAQ;AAJlB,SAAO,UAAU,IAAI,uBAAA;AAMjB,SAAK,QAAQ,KAAK,UAAU,IAAI;EACpC;AACJ;AAhBa,sBAGK,YAAY;EACtB,MAAM,CAAC,cAAc,YAAY;EACjC,MAAM;AACV;;;ACIG,IAAM,kBAAN,MACP;EADO,cAAA;AAYH,SAAiB,kBAAkD,uBAAO,OAAO,IAAI;EAAA;EAE3E,cAAc,KACxB;AACI,SAAK,OAAO;EAChB;EAEO,eAAe,SACtB;AACI,WAAO,KAAK,gBAAgB,QAAQ,UAAU,KAAK,KAAK,sBAAsB,OAAO;EACzF;EAEQ,sBAAsB,SAC9B;AACI,UAAM,SAAS,KAAK,KAAK;AAEzB,UAAM,aAAa,QAAQ,UAAU,IAAI,CAAC,UAAU,OAAO,sBAAsB,EAAE,SAAS,MAAA,CAAO,CAAC;AAEpG,UAAM,qBAAqB,EAAE,kBAAkB,WAAA;AAE/C,SAAK,gBAAgB,QAAQ,UAAU,IAAI;MACvC;MACA,UAAU,OAAO,qBAAqB,kBAAkB;IAAA;AAU5D,WAAO,KAAK,gBAAgB,QAAQ,UAAU;EAClD;EAEO,UACP;AAEI,SAAK,OAAO;AACX,SAAK,kBAA2B;EACrC;AACJ;AArDa,gBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;AC3BG,IAAM,sBAAmE,CAAA;AAEhF,oBAAoB,SAAS;EACzB,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,MAAM;EACtB,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,WAAW;EAC3B,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,SAAS;EACzB,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,UAAU;EAC1B,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,OAAO;EACvB,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAGA,oBAAoB,YAAY,IAAI;EAChC,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,SAAS,IAAI;EAC7B,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,YAAY,IAAI;EAChC,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,QAAQ;EACxB,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,MAAM;EACtB,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;AAEA,oBAAoB,MAAM;EACtB,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;EAEf,OAAO;IACH,WAAW;IACX,WAAW;IACX,WAAW;EAAA;AAEnB;;;ACnJO,IAAM,iBAAN,MACP;EA2CI,cACA;AACI,SAAK,eAAe,IAAI,MAAA;AACxB,SAAK,aAAa,QAAQ;EAC9B;EAEU,cAAc,KACxB;AACI,SAAK,MAAM;EACf;;;;;;EAOO,gBAAgB,OAAc,OACrC;AACI,UAAM,QAAQ,oBAAoB,MAAM,SAAS,KAAK,oBAAoB;AAE1E,UAAM,UAAiC,CAAA;AACvC,UAAM,SAAS;MACX,QAAQ;MACR,WAAW;MACX;IAAA;AAGJ,aAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACI,cAAQ,CAAC,IAAI;IACjB;AAEA,WAAO;EACX;EAEO,UACP;AACI,SAAK,MAAM;EACf;AACJ;AAnFa,eAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;AChBG,IAAM,+BAA+B;EAExC,MAAM;EAEN,OAAO,QAA2B,YAAwB,KAAU,kBAAkB,GACtF;AACI,UAAM,WAAW,OAAO;AAExB,UAAM,SAAS,OAAO,aAAa,MAAM,OAAO,cAAc;AAE9D,UAAM,gBAAgB,SAAS,aAAa;AAE5C,QAAI,OAAO,MAAM;MACb,EAAE,SAAS,YAAY,QAAQ,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,gBAAA,EAAgB;MAChE;MACA;QACI,QAAQ;QACR,cAAc,OAAO;QACrB,aAAa,OAAO,aAAa;MAAA;MAErC;QACI,OAAO,OAAO;QACd,QAAQ,OAAO;QACf,oBAAoB;MAAA;IACxB;EAER;AACJ;;;AC3BO,IAAM,eAA8F;EACvG,kBAAkB,EAAE,YAAY,GAAG,YAAY,GAAG,aAAa,EAAA;EAC/D,kBAAkB,EAAE,YAAY,IAAI,YAAY,GAAG,aAAa,EAAA;EAChE,kBAAkB,EAAE,YAAY,IAAI,YAAY,GAAG,aAAa,EAAA;EAChE,kBAAkB,EAAE,YAAY,IAAI,YAAY,GAAG,aAAa,EAAA;EAChE,kBAAkB,EAAE,YAAY,GAAG,YAAY,GAAG,aAAa,EAAA;EAC/D,mBAAmB,EAAE,YAAY,IAAI,YAAY,GAAG,aAAa,EAAA;EACjE,kBAAkB,EAAE,YAAY,IAAI,YAAY,GAAG,aAAa,EAAA;AACpE;AAEA,IAAM,mBAAmB,EAAE,YAAY,GAAG,YAAY,GAAG,aAAa,EAAA;AAG/D,IAAM,qCAAqC;EAE9C,MAAM;EAEN,OAAO,QAA0B,YAAwB,KAAU,kBAAkB,GACrF;AACI,QAAI,WAAW,OAAO;AACtB,QAAI,YAAY,OAAO;AAEvB,UAAM,YAAY,aAAa,OAAO,MAAM,KAAK;AAEjD,aAAS,IAAI,GAAG,IAAI,OAAO,SAAS,QAAQ,KAC5C;AACI,YAAM,cAAc,OAAO,SAAS,CAAC;AAErC,YAAM,cAAc,KAAK,KAAK,WAAW,UAAU,UAAU,IAAI,UAAU;AAE3E,UAAI,OAAO,MAAM;QACb;UACI,SAAS;UACT,UAAU;UACV,QAAQ,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,gBAAA;QAAgB;QAE7C;QACA;UACI,QAAQ;UACR;QAAA;QAEJ;UACI,OAAO,KAAK,KAAK,WAAW,UAAU,UAAU,IAAI,UAAU;UAC9D,QAAQ,KAAK,KAAK,YAAY,UAAU,WAAW,IAAI,UAAU;UACjE,oBAAoB;QAAA;MACxB;AAGJ,iBAAW,KAAK,IAAI,YAAY,GAAG,CAAC;AACpC,kBAAY,KAAK,IAAI,aAAa,GAAG,CAAC;IAC1C;EACJ;AACJ;;;ACrDA,IAAM,aAAmD,CAAC,SAAS,QAAQ,OAAO,UAAU,SAAS,MAAM;AAOpG,SAAS,mCACZ,WAEJ;AACI,SAAO;IACH,MAAM;IACN,OAAO,QAA2B,YAAwB,KAC1D;AACI,YAAM,QAAQ,OAAO;AAErB,eAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KACvC;AACI,cAAM,MAAM,WAAW,CAAC;AACxB,cAAM,OAAO,MAAM,GAAG;AAEtB,cAAM,WAAW,UAAU,KAAK,cAAc,KAAK,UAAU;AAE7D,iBAAS,OAAO,MAAa,YAAY,KAAK,CAAC;MACnD;IACJ;EAAA;AAER;;;ACxBO,IAAM,yBAAyB;EAElC,MAAM;EAEN,OAAO,QAAuB,YAAwB,KAAU,kBAAkB,GAClF;AACI,UAAM,WAAW,OAAO;AAExB,QAAI,CAAC,SAAU;AAIf,QAAI,WAAW,oBAAoB,oBAAoB,kBACvD;AACI,YAAM,SAAS,WAAW,IAAA,EAAM,aAAa,SAAS,OAAO,SAAS,MAAM;AAC5E,YAAM,UAAU,OAAO,WAAW,IAAI;AAEtC,cAAQ,UAAU,UAAU,GAAG,GAAG,SAAS,OAAO,SAAS,MAAM;AAGjE,aAAO,WAAW;AAGlB,WAAK,iFAAiF;IAE1F;AAEA,UAAM,QAAQ,KAAK,IAAI,WAAW,OAAO,OAAO,iBAAiB,OAAO,UAAU;AAClF,UAAM,SAAS,KAAK,IAAI,WAAW,QAAQ,OAAO,kBAAkB,OAAO,WAAW;AAEtF,UAAM,qBAAqB,OAAO,cAAc;AAEhD,QAAI,OAAO,MAAM;MACb,EAAE,QAAQ,SAAA;MACV,EAAE,SAAS,YAAY,QAAQ,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,gBAAA,GAAmB,mBAAA;MACnE;QACI;QACA;MAAA;IACJ;EAER;AACJ;;;AC1CO,IAAM,yBAAyB;EAElC,MAAM;EAEN,OAAO,QAAqB,YAAwB,KAAU,iBAC9D;AACI,2BAAuB,OAAO,QAAQ,YAAY,KAAK,eAAe;EAC1E;AACJ;;;ACRO,IAAM,qBAAN,MACP;EAOI,YAAY,QACZ;AACI,SAAK,SAAS;AACd,SAAK,UAAU,OAAO,cAAc,EAAE,WAAW,SAAA,CAAU;AAE3D,SAAK,YAAY,CAAA;EACrB;EAEQ,mBAAmB,QAC3B;AACI,QAAI,WAAW,KAAK,UAAU,MAAM;AAEpC,QAAI,CAAC,UACL;AAEI,UAAI,CAAC,KAAK,oBACV;AACI,aAAK,qBAAqB,KAAK,OAAO,mBAAmB;UACrD;;YAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;QAAA,CAyBpB;MACL;AAEA,iBAAW,KAAK,OAAO,qBAAqB;QACxC,QAAQ;QACR,QAAQ;UACJ,QAAQ,KAAK;UACb,YAAY;QAAA;QAEhB,UAAU;UACN,QAAQ,KAAK;UACb,YAAY;UACZ,SAAS,CAAC,EAAE,OAAA,CAAQ;QAAA;MACxB,CACH;AAED,WAAK,UAAU,MAAM,IAAI;IAC7B;AAEA,WAAO;EACX;;;;;;EAOO,eAAe,SACtB;AACI,UAAM,WAAW,KAAK,mBAAmB,QAAQ,MAAM;AAEvD,QAAI,QAAQ,cAAc,QAAQ,QAAQ,cAAc,MACxD;AACI,YAAM,IAAI,MAAM,kEAAkE;IACtF;AAEA,QAAI,aAAa;AACjB,UAAM,kBAAkB,QAAQ,sBAAsB;AAGtD,UAAM,iBAAiB,QAAQ,QAAQ,gBAAgB;AAEvD,QAAI,CAAC,gBACL;AAGI,YAAM,uBAAuB;QACzB,MAAM;UACF,OAAO,KAAK,KAAK,QAAQ,QAAQ,CAAC;UAClC,QAAQ,KAAK,KAAK,QAAQ,SAAS,CAAC;UACpC,oBAAoB;QAAA;QAExB,QAAQ,QAAQ;QAChB,OAAO,gBAAgB,kBAAkB,gBAAgB,WAAW,gBAAgB;QACpF,eAAe,QAAQ,gBAAgB;MAAA;AAG3C,mBAAa,KAAK,OAAO,cAAc,oBAAoB;IAC/D;AAEA,UAAM,iBAAiB,KAAK,OAAO,qBAAqB,CAAA,CAAE;AAE1D,UAAM,kBAAkB,SAAS,mBAAmB,CAAC;AAErD,aAAS,aAAa,GAAG,aAAa,iBAAiB,EAAE,YACzD;AACI,UAAI,UAAU,QAAQ,WAAW;QAC7B,cAAc;QACd,eAAe;QACf,WAAW;QACX,gBAAgB;QAChB,iBAAiB;MAAA,CACpB;AAED,UAAI,cAAc,iBAAiB,IAAI;AAEvC,eAAS,IAAI,GAAG,IAAI,QAAQ,eAAe,EAAE,GAC7C;AACI,cAAM,UAAU,WAAW,WAAW;UAClC,cAAc;UACd,eAAe;UACf,WAAW;UACX,gBAAgB;UAChB,iBAAiB;QAAA,CACpB;AAED,cAAM,cAAc,eAAe,gBAAgB;UAC/C,kBAAkB,CAAC;YACf,MAAM;YACN,SAAS;YACT,QAAQ;YACR,YAAY,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAA;UAAE,CACxC;QAAA,CACJ;AAED,cAAM,YAAY,KAAK,OAAO,gBAAgB;UAC1C,QAAQ;UACR,SAAS,CAAC;YACN,SAAS;YACT,UAAU,KAAK;UAAA,GAChB;YACC,SAAS;YACT,UAAU;UAAA,CACb;QAAA,CACJ;AAED,oBAAY,YAAY,QAAQ;AAChC,oBAAY,aAAa,GAAG,SAAS;AACrC,oBAAY,KAAK,GAAG,GAAG,GAAG,CAAC;AAE3B,oBAAY,IAAA;AAEZ,kBAAU;MACd;IACJ;AAIA,QAAI,CAAC,gBACL;AACI,YAAM,eAAe;QACjB,OAAO,KAAK,KAAK,QAAQ,QAAQ,CAAC;QAClC,QAAQ,KAAK,KAAK,QAAQ,SAAS,CAAC;QACpC,oBAAoB;MAAA;AAGxB,eAAS,IAAI,GAAG,IAAI,QAAQ,eAAe,EAAE,GAC7C;AACI,uBAAe,qBAAqB;UAChC,SAAS;UACT,UAAU,IAAI;QAAA,GACf;UACC;UACA,UAAU;QAAA,GACX,YAAY;AAEf,qBAAa,QAAQ,KAAK,KAAK,aAAa,QAAQ,CAAC;AACrD,qBAAa,SAAS,KAAK,KAAK,aAAa,SAAS,CAAC;MAC3D;IACJ;AAEA,SAAK,OAAO,MAAM,OAAO,CAAC,eAAe,OAAA,CAAQ,CAAC;AAElD,QAAI,CAAC,gBACL;AACI,iBAAW,QAAA;IACf;AAEA,WAAO;EACX;AACJ;;;ACpLO,IAAM,oBAAN,MACP;EAII,YAAY,YACZ;AAHA,SAAO,cAA8B;AAIjC,SAAK,aAAa;EACtB;;EAGO,UACP;AACI,SAAK,WAAW,QAAA;AAChB,SAAK,cAAc;AACnB,SAAK,aAAa;EACtB;AACJ;AAOO,IAAM,mBAAN,MACP;EAyBI,YAAY,UACZ;AAhBA,SAAQ,eAA2C,uBAAO,OAAO,IAAI;AACrE,SAAQ,iBAA4C,uBAAO,OAAO,IAAI;AAgBlE,SAAK,YAAY;AACjB,aAAS,GAAG,cAAc,MAAM,kBAAkB,MAAM;AAExD,SAAK,mBAAmB,IAAI,cAAc;MACtC;MACA,MAAM;MACN,UAAU,KAAK,eAAe,KAAK,IAAI;MACvC,MAAM;IAAA,CACT;AAED,UAAM,gBAAgB;MAClB,OAAO;MACP,QAAQ;MACR,OAAO;MACP,YAAY;IAAA;AAGhB,SAAK,WAAW;MACZ,GAAG;MACH,MAAM,mCAAmC,aAAa;IAAA;EAE9D;;;;EAzBA,IAAW,kBAA6C;AAAE,WAAO,OAAO,OAAO,KAAK,iBAAiB,KAAK;EAAG;EA2BnG,cAAc,KACxB;AACI,SAAK,OAAO;EAChB;;;;;;EAOO,WAAW,QAClB;;AACI,aAAQ,YAAO,SAAS,KAAK,UAAU,GAAG,MAAlC,mBAA2D,eAAc,KAAK,YAAY,MAAM;EAC5G;EAEQ,YAAY,QACpB;AACI,QAAI,OAAO,qBACX;AACI,YAAM,mBAAmB,KAAK,IAAI,OAAO,YAAY,OAAO,WAAW;AAEvE,aAAO,gBAAgB,KAAK,MAAM,KAAK,KAAK,gBAAgB,CAAC,IAAI;IACrE;AAEA,QAAI,QAAQ,gBAAgB,kBAAkB,gBAAgB;AAE9D,QAAI,OAAO,mBAAmB,cAC9B;AACI,eAAS,gBAAgB;AACzB,eAAS,gBAAgB;IAC7B;AAEA,UAAM,YAAY,aAAa,OAAO,MAAM,KAAK,EAAE,YAAY,GAAG,YAAY,GAAG,aAAa,EAAA;AAE9F,UAAM,QAAQ,KAAK,KAAK,OAAO,aAAa,UAAU,UAAU,IAAI,UAAU;AAC9E,UAAM,SAAS,KAAK,KAAK,OAAO,cAAc,UAAU,WAAW,IAAI,UAAU;AAEjF,UAAM,oBAA0C;MAC5C,OAAO,OAAO;MACd,MAAM,EAAE,OAAO,QAAQ,oBAAoB,OAAO,gBAAA;MAClD,QAAQ,OAAO;MACf,aAAa,OAAO;MACpB,eAAe,OAAO;MACtB,WAAW,OAAO;MAClB;IAAA;AAGJ,UAAM,aAAa,KAAK,KAAK,OAAO,cAAc,iBAAiB;AAEnE,WAAO,SAAS,KAAK,UAAU,GAAG,IAAI,IAAI,kBAAkB,UAAU;AAEtE,UAAM,QAAQ,KAAK,iBAAiB,IAAI,MAAM;AAE9C,QAAI,OACJ;AACI,aAAO,GAAG,UAAU,KAAK,gBAAgB,IAAI;AAC7C,aAAO,GAAG,UAAU,KAAK,gBAAgB,IAAI;AAC7C,aAAO,GAAG,iBAAiB,KAAK,iBAAiB,IAAI;IACzD;AAEA,SAAK,eAAe,MAAM;AAE1B,WAAO;EACX;EAEU,eAAe,QACzB;AACI,UAAM,aAAa,KAAK,aAAa,MAAM;AAG3C,QAAI,CAAC,WAAY;AAEjB,QAAI,KAAK,SAAS,OAAO,cAAc,GACvC;AACI,WAAK,SAAS,OAAO,cAAc,EAAE,OAAO,QAAQ,YAAY,KAAK,IAAI;IAC7E;AAEA,QAAI,OAAO,uBAAuB,OAAO,gBAAgB,GACzD;AACI,WAAK,gBAAgB,MAAM;IAC/B;EACJ;EAEU,gBAAgB,QAC1B;AACI,QAAI,CAAC,KAAK,kBACV;AACI,WAAK,mBAAmB,IAAI,mBAAmB,KAAK,KAAK,MAAM;IACnE;AAEA,UAAM,aAAa,KAAK,aAAa,MAAM;AAE3C,SAAK,iBAAiB,eAAe,UAAU;EACnD;EAEU,eAAe,QACzB;AACI,WAAO,IAAI,UAAU,KAAK,gBAAgB,IAAI;AAC9C,WAAO,IAAI,UAAU,KAAK,gBAAgB,IAAI;AAC9C,WAAO,IAAI,iBAAiB,KAAK,iBAAiB,IAAI;EAC1D;EAEU,eAAe,QACzB;AACI,WAAO,cAAc,KAAK,UAAU,GAAG;AAEvC,UAAM,UAAU,OAAO,SAAS,KAAK,UAAU,GAAG;AAClD,UAAM,aAAa,mCAAS;AAE5B,QAAI,CAAC,YACL;AACI,WAAK,WAAW,MAAM;IAC1B,WACS,WAAW,UAAU,OAAO,cAAc,WAAW,WAAW,OAAO,aAChF;AACI,cAAQ,QAAA;AACR,WAAK,eAAe,OAAO,GAAG,IAAI;AAClC,aAAO,SAAS,KAAK,UAAU,GAAG,IAAI;AACtC,WAAK,WAAW,MAAM;IAC1B;EACJ;EAEQ,aAAa,SACrB;AACI,SAAK,aAAa,QAAQ,WAAW,IAAI,KAAK,KAAK,OAAO,cAAc,OAAO;AAE/E,WAAO,KAAK,aAAa,QAAQ,WAAW;EAChD;EAEO,cAAc,SACrB;AACI,WAAO,KAAK,aAAa,QAAQ,WAAW,KAAK,KAAK,aAAa,OAAO;EAC9E;EAEO,aAAa,QACpB;;AACI,WAAO,cAAc,KAAK,UAAU,GAAG;AAEvC,aAAQ,YAAO,SAAS,KAAK,UAAU,GAAG,MAAlC,mBAA2D,eAAc,KAAK,WAAW,MAAM;EAC3G;;;;;;;;;;EAWO,oBAAoB,SAC3B;AACI,WAAO,KAAK,eAAe,QAAQ,GAAG,KAAK,KAAK,wBAAwB,OAAO;EACnF;EAEQ,wBAAwB,SAChC;AACI,UAAM,SAAS,QAAQ;AAEvB,SAAK,eAAe,QAAQ,GAAG,IAAI,IAAI,UAAU;MAC7C,GAAG;MACH,GAAG,OAAO;MACV,GAAG,IAAI,aAAa;QAChB,gBAAgB,EAAE,MAAM,eAAe,OAAO,QAAQ,cAAc,SAAA;MAAS,CAChF;IAAA,CACJ;AAED,WAAO,KAAK,eAAe,QAAQ,GAAG;EAC1C;EAEO,eAAe,SACtB;AACI,UAAM,SAAS,QAAQ;AAEvB,WAAO,cAAc,KAAK,UAAU,GAAG;AACvC,QAAI,UAAU,OAAO,SAAS,KAAK,UAAU,GAAG;AAEhD,QAAI,CAAC,SACL;AACI,WAAK,WAAW,MAAM;AACtB,gBAAU,OAAO,SAAS,KAAK,UAAU,GAAG;IAChD;AAEA,YAAQ,gBAAR,QAAQ,cAAgB,QAAQ,WAAW,WAAW,EAAE,WAAW,OAAO,cAAA,CAAe;AAEzF,WAAO,QAAQ;EACnB;EAEO,eAAe,SACtB;AACI,UAAM,WAAW,KAAK;AAEtB,UAAM,iBAAiB,SAAS,IAAI,OAAO,qBAAA;AAG3C,UAAM,SAAS,WAAW,IAAA,EAAM,aAAA;AAEhC,WAAO,QAAQ,QAAQ,OAAO;AAC9B,WAAO,SAAS,QAAQ,OAAO;AAE/B,UAAM,UAAU,OAAO,WAAW,QAAQ;AAE1C,YAAQ,UAAU;MACd,QAAQ,SAAS,IAAI;MAErB,OAAO,gBAAgB,WAAW,gBAAgB;MAClD,QAAQ,WAAW,IAAA,EAAM,aAAA,EAAe,IAAI,yBAAA;MAC5C,WAAW;IAAA,CACd;AAED,mBAAe,qBAAqB;MAChC,SAAS,SAAS,QAAQ,aAAa,QAAQ,MAAM;MACrD,QAAQ;QACJ,GAAG;QACH,GAAG;MAAA;IACP,GACD;MACC,SAAS,QAAQ,kBAAA;IAAkB,GACpC;MACC,OAAO,OAAO;MACd,QAAQ,OAAO;IAAA,CAClB;AAED,aAAS,IAAI,OAAO,MAAM,OAAO,CAAC,eAAe,OAAA,CAAQ,CAAC;AAE1D,WAAO;EACX;EAEO,UAAU,SACjB;AACI,UAAM,eAAe,KAAK,eAAe,OAAO;AAEhD,UAAM,mBAAmB,WAAW,2BAA2B,aAAa,OAAO,aAAa,MAAM;AAEtG,UAAM,UAAU,iBAAiB;AAEjC,YAAQ,UAAU,cAAc,GAAG,CAAC;AAEpC,UAAM,EAAE,OAAO,OAAA,IAAW;AAE1B,UAAM,YAAY,QAAQ,aAAa,GAAG,GAAG,OAAO,MAAM;AAE1D,UAAM,SAAS,IAAI,kBAAkB,UAAU,KAAK,MAAM;AAE1D,eAAW,uBAAuB,gBAAgB;AAElD,WAAO,EAAE,QAAQ,OAAO,OAAA;EAC5B;EAEO,UACP;AACI,SAAK,iBAAiB,QAAA;AACtB,eAAW,KAAK,OAAO,KAAK,KAAK,cAAc,GAC/C;AACI,YAAM,MAAM,OAAO,CAAC;AACpB,YAAM,YAAY,KAAK,eAAe,GAAG;AAEzC,6CAAW;IACf;AAEC,SAAK,YAAqB;AAC3B,SAAK,OAAO;AACZ,SAAK,mBAAmB;AACxB,SAAK,eAAe;AACpB,SAAK,iBAAiB;EAC1B;AACJ;AA7Ta,iBAGK,YAAY;EACtB,MAAM;IACF,cAAc;EAAA;EAElB,MAAM;AACV;;;AChCJ,IAAM,uBAAuB;EACzB,GAAG;EACH;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AACA,IAAM,qBAAqB,CAAC,GAAG,mBAAmB,mBAAmB;AACrE,IAAM,wBAAwB,CAAC,iBAAiB,gBAAgB,kBAAkB;AAGlF,IAAM,UAAwD,CAAA;AAC9D,IAAM,cAA0D,CAAA;AAChE,IAAM,qBAAqD,CAAA;AAE3D,WAAW,kBAAkB,cAAc,cAAc,OAAO;AAChE,WAAW,kBAAkB,cAAc,aAAa,WAAW;AACnE,WAAW,kBAAkB,cAAc,oBAAoB,kBAAkB;AAGjF,WAAW,IAAI,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,qBAAqB;AAiGhF,IAAM,iBAAN,cACK,iBAEZ;EAII,cACA;AACI,UAAM,eAAe;MACjB,MAAM;MACN,MAAM,aAAa;MACnB;MACA;MACA;IAAA;AAGJ,UAAM,YAAY;EACtB;AACJ;",
  "names": ["minUniformOffsetAlignment"]
}
