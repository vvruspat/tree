{
  "version": 3,
  "sources": ["../../pixi.js/src/rendering/renderers/canvas/utils/canUseNewCanvasBlendModes.ts", "../../pixi.js/src/rendering/renderers/canvas/utils/canvasUtils.ts", "../../pixi.js/src/scene/graphics/canvas/CanvasGraphicsAdaptor.ts", "../../pixi.js/src/rendering/batcher/canvas/CanvasBatchAdaptor.ts", "../../pixi.js/src/rendering/mask/color/CanvasColorMaskPipe.ts", "../../pixi.js/src/scene/graphics/canvas/CanvasGraphicsContextSystem.ts", "../../pixi.js/src/scene/graphics/canvas/CanvasGraphicsPipe.ts", "../../pixi.js/src/scene/graphics/shared/GraphicsPipe.ts", "../../pixi.js/src/scene/graphics/init.ts", "../../pixi.js/src/scene/graphics/shared/Graphics.ts", "../../pixi.js/src/rendering/mask/stencil/CanvasStencilMaskPipe.ts", "../../pixi.js/src/rendering/renderers/canvas/utils/mapCanvasBlendModesToPixi.ts", "../../pixi.js/src/rendering/renderers/canvas/CanvasContextSystem.ts", "../../pixi.js/src/rendering/renderers/canvas/CanvasLimitsSystem.ts", "../../pixi.js/src/rendering/renderers/canvas/renderTarget/CanvasRenderTargetAdaptor.ts", "../../pixi.js/src/rendering/renderers/canvas/renderTarget/CanvasRenderTargetSystem.ts", "../../pixi.js/src/rendering/renderers/canvas/texture/CanvasTextureSystem.ts", "../../pixi.js/src/rendering/renderers/canvas/CanvasRenderer.ts"],
  "sourcesContent": ["import { DOMAdapter } from '../../../../environment/adapter';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\n\nlet canUseNewCanvasBlendModesValue: boolean | undefined;\n\nfunction createColoredCanvas(color: string): ICanvas\n{\n    const canvas = DOMAdapter.get().createCanvas(6, 1);\n    const context = canvas.getContext('2d');\n\n    context.fillStyle = color;\n    context.fillRect(0, 0, 6, 1);\n\n    return canvas;\n}\n\n/**\n * Checks whether advanced Canvas blend modes are supported.\n * @returns True if advanced blend modes are available.\n * @internal\n */\nexport function canUseNewCanvasBlendModes(): boolean\n{\n    if (canUseNewCanvasBlendModesValue !== undefined)\n    {\n        return canUseNewCanvasBlendModesValue;\n    }\n\n    try\n    {\n        const magenta = createColoredCanvas('#ff00ff');\n        const yellow = createColoredCanvas('#ffff00');\n\n        const canvas = DOMAdapter.get().createCanvas(6, 1);\n        const context = canvas.getContext('2d');\n\n        context.globalCompositeOperation = 'multiply';\n        context.drawImage(magenta as unknown as CanvasImageSource, 0, 0);\n        context.drawImage(yellow as unknown as CanvasImageSource, 2, 0);\n\n        const imageData = context.getImageData(2, 0, 1, 1);\n\n        if (!imageData)\n        {\n            canUseNewCanvasBlendModesValue = false;\n        }\n        else\n        {\n            const data = imageData.data;\n\n            canUseNewCanvasBlendModesValue = (data[0] === 255 && data[1] === 0 && data[2] === 0);\n        }\n    }\n    catch (_error)\n    {\n        canUseNewCanvasBlendModesValue = false;\n    }\n\n    return canUseNewCanvasBlendModesValue;\n}\n", "import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { canUseNewCanvasBlendModes } from './canUseNewCanvasBlendModes';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ImageLike } from '../../../../environment/ImageLike';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { Texture } from '../../shared/texture/Texture';\n\ntype TintCache = Record<string, (ICanvas & { tintId?: number }) | (ImageLike & { tintId?: number })>;\ntype CanvasSourceCache = {\n    canvas: ICanvas;\n    resourceId: number;\n};\n\n/**\n * Canvas helper utilities for tinting and pattern generation.\n * @internal\n */\nexport const canvasUtils = {\n    canvas: null as ICanvas | null,\n    convertTintToImage: false,\n    cacheStepsPerColorChannel: 8,\n    canUseMultiply: canUseNewCanvasBlendModes(),\n    tintMethod: null as (texture: Texture, color: number, canvas: ICanvas) => void,\n    _canvasSourceCache: new WeakMap<TextureSource, CanvasSourceCache>(),\n    _unpremultipliedCache: new WeakMap<TextureSource, CanvasSourceCache>(),\n    getCanvasSource: (texture: Texture): CanvasImageSource | null =>\n    {\n        const source = texture.source;\n        const resource = source?.resource as unknown;\n\n        if (!resource)\n        {\n            return null;\n        }\n\n        const isPMA = source.alphaMode === 'premultiplied-alpha';\n\n        const resourceWidth = source.resourceWidth ?? source.pixelWidth;\n        const resourceHeight = source.resourceHeight ?? source.pixelHeight;\n        const needsResize = resourceWidth !== source.pixelWidth || resourceHeight !== source.pixelHeight;\n\n        if (isPMA)\n        {\n            // If the resource is a canvas, we can assume it's already in a format that the context handles correctly\n            if (resource instanceof HTMLCanvasElement\n                || (typeof OffscreenCanvas !== 'undefined' && resource instanceof OffscreenCanvas))\n            {\n                if (!needsResize)\n                {\n                    return resource as CanvasImageSource;\n                }\n            }\n\n            const cached = canvasUtils._unpremultipliedCache.get(source);\n\n            if (cached?.resourceId === source._resourceId)\n            {\n                return cached.canvas as unknown as CanvasImageSource;\n            }\n        }\n\n        if (resource instanceof Uint8Array\n            || resource instanceof Uint8ClampedArray\n            || resource instanceof Int8Array\n            || resource instanceof Uint16Array\n            || resource instanceof Int16Array\n            || resource instanceof Uint32Array\n            || resource instanceof Int32Array\n            || resource instanceof Float32Array\n            || resource instanceof ArrayBuffer)\n        {\n            const cached = canvasUtils._canvasSourceCache.get(source);\n\n            if (cached?.resourceId === source._resourceId)\n            {\n                return cached.canvas as unknown as CanvasImageSource;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n            const context = canvas.getContext('2d');\n            const imageData = context.createImageData(source.pixelWidth, source.pixelHeight);\n            const data = imageData.data;\n\n            const bytes = resource instanceof ArrayBuffer\n                ? new Uint8Array(resource)\n                : new Uint8Array(resource.buffer, resource.byteOffset, resource.byteLength);\n\n            if (source.format === 'bgra8unorm')\n            {\n                for (let i = 0; i < data.length && i + 3 < bytes.length; i += 4)\n                {\n                    data[i] = bytes[i + 2];\n                    data[i + 1] = bytes[i + 1];\n                    data[i + 2] = bytes[i];\n                    data[i + 3] = bytes[i + 3];\n                }\n            }\n            else\n            {\n                data.set(bytes.subarray(0, data.length));\n            }\n\n            context.putImageData(imageData, 0, 0);\n\n            canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });\n\n            return canvas as unknown as CanvasImageSource;\n        }\n\n        if (isPMA)\n        {\n            const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n            const context = canvas.getContext('2d', { willReadFrequently: true });\n\n            canvas.width = source.pixelWidth;\n            canvas.height = source.pixelHeight;\n\n            context.drawImage(resource as CanvasImageSource, 0, 0);\n\n            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n            const data = imageData.data;\n\n            for (let i = 0; i < data.length; i += 4)\n            {\n                const a = data[i + 3];\n\n                if (a > 0)\n                {\n                    const alphaInv = 255 / a;\n\n                    data[i] = Math.min(255, (data[i] * alphaInv) + 0.5);\n                    data[i + 1] = Math.min(255, (data[i + 1] * alphaInv) + 0.5);\n                    data[i + 2] = Math.min(255, (data[i + 2] * alphaInv) + 0.5);\n                }\n            }\n\n            context.putImageData(imageData, 0, 0);\n\n            canvasUtils._unpremultipliedCache.set(source, { canvas, resourceId: source._resourceId });\n\n            return canvas as unknown as CanvasImageSource;\n        }\n\n        if (needsResize)\n        {\n            const cached = canvasUtils._canvasSourceCache.get(source);\n\n            if (cached?.resourceId === source._resourceId)\n            {\n                return cached.canvas as unknown as CanvasImageSource;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n            const context = canvas.getContext('2d');\n\n            canvas.width = source.pixelWidth;\n            canvas.height = source.pixelHeight;\n\n            context.drawImage(resource as CanvasImageSource, 0, 0);\n\n            canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });\n\n            return canvas as unknown as CanvasImageSource;\n        }\n\n        return resource as CanvasImageSource;\n    },\n\n    getTintedCanvas: (sprite: { texture: Texture }, color: number): ICanvas | ImageLike =>\n    {\n        const texture = sprite.texture;\n        const stringColor = Color.shared.setValue(color).toHex();\n        const cache = (texture as any).tintCache as TintCache || ((texture as any).tintCache = {});\n\n        const cachedCanvas = cache[stringColor];\n        const resourceId = texture.source._resourceId;\n\n        if (cachedCanvas?.tintId === resourceId)\n        {\n            return cachedCanvas;\n        }\n\n        const canvas = (cachedCanvas && 'getContext' in cachedCanvas)\n            ? (cachedCanvas as ICanvas)\n            : DOMAdapter.get().createCanvas();\n\n        canvasUtils.tintMethod(texture, color, canvas);\n\n        (canvas as any).tintId = resourceId;\n\n        if (canvasUtils.convertTintToImage && canvas.toDataURL !== undefined)\n        {\n            const tintImage = DOMAdapter.get().createImage();\n\n            tintImage.src = canvas.toDataURL();\n            (tintImage as any).tintId = resourceId;\n\n            cache[stringColor] = tintImage as any;\n        }\n        else\n        {\n            cache[stringColor] = canvas;\n        }\n\n        return cache[stringColor];\n    },\n\n    getTintedPattern: (texture: Texture, color: number): CanvasPattern =>\n    {\n        const stringColor = Color.shared.setValue(color).toHex();\n        const cache = (texture as any).patternCache as Record<string, CanvasPattern & { tintId?: number }>\n            || ((texture as any).patternCache = {});\n        const resourceId = texture.source._resourceId;\n\n        let pattern = cache[stringColor];\n\n        if (pattern?.tintId === resourceId)\n        {\n            return pattern;\n        }\n\n        if (!canvasUtils.canvas)\n        {\n            canvasUtils.canvas = DOMAdapter.get().createCanvas();\n        }\n\n        // Always use tintMethod to handle frame cropping correctly (matching v7 approach)\n        canvasUtils.tintMethod(texture, color, canvasUtils.canvas);\n\n        const context = canvasUtils.canvas.getContext('2d');\n\n        pattern = context.createPattern(canvasUtils.canvas, 'repeat');\n\n        pattern.tintId = resourceId;\n        cache[stringColor] = pattern;\n\n        return pattern;\n    },\n\n    /**\n     * Applies a transform to a CanvasPattern.\n     * @param pattern - The pattern to apply the transform to.\n     * @param matrix - The matrix to apply.\n     * @param matrix.a\n     * @param matrix.b\n     * @param matrix.c\n     * @param matrix.d\n     * @param matrix.tx\n     * @param matrix.ty\n     * @param invert\n     */\n    applyPatternTransform: (\n        pattern: CanvasPattern,\n        matrix: {\n            a: number,\n            b: number,\n            c: number,\n            d: number,\n            tx: number,\n            ty: number\n        },\n        invert = true\n    ): void =>\n    {\n        if (!matrix) return;\n\n        const patternAny = pattern as unknown as { setTransform?: (value: DOMMatrix) => void };\n\n        if (!patternAny.setTransform) return;\n\n        const DOMMatrixCtor = (globalThis as { DOMMatrix?: typeof DOMMatrix }).DOMMatrix;\n\n        if (!DOMMatrixCtor) return;\n\n        const domMatrix = new DOMMatrixCtor([matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty]);\n\n        patternAny.setTransform(invert ? domMatrix.inverse() : domMatrix);\n    },\n\n    tintWithMultiply: (texture: Texture, color: number, canvas: ICanvas): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture.frame.clone();\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n        const rotate = texture.rotate;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        // When texture is rotated 90° or 270°, output dimensions are swapped\n        const isVertical = groupD8.isVertical(rotate);\n        const outWidth = isVertical ? crop.height : crop.width;\n        const outHeight = isVertical ? crop.width : crop.height;\n\n        canvas.width = Math.ceil(outWidth);\n        canvas.height = Math.ceil(outHeight);\n\n        context.save();\n        context.fillStyle = Color.shared.setValue(color).toHex();\n        context.fillRect(0, 0, outWidth, outHeight);\n\n        context.globalCompositeOperation = 'multiply';\n\n        const source = canvasUtils.getCanvasSource(texture);\n\n        if (!source)\n        {\n            context.restore();\n\n            return;\n        }\n\n        // Apply inverse rotation to compensate for spritesheet packing\n        if (rotate)\n        {\n            canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n        }\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.globalCompositeOperation = 'destination-atop';\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n    },\n\n    tintWithOverlay: (texture: Texture, color: number, canvas: ICanvas): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture.frame.clone();\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n        const rotate = texture.rotate;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        // When texture is rotated 90° or 270°, output dimensions are swapped\n        const isVertical = groupD8.isVertical(rotate);\n        const outWidth = isVertical ? crop.height : crop.width;\n        const outHeight = isVertical ? crop.width : crop.height;\n\n        canvas.width = Math.ceil(outWidth);\n        canvas.height = Math.ceil(outHeight);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.fillStyle = Color.shared.setValue(color).toHex();\n        context.fillRect(0, 0, outWidth, outHeight);\n\n        context.globalCompositeOperation = 'destination-atop';\n        const source = canvasUtils.getCanvasSource(texture);\n\n        if (!source)\n        {\n            context.restore();\n\n            return;\n        }\n\n        // Apply inverse rotation to compensate for spritesheet packing\n        if (rotate)\n        {\n            canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n        }\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n    },\n\n    tintWithPerPixel: (texture: Texture, color: number, canvas: ICanvas): void =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture.frame.clone();\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n        const rotate = texture.rotate;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        // When texture is rotated 90° or 270°, output dimensions are swapped\n        const isVertical = groupD8.isVertical(rotate);\n        const outWidth = isVertical ? crop.height : crop.width;\n        const outHeight = isVertical ? crop.width : crop.height;\n\n        canvas.width = Math.ceil(outWidth);\n        canvas.height = Math.ceil(outHeight);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        const source = canvasUtils.getCanvasSource(texture);\n\n        if (!source)\n        {\n            context.restore();\n\n            return;\n        }\n\n        // Apply inverse rotation to compensate for spritesheet packing\n        if (rotate)\n        {\n            canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n        }\n\n        context.drawImage(\n            source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.restore();\n\n        const r = (color >> 16) & 0xFF;\n        const g = (color >> 8) & 0xFF;\n        const b = color & 0xFF;\n\n        const imageData = context.getImageData(0, 0, outWidth, outHeight);\n        const data = imageData.data;\n\n        for (let i = 0; i < data.length; i += 4)\n        {\n            data[i] = (data[i] * r) / 255;\n            data[i + 1] = (data[i + 1] * g) / 255;\n            data[i + 2] = (data[i + 2] * b) / 255;\n        }\n\n        context.putImageData(imageData, 0, 0);\n    },\n\n    /**\n     * Applies inverse rotation transform to context for texture packer rotation compensation.\n     * Supports all 16 groupD8 symmetries (rotations and reflections).\n     * @param context - Canvas 2D context\n     * @param rotate - The groupD8 rotation value\n     * @param srcWidth - Source crop width (before rotation)\n     * @param srcHeight - Source crop height (before rotation)\n     */\n    _applyInverseRotation: (\n        context: ICanvasRenderingContext2D,\n        rotate: number,\n        srcWidth: number,\n        srcHeight: number\n    ): void =>\n    {\n        // Get inverse rotation matrix components using groupD8 utilities\n        const inv = groupD8.inv(rotate);\n        const a = groupD8.uX(inv);\n        const b = groupD8.uY(inv);\n        const c = groupD8.vX(inv);\n        const d = groupD8.vY(inv);\n\n        // Calculate translation to keep content at origin after transform\n        // Same approach as matrixAppendRotationInv\n        const tx = -Math.min(0, a * srcWidth, c * srcHeight, (a * srcWidth) + (c * srcHeight));\n        const ty = -Math.min(0, b * srcWidth, d * srcHeight, (b * srcWidth) + (d * srcHeight));\n\n        context.transform(a, b, c, d, tx, ty);\n    },\n};\n\ncanvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { groupD8 } from '../../../maths/matrix/groupD8';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { canvasUtils } from '../../../rendering/renderers/canvas/utils/canvasUtils';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { bgr2rgb } from '../../container/container-mixins/getGlobalMixin';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\nimport { buildLine } from '../shared/buildCommands/buildLine';\nimport { FillGradient } from '../shared/fill/FillGradient';\nimport { FillPattern } from '../shared/fill/FillPattern';\nimport { shapeBuilders } from '../shared/utils/buildContextBatches';\nimport { generateTextureMatrix as generateTextureFillMatrix } from '../shared/utils/generateTextureFillMatrix';\n\nimport type { ShapePrimitive } from '../../../maths/shapes/ShapePrimitive';\nimport type { CrossPlatformCanvasRenderingContext2D } from '../../../rendering/renderers/canvas/CanvasContextSystem';\nimport type { CanvasRenderer } from '../../../rendering/renderers/canvas/CanvasRenderer';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../shared/FillTypes';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipeLike } from '../shared/GraphicsPipe';\nimport type { ShapePrimitiveWithHoles } from '../shared/path/ShapePath';\n\nconst emptyCanvasStyle = '#808080';\nconst tempMatrix = new Matrix();\nconst tempTextureMatrix = new Matrix();\nconst tempGradientMatrix = new Matrix();\nconst tempPatternMatrix = new Matrix();\n\nfunction fillTriangles(\n    context: CrossPlatformCanvasRenderingContext2D,\n    vertices: number[],\n    indices: number[]\n): void\n{\n    context.beginPath();\n\n    for (let i = 0; i < indices.length; i += 3)\n    {\n        const i0 = indices[i] * 2;\n        const i1 = indices[i + 1] * 2;\n        const i2 = indices[i + 2] * 2;\n\n        context.moveTo(vertices[i0], vertices[i0 + 1]);\n        context.lineTo(vertices[i1], vertices[i1 + 1]);\n        context.lineTo(vertices[i2], vertices[i2 + 1]);\n        context.closePath();\n    }\n\n    context.fill();\n}\n\nfunction colorToHex(color: number): string\n{\n    const clamped = color & 0xFFFFFF;\n\n    return `#${clamped.toString(16).padStart(6, '0')}`;\n}\n\nfunction buildRoundedRectPath(\n    context: CrossPlatformCanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number\n): void\n{\n    radius = Math.max(0, Math.min(radius, Math.min(width, height) / 2));\n\n    context.moveTo(x + radius, y);\n    context.lineTo(x + width - radius, y);\n    context.quadraticCurveTo(x + width, y, x + width, y + radius);\n    context.lineTo(x + width, y + height - radius);\n    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    context.lineTo(x + radius, y + height);\n    context.quadraticCurveTo(x, y + height, x, y + height - radius);\n    context.lineTo(x, y + radius);\n    context.quadraticCurveTo(x, y, x + radius, y);\n}\n\nfunction buildShapePath(context: CrossPlatformCanvasRenderingContext2D, shape: ShapePrimitive): void\n{\n    switch (shape.type)\n    {\n        case 'rectangle':\n        {\n            const rect = shape as typeof shape & { width: number; height: number };\n\n            context.rect(rect.x, rect.y, rect.width, rect.height);\n            break;\n        }\n        case 'roundedRectangle':\n        {\n            const rect = shape as typeof shape & { width: number; height: number; radius: number };\n\n            buildRoundedRectPath(context, rect.x, rect.y, rect.width, rect.height, rect.radius);\n            break;\n        }\n        case 'circle':\n        {\n            const circle = shape as typeof shape & { radius: number };\n\n            context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);\n            break;\n        }\n        case 'ellipse':\n        {\n            const ellipse = shape as typeof shape & { halfWidth: number; halfHeight: number };\n\n            if (context.ellipse)\n            {\n                context.ellipse(ellipse.x, ellipse.y, ellipse.halfWidth, ellipse.halfHeight, 0, 0, Math.PI * 2);\n            }\n            else\n            {\n                context.save();\n                context.translate(ellipse.x, ellipse.y);\n                context.scale(ellipse.halfWidth, ellipse.halfHeight);\n                context.arc(0, 0, 1, 0, Math.PI * 2);\n                context.restore();\n            }\n            break;\n        }\n        case 'triangle':\n        {\n            const tri = shape as typeof shape & { x2: number; y2: number; x3: number; y3: number };\n\n            context.moveTo(tri.x, tri.y);\n            context.lineTo(tri.x2, tri.y2);\n            context.lineTo(tri.x3, tri.y3);\n            context.closePath();\n            break;\n        }\n        case 'polygon':\n        default:\n        {\n            const poly = shape as typeof shape & { points: number[]; closePath: boolean };\n            const points = poly.points;\n\n            if (!points?.length) break;\n\n            context.moveTo(points[0], points[1]);\n\n            for (let i = 2; i < points.length; i += 2)\n            {\n                context.lineTo(points[i], points[i + 1]);\n            }\n\n            if (poly.closePath)\n            {\n                context.closePath();\n            }\n            break;\n        }\n    }\n}\n\nfunction addHolePaths(context: CrossPlatformCanvasRenderingContext2D, holes?: ShapePrimitiveWithHoles[]): boolean\n{\n    if (!holes?.length) return false;\n\n    for (let i = 0; i < holes.length; i++)\n    {\n        const hole = holes[i];\n\n        if (!hole?.shape) continue;\n\n        const transform = hole.transform;\n        const hasTransform = transform && !transform.isIdentity();\n\n        if (hasTransform)\n        {\n            context.save();\n            context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n        }\n\n        buildShapePath(context, hole.shape);\n\n        if (hasTransform)\n        {\n            context.restore();\n        }\n    }\n\n    return true;\n}\n\nfunction getCanvasStyle(\n    style: ConvertedFillStyle,\n    tint: number,\n    textureMatrix?: Matrix,\n    currentTransform?: Matrix\n): string | CanvasPattern | CanvasGradient\n{\n    const fill = style.fill;\n\n    if (fill instanceof FillGradient)\n    {\n        fill.buildGradient();\n\n        const gradientTexture = fill.texture;\n\n        if (gradientTexture)\n        {\n            const pattern = canvasUtils.getTintedPattern(gradientTexture, tint);\n            const patternMatrix = textureMatrix\n                ? tempPatternMatrix\n                    .copyFrom(textureMatrix)\n                    .scale(gradientTexture.source.pixelWidth, gradientTexture.source.pixelHeight)\n                : tempPatternMatrix.copyFrom(fill.transform);\n\n            if (currentTransform && !style.textureSpace)\n            {\n                patternMatrix.append(currentTransform);\n            }\n\n            canvasUtils.applyPatternTransform(pattern, patternMatrix);\n\n            return pattern;\n        }\n    }\n\n    if (fill instanceof FillPattern)\n    {\n        const pattern = canvasUtils.getTintedPattern(fill.texture, tint);\n\n        canvasUtils.applyPatternTransform(pattern, fill.transform);\n\n        return pattern;\n    }\n\n    const texture = style.texture;\n\n    if (texture && texture !== Texture.WHITE)\n    {\n        if (!texture.source.resource)\n        {\n            return emptyCanvasStyle;\n        }\n\n        const pattern = canvasUtils.getTintedPattern(texture, tint);\n        const patternMatrix = textureMatrix\n            ? tempPatternMatrix\n                .copyFrom(textureMatrix)\n                .scale(texture.source.pixelWidth, texture.source.pixelHeight)\n            : style.matrix;\n\n        canvasUtils.applyPatternTransform(pattern, patternMatrix);\n\n        return pattern;\n    }\n\n    return colorToHex(tint);\n}\n\n/**\n * A GraphicsAdaptor that uses Canvas2D to render graphics.\n * @category rendering\n * @ignore\n */\nexport class CanvasGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader = null;\n\n    public contextChange(renderer: Renderer): void\n    {\n        void renderer;\n    }\n\n    public execute(graphicsPipe: GraphicsPipeLike, renderable: Graphics): void\n    {\n        const renderer = graphicsPipe.renderer as CanvasRenderer;\n        const contextSystem = renderer.canvasContext;\n        const context = contextSystem.activeContext;\n        const baseTransform = renderable.groupTransform;\n\n        const globalColor = renderer.globalUniforms.globalUniformData?.worldColor ?? 0xFFFFFFFF;\n        const groupColorAlpha = renderable.groupColorAlpha;\n\n        const globalAlpha = ((globalColor >>> 24) & 0xFF) / 255;\n        const groupAlphaValue = ((groupColorAlpha >>> 24) & 0xFF) / 255;\n\n        const filterAlpha = (renderer.filter as { alphaMultiplier?: number } | null)?.alphaMultiplier ?? 1;\n        const groupAlpha = globalAlpha * groupAlphaValue * filterAlpha;\n\n        if (groupAlpha <= 0) return;\n\n        const globalTint = globalColor & 0xFFFFFF;\n        const groupTintBGR = groupColorAlpha & 0xFFFFFF;\n\n        const groupTint = bgr2rgb(multiplyHexColors(groupTintBGR, globalTint));\n\n        const roundPixels = (renderer._roundPixels | renderable._roundPixels) as 0 | 1;\n\n        context.save();\n\n        contextSystem.setContextTransform(baseTransform, roundPixels === 1);\n        contextSystem.setBlendMode(renderable.groupBlendMode);\n\n        const instructions = renderable.context.instructions;\n\n        for (let i = 0; i < instructions.length; i++)\n        {\n            const instruction = instructions[i];\n\n            if (instruction.action === 'texture')\n            {\n                const data = instruction.data;\n                const texture = data.image;\n                const source = texture ? canvasUtils.getCanvasSource(texture) : null;\n\n                if (!source) continue;\n\n                const alpha = data.alpha * groupAlpha;\n\n                if (alpha <= 0) continue;\n\n                const tint = multiplyHexColors(data.style, groupTint);\n\n                context.globalAlpha = alpha;\n\n                let drawSource: CanvasImageSource = source;\n\n                if (tint !== 0xFFFFFF)\n                {\n                    drawSource = canvasUtils.getTintedCanvas({ texture }, tint) as CanvasImageSource;\n                }\n\n                const frame = texture.frame;\n                const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n\n                let sx = frame.x * resolution;\n                let sy = frame.y * resolution;\n                const sw = frame.width * resolution;\n                const sh = frame.height * resolution;\n\n                if (drawSource !== source)\n                {\n                    sx = 0;\n                    sy = 0;\n                }\n\n                const transform = data.transform;\n                const hasTransform = transform && !transform.isIdentity();\n                const rotate = texture.rotate;\n\n                if (hasTransform || rotate)\n                {\n                    tempMatrix.copyFrom(baseTransform);\n\n                    if (hasTransform)\n                    {\n                        tempMatrix.append(transform);\n                    }\n\n                    if (rotate)\n                    {\n                        groupD8.matrixAppendRotationInv(tempMatrix, rotate, data.dx, data.dy, data.dw, data.dh);\n                    }\n\n                    contextSystem.setContextTransform(tempMatrix, roundPixels === 1);\n                }\n                else\n                {\n                    contextSystem.setContextTransform(baseTransform, roundPixels === 1);\n                }\n\n                context.drawImage(\n                    drawSource,\n                    sx,\n                    sy,\n                    drawSource === source ? sw : (drawSource as any).width,\n                    drawSource === source ? sh : (drawSource as any).height,\n                    rotate ? 0 : data.dx,\n                    rotate ? 0 : data.dy,\n                    data.dw,\n                    data.dh\n                );\n\n                if (hasTransform || rotate)\n                {\n                    contextSystem.setContextTransform(baseTransform, roundPixels === 1);\n                }\n\n                continue;\n            }\n\n            const data = instruction.data;\n            const shapePath = data?.path?.shapePath;\n\n            if (!shapePath?.shapePrimitives?.length) continue;\n\n            const style = data.style as ConvertedFillStyle | ConvertedStrokeStyle;\n            const tint = multiplyHexColors(style.color, groupTint);\n            const alpha = style.alpha * groupAlpha;\n\n            if (alpha <= 0) continue;\n\n            const isStroke = instruction.action === 'stroke';\n\n            context.globalAlpha = alpha;\n\n            if (isStroke)\n            {\n                const strokeStyle = style as ConvertedStrokeStyle;\n\n                context.lineWidth = strokeStyle.width;\n                context.lineCap = strokeStyle.cap;\n                context.lineJoin = strokeStyle.join;\n                context.miterLimit = strokeStyle.miterLimit;\n            }\n\n            const shapePrimitives = shapePath.shapePrimitives;\n\n            if (!isStroke && data.hole?.shapePath?.shapePrimitives?.length)\n            {\n                const lastShape = shapePrimitives[shapePrimitives.length - 1];\n\n                lastShape.holes = data.hole.shapePath.shapePrimitives;\n            }\n\n            for (let j = 0; j < shapePrimitives.length; j++)\n            {\n                const primitive = shapePrimitives[j];\n\n                if (!primitive?.shape) continue;\n\n                const transform = primitive.transform;\n                const hasTransform = transform && !transform.isIdentity();\n                const hasTexture = style.texture && style.texture !== Texture.WHITE;\n                const textureTransform = style.textureSpace === 'global' ? transform : null;\n                const textureMatrix = hasTexture\n                    ? generateTextureFillMatrix(tempTextureMatrix, style, primitive.shape, textureTransform)\n                    : null;\n                const currentTransform = hasTransform\n                    ? tempGradientMatrix.copyFrom(baseTransform).append(transform)\n                    : baseTransform;\n                const canvasStyle = getCanvasStyle(\n                    style,\n                    tint,\n                    textureMatrix,\n                    currentTransform\n                );\n\n                if (hasTransform)\n                {\n                    context.save();\n                    context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n                }\n\n                if (isStroke)\n                {\n                    const strokeStyle = style as ConvertedStrokeStyle;\n                    const useStrokeGeometry = strokeStyle.alignment !== 0.5 && !strokeStyle.pixelLine;\n\n                    if (useStrokeGeometry)\n                    {\n                        const points: number[] = [];\n                        const vertices: number[] = [];\n                        const indices: number[] = [];\n                        const shapeBuilder = shapeBuilders[primitive.shape.type];\n\n                        if (shapeBuilder?.build(primitive.shape, points))\n                        {\n                            const close = (primitive.shape as { closePath?: boolean }).closePath ?? true;\n\n                            buildLine(points, strokeStyle, false, close, vertices, indices);\n                            context.fillStyle = canvasStyle as string | CanvasPattern | CanvasGradient;\n                            fillTriangles(context, vertices, indices);\n                        }\n                        else\n                        {\n                            context.strokeStyle = canvasStyle as string | CanvasPattern | CanvasGradient;\n                            context.beginPath();\n                            buildShapePath(context, primitive.shape);\n                            context.stroke();\n                        }\n                    }\n                    else\n                    {\n                        context.strokeStyle = canvasStyle as string | CanvasPattern | CanvasGradient;\n                        context.beginPath();\n                        buildShapePath(context, primitive.shape);\n                        context.stroke();\n                    }\n                }\n                else\n                {\n                    context.fillStyle = canvasStyle as string | CanvasPattern | CanvasGradient;\n                    context.beginPath();\n                    buildShapePath(context, primitive.shape);\n\n                    const hasHoles = addHolePaths(context, primitive.holes);\n\n                    if (hasHoles)\n                    {\n                        context.fill('evenodd');\n                    }\n                    else\n                    {\n                        context.fill();\n                    }\n                }\n\n                if (hasTransform)\n                {\n                    context.restore();\n                }\n            }\n        }\n\n        context.restore();\n    }\n\n    public destroy(): void\n    {\n        this.shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { groupD8 } from '../../../maths/matrix/groupD8';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { bgr2rgb } from '../../../scene/container/container-mixins/getGlobalMixin';\nimport { multiplyHexColors } from '../../../scene/container/utils/multiplyHexColors';\nimport { type PatternRepetition } from '../../../scene/graphics/shared/fill/FillPattern';\nimport { canvasUtils } from '../../renderers/canvas/utils/canvasUtils';\n\nimport type { CanvasRenderer } from '../../renderers/canvas/CanvasRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\nimport type { DefaultBatchableQuadElement } from '../shared/DefaultBatcher';\n\n/**\n * A BatcherAdaptor that renders batches using Canvas2D.\n * @category rendering\n * @ignore\n */\nexport class CanvasBatchAdaptor implements BatcherAdaptor\n{\n    private static readonly _tempPatternMatrix = new Matrix();\n\n    private static _getPatternRepeat(\n        addressModeU?: string,\n        addressModeV?: string\n    ): PatternRepetition\n    {\n        const repeatU = addressModeU && addressModeU !== 'clamp-to-edge';\n        const repeatV = addressModeV && addressModeV !== 'clamp-to-edge';\n\n        if (repeatU && repeatV) return 'repeat';\n        if (repeatU) return 'repeat-x';\n        if (repeatV) return 'repeat-y';\n\n        return 'no-repeat';\n    }\n\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        void batchPipe;\n        void geometry;\n        void shader;\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const elements = batch.elements;\n\n        if (!elements || !elements.length) return;\n\n        const renderer = batchPipe.renderer as CanvasRenderer;\n        const contextSystem = renderer.canvasContext;\n        const context = contextSystem.activeContext;\n\n        for (let i = 0; i < elements.length; i++)\n        {\n            const element = elements[i];\n\n            if (!element.packAsQuad) continue;\n\n            const quad = element as DefaultBatchableQuadElement;\n            const texture = quad.texture;\n            const source = texture ? canvasUtils.getCanvasSource(texture) : null;\n\n            if (!source) continue;\n\n            const textureStyle = texture.source.style;\n            const smoothProperty = contextSystem.smoothProperty;\n            const shouldSmooth = textureStyle.scaleMode !== 'nearest';\n\n            if (context[smoothProperty] !== shouldSmooth)\n            {\n                context[smoothProperty] = shouldSmooth;\n            }\n\n            // Use the batch-level (already alpha-adjusted) blend mode\n            contextSystem.setBlendMode(batch.blendMode);\n\n            const globalColor = renderer.globalUniforms.globalUniformData?.worldColor ?? 0xFFFFFFFF;\n            const argb = quad.color;\n\n            const globalAlpha = ((globalColor >>> 24) & 0xFF) / 255;\n            const quadAlpha = ((argb >>> 24) & 0xFF) / 255;\n\n            const filterAlpha = (renderer.filter as { alphaMultiplier?: number } | null)?.alphaMultiplier ?? 1;\n            const alpha = globalAlpha * quadAlpha * filterAlpha;\n\n            if (alpha <= 0) continue;\n\n            context.globalAlpha = alpha;\n\n            const globalTint = globalColor & 0xFFFFFF;\n            const quadTint = argb & 0xFFFFFF;\n\n            const tint = bgr2rgb(multiplyHexColors(quadTint, globalTint));\n            const frame = texture.frame;\n            const repeatU = textureStyle.addressModeU ?? textureStyle.addressMode;\n            const repeatV = textureStyle.addressModeV ?? textureStyle.addressMode;\n            const repeat = CanvasBatchAdaptor._getPatternRepeat(repeatU, repeatV);\n\n            const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n\n            const isFromCachedRenderGroup = ((quad as any).renderable as any)?.renderGroup?.isCachedAsTexture;\n\n            const sx = frame.x * resolution;\n            const sy = frame.y * resolution;\n            const sw = frame.width * resolution;\n            const sh = frame.height * resolution;\n\n            const bounds = quad.bounds;\n\n            const isRootTarget = renderer.renderTarget.renderTarget.isRoot;\n            const dx = bounds.minX;\n            const dy = bounds.minY;\n            const dw = bounds.maxX - bounds.minX;\n            const dh = bounds.maxY - bounds.minY;\n\n            const rotate = texture.rotate;\n\n            const uvs = texture.uvs;\n            const uvMin = Math.min(uvs.x0, uvs.x1, uvs.x2, uvs.x3, uvs.y0, uvs.y1, uvs.y2, uvs.y3);\n            const uvMax = Math.max(uvs.x0, uvs.x1, uvs.x2, uvs.x3, uvs.y0, uvs.y1, uvs.y2, uvs.y3);\n            const needsRepeat = repeat !== 'no-repeat' && (uvMin < 0 || uvMax > 1);\n\n            // Determine if we'll use getTintedCanvas (which handles rotation internally)\n            // Use it for tinting OR rotation (for non-repeat path)\n            const willUseProcessedCanvas = !needsRepeat && (tint !== 0xFFFFFF || rotate);\n            // Only apply rotation transform when NOT using processed canvas (which handles rotation itself)\n            const applyRotateTransform = rotate && !willUseProcessedCanvas;\n\n            if (applyRotateTransform)\n            {\n                CanvasBatchAdaptor._tempPatternMatrix.copyFrom(quad.transform);\n                groupD8.matrixAppendRotationInv(\n                    CanvasBatchAdaptor._tempPatternMatrix,\n                    rotate,\n                    dx,\n                    dy,\n                    dw,\n                    dh\n                );\n                contextSystem.setContextTransform(\n                    CanvasBatchAdaptor._tempPatternMatrix,\n                    quad.roundPixels === 1,\n                    undefined,\n                    isFromCachedRenderGroup && isRootTarget\n                );\n            }\n            else\n            {\n                contextSystem.setContextTransform(\n                    quad.transform,\n                    quad.roundPixels === 1,\n                    undefined,\n                    isFromCachedRenderGroup && isRootTarget\n                );\n            }\n\n            const drawX = applyRotateTransform ? 0 : dx;\n            const drawY = applyRotateTransform ? 0 : dy;\n            const drawW = dw;\n            const drawH = dh;\n\n            if (needsRepeat)\n            {\n                // We can now allow tinting for PMA textures because getCanvasSource\n                // returns an un-premultiplied (straight alpha) version for Canvas.\n                // NOTE: Don't use getTintedCanvas when rotated because it applies rotation compensation,\n                // but the repeat path uses UV-based pattern transforms that expect the original rotated source.\n                let patternSource = source;\n\n                const canTint = tint !== 0xFFFFFF && !rotate;\n                const fitsFrame = frame.width <= texture.source.width && frame.height <= texture.source.height;\n\n                if (canTint && fitsFrame)\n                {\n                    patternSource = canvasUtils.getTintedCanvas({ texture }, tint) as CanvasImageSource;\n                }\n\n                const pattern = context.createPattern(patternSource, repeat);\n\n                if (!pattern) continue;\n\n                const denomX = drawW;\n                const denomY = drawH;\n\n                if (denomX === 0 || denomY === 0) continue;\n\n                const invDx = 1 / denomX;\n                const invDy = 1 / denomY;\n\n                const a = (uvs.x1 - uvs.x0) * invDx;\n                const b = (uvs.y1 - uvs.y0) * invDx;\n                const c = (uvs.x3 - uvs.x0) * invDy;\n                const d = (uvs.y3 - uvs.y0) * invDy;\n                const tx = uvs.x0 - (a * drawX) - (c * drawY);\n                const ty = uvs.y0 - (b * drawX) - (d * drawY);\n\n                const pixelWidth = texture.source.pixelWidth;\n                const pixelHeight = texture.source.pixelHeight;\n\n                CanvasBatchAdaptor._tempPatternMatrix.set(\n                    a * pixelWidth,\n                    b * pixelHeight,\n                    c * pixelWidth,\n                    d * pixelHeight,\n                    tx * pixelWidth,\n                    ty * pixelHeight\n                );\n\n                canvasUtils.applyPatternTransform(pattern, CanvasBatchAdaptor._tempPatternMatrix);\n                context.fillStyle = pattern;\n                context.fillRect(drawX, drawY, drawW, drawH);\n            }\n            else\n            {\n                // We can now allow tinting for PMA textures because getCanvasSource\n                // returns an un-premultiplied (straight alpha) version for Canvas.\n                // getTintedCanvas handles rotation internally, so use it for rotated textures too\n                const needsProcessing = tint !== 0xFFFFFF || rotate;\n                const processedSource = needsProcessing\n                    ? canvasUtils.getTintedCanvas({ texture }, tint) as CanvasImageSource\n                    : source;\n\n                const isProcessed = processedSource !== source;\n\n                context.drawImage(\n                    processedSource,\n                    isProcessed ? 0 : sx,\n                    isProcessed ? 0 : sy,\n                    isProcessed ? (processedSource as any).width : sw,\n                    isProcessed ? (processedSource as any).height : sh,\n                    drawX,\n                    drawY,\n                    drawW,\n                    drawH\n                );\n            }\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\nimport type { ColorMaskInstruction } from './ColorMaskTypes';\n\n/** @internal */\nexport class CanvasColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(_instruction: ColorMaskInstruction)\n    {\n        // no-op on canvas\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorStack = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { type GPUData } from '../../view/ViewContainer';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { GraphicsContext } from '../shared/GraphicsContext';\nimport type { GraphicsContextSystemOptions } from '../shared/GraphicsContextSystem';\n\nclass CanvasGraphicsContext implements GPUData\n{\n    /**\n     * Whether this context can be batched.\n     * @advanced\n     */\n    public isBatchable = false;\n    /**\n     * The source GraphicsContext.\n     * @advanced\n     */\n    public context: GraphicsContext;\n    /**\n     * Render data for this context.\n     * @advanced\n     */\n    public graphicsData: CanvasGraphicsContextRenderData;\n\n    /**\n     * Reset cached canvas data.\n     * @advanced\n     */\n    public reset()\n    {\n        this.isBatchable = false;\n        this.context = null;\n\n        if (this.graphicsData)\n        {\n            this.graphicsData.destroy();\n            this.graphicsData = null;\n        }\n    }\n\n    /**\n     * Destroy the cached data.\n     * @advanced\n     */\n    public destroy()\n    {\n        this.reset();\n    }\n}\n\nclass CanvasGraphicsContextRenderData\n{\n    /**\n     * Instructions for canvas rendering.\n     * @advanced\n     */\n    public instructions = new InstructionSet();\n\n    /**\n     * Initialize render data.\n     * @advanced\n     */\n    public init(): void\n    {\n        this.instructions.reset();\n    }\n\n    /**\n     * Destroy render data.\n     * @advanced\n     */\n    public destroy(): void\n    {\n        this.instructions.destroy();\n        (this.instructions as null) = null;\n    }\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts for Canvas2D.\n * @category rendering\n * @advanced\n */\nexport class CanvasGraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    private readonly _renderer: Renderer;\n    private readonly _managedContexts: GCManagedHash<GraphicsContext>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedContexts = new GCManagedHash({ renderer, type: 'resource', name: 'graphicsContext' });\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        CanvasGraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? CanvasGraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    /**\n     * Returns the render data for a given GraphicsContext.\n     * @param context - The GraphicsContext to get the render data for.\n     * @internal\n     */\n    public getContextRenderData(context: GraphicsContext): CanvasGraphicsContextRenderData\n    {\n        const gpuContext = this.getGpuContext(context);\n\n        return gpuContext.graphicsData || this._initContextRenderData(context);\n    }\n\n    /**\n     * Updates the GPU context for a given GraphicsContext.\n     * @param context - The GraphicsContext to update.\n     * @returns The updated CanvasGraphicsContext.\n     * @internal\n     */\n    public updateGpuContext(context: GraphicsContext)\n    {\n        const gpuData = context._gpuData as unknown as Record<number | string, CanvasGraphicsContext>;\n        const hasContext = !!gpuData[this._renderer.uid];\n        const gpuContext = gpuData[this._renderer.uid] || this._initContext(context);\n\n        if (context.dirty || !hasContext)\n        {\n            if (hasContext)\n            {\n                gpuContext.reset();\n            }\n\n            gpuContext.isBatchable = false;\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    /**\n     * Returns the CanvasGraphicsContext for a given GraphicsContext.\n     * If it does not exist, it will initialize a new one.\n     * @param context - The GraphicsContext to get the CanvasGraphicsContext for.\n     * @returns The CanvasGraphicsContext for the given GraphicsContext.\n     * @internal\n     */\n    public getGpuContext(context: GraphicsContext): CanvasGraphicsContext\n    {\n        const gpuData = context._gpuData as unknown as Record<number | string, CanvasGraphicsContext>;\n\n        return gpuData[this._renderer.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): CanvasGraphicsContextRenderData\n    {\n        const renderData = new CanvasGraphicsContextRenderData();\n        const gpuContext = this.getGpuContext(context);\n\n        gpuContext.graphicsData = renderData;\n\n        renderData.init();\n\n        return renderData;\n    }\n\n    private _initContext(context: GraphicsContext): CanvasGraphicsContext\n    {\n        const gpuContext = new CanvasGraphicsContext();\n\n        gpuContext.context = context;\n        (context._gpuData as unknown as Record<number | string, CanvasGraphicsContext>)[this._renderer.uid] = gpuContext;\n\n        this._managedContexts.add(context);\n\n        return gpuContext;\n    }\n\n    public destroy()\n    {\n        this._managedContexts.destroy();\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor } from '../shared/GraphicsPipe';\n\n/** @internal */\nexport class CanvasGraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n    private _adaptor: GraphicsAdaptor;\n    private readonly _managedGraphics: GCManagedHash<Graphics>;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this.renderer.runners.contextChange.add(this);\n        this._managedGraphics = new GCManagedHash({ renderer, type: 'renderable', priority: -1, name: 'graphics' });\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(_graphics: Graphics): boolean\n    {\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        this._managedGraphics.add(graphics);\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(graphics);\n    }\n\n    public updateRenderable(_graphics: Graphics)\n    {\n        // no-op for canvas\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    public destroy()\n    {\n        this._managedGraphics.destroy();\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsPipeLike\n{\n    renderer: Renderer;\n    state: State;\n}\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipeLike, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData implements GPUData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n    private readonly _managedGraphics: GCManagedHash<Graphics>;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this.renderer.runners.contextChange.add(this);\n        this._managedGraphics = new GCManagedHash({ renderer, type: 'renderable', priority: -1, name: 'graphics' });\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const contextSystem = this.renderer.graphicsContext as GraphicsContextSystem;\n        const gpuContext = contextSystem.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const contextSystem = this.renderer.graphicsContext as GraphicsContextSystem;\n        const gpuContext = contextSystem.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext as GraphicsContextSystem;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const contextSystem = this.renderer.graphicsContext as GraphicsContextSystem;\n        const gpuContext = contextSystem.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        this._managedGraphics.add(graphics);\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n        const contextSystem = this.renderer.graphicsContext as GraphicsContextSystem;\n        const gpuContext: GpuGraphicsContext = contextSystem.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this._managedGraphics.destroy();\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { CanvasGraphicsContextSystem } from './canvas/CanvasGraphicsContextSystem';\nimport { CanvasGraphicsPipe } from './canvas/CanvasGraphicsPipe';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(CanvasGraphicsPipe);\nextensions.add(GraphicsPipe);\nextensions.add(CanvasGraphicsContextSystem);\nextensions.add(GraphicsContextSystem);\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\nimport { type GraphicsGpuData } from './GraphicsPipe';\nimport '../init';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for Graphics instances.\n * Configures the initial state and behavior of a Graphics object.\n * @example\n * ```ts\n * const graphics = new Graphics({\n *     roundPixels: true,\n *     position: { x: 100.5, y: 100.5 }\n * });\n *\n * // Reuse graphics context\n * const sharedContext = new GraphicsContext();\n * const graphics1 = new Graphics({ context: sharedContext });\n * const graphics2 = new Graphics({ context: sharedContext });\n * ```\n * @see {@link Graphics} For the graphics class implementation\n * @see {@link GraphicsContext} For the graphics context API\n * @category scene\n * @standard\n */\nexport interface GraphicsOptions extends PixiMixins.GraphicsOptions, ViewContainerOptions\n{\n    /**\n     * The GraphicsContext to use, useful for reuse and optimisation\n     * If not provided, a new GraphicsContext will be created.\n     * @example\n     * ```ts\n     * const sharedContext = new GraphicsContext();\n     * const graphics1 = new Graphics({ context: sharedContext });\n     * const graphics2 = new Graphics({ context: sharedContext });\n     * ```\n     */\n    context?: GraphicsContext;\n    /**\n     * Whether or not to round the x/y position.\n     * @default false\n     * @example\n     * ```ts\n     * const graphics = new Graphics({ roundPixels: true });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Graphics extends PixiMixins.Graphics, ViewContainer<GraphicsGpuData> {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them. It can also be used to create complex\n * masks and hit areas for interaction.\n * @example\n * ```ts\n * // Create a new graphics object\n * const graphics = new Graphics();\n *\n * // Draw a filled rectangle with a stroke\n * graphics\n *     .rect(0, 0, 100, 100)\n *     .fill({ color: 0xff0000 }) // Fill with red\n *     .stroke({ width: 2, color: 0x000000 }); // Stroke with black\n *\n * // Draw a complex shape\n * graphics\n *     .moveTo(50, 50)\n *     .lineTo(100, 100)\n *     .arc(100, 100, 50, 0, Math.PI)\n *     .closePath()\n *     .fill({ color: 0x00ff00, alpha: 0.5 }); // Fill the shape\n *\n * // Use as a mask\n * sprite.mask = graphics;\n * ```\n * @see {@link GraphicsContext} For the underlying drawing API\n * @see {@link GraphicsPath} For path creation\n * @category scene\n * @standard\n */\nexport class Graphics extends ViewContainer<GraphicsGpuData> implements Instruction\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'graphics';\n    /** @internal */\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * Creates a new Graphics object.\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this.context = this._ownedContext = new GraphicsContext();\n            this.context.autoGarbageCollect = this.autoGarbageCollect;\n        }\n        else\n        {\n            this.context = context;\n        }\n\n        this.didViewUpdate = true;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        if (this._context)\n        {\n            this._context.off('update', this.onViewUpdate, this);\n            this._context.off('unload', this.unload, this);\n        }\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n        this._context.on('unload', this.unload, this);\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The underlying graphics context used for drawing operations.\n     * Controls how shapes and paths are rendered.\n     * @example\n     * ```ts\n     * // Create a shared context\n     * const sharedContext = new GraphicsContext();\n     *\n     * // Create graphics objects sharing the same context\n     * const graphics1 = new Graphics();\n     * const graphics2 = new Graphics();\n     *\n     * // Assign shared context\n     * graphics1.context = sharedContext;\n     * graphics2.context = sharedContext;\n     *\n     * // Both graphics will show the same shapes\n     * sharedContext\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @see {@link GraphicsContext} For drawing operations\n     * @see {@link GraphicsOptions} For context configuration\n     */\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphics object.\n     * Returns the boundaries after all graphical operations but before any transforms.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Get bounds information\n     * const bounds = graphics.bounds;\n     * console.log(bounds.width);  // 100\n     * console.log(bounds.height); // 100\n     * ```\n     * @readonly\n     * @see {@link Bounds} For bounds operations\n     * @see {@link Container#getBounds} For transformed bounds\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Graphics objects do not need to update their bounds as the context handles this.\n     * @private\n     */\n    protected updateBounds(): void { /** */ }\n\n    /**\n     * Checks if the object contains the given point.\n     * Returns true if the point lies within the Graphics object's rendered area.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Check point intersection\n     * if (graphics.containsPoint({ x: 50, y: 50 })) {\n     *     console.log('Point is inside rectangle!');\n     * }\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is inside the Graphics object\n     * @see {@link Graphics#bounds} For bounding box checks\n     * @see {@link PointData} For point data structure\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @example\n     * ```ts\n     * // Destroy the graphics and its context\n     * graphics.destroy();\n     * graphics.destroy(true);\n     * graphics.destroy({ context: true, texture: true, textureSource: true });\n     * ```\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    /**\n     * @param now - The current time in milliseconds.\n     * @internal\n     */\n    public _onTouch(now: number): void\n    {\n        this._gcLastUsed = now;\n        this._context._gcLastUsed = now;\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context.\n     * The fill style can be a color, gradient, pattern, or a complex style object.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics\n     *     .setFillStyle({ color: 0xff0000 }) // Red fill\n     *     .rect(0, 0, 100, 100)\n     *     .fill();\n     *\n     * // Gradient fill\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setFillStyle(gradient)\n     *     .circle(100, 100, 50)\n     *     .fill();\n     *\n     * // Pattern fill\n     * const pattern = new FillPattern(texture);\n     * graphics\n     *     .setFillStyle({\n     *         fill: pattern,\n     *         alpha: 0.5\n     *     })\n     *     .rect(0, 0, 200, 200)\n     *     .fill();\n     * ```\n     * @param {FillInput} args - The fill style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context.\n     * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color stroke\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 2,\n     *         color: 0x000000\n     *     })\n     *     .rect(0, 0, 100, 100)\n     *     .stroke();\n     *\n     * // Complex stroke style\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 4,\n     *         color: 0xff0000,\n     *         alpha: 0.5,\n     *         join: 'round',\n     *         cap: 'round',\n     *         alignment: 0.5\n     *     })\n     *     .circle(100, 100, 50)\n     *     .stroke();\n     *\n     * // Gradient stroke\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 10,\n     *         fill: gradient\n     *     })\n     *     .poly([0,0, 100,50, 0,100])\n     *     .stroke();\n     * ```\n     * @param {StrokeInput} args - The stroke style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link FillPattern} For pattern strokes\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style or specified style.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Fill with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill('red'); // Red fill\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .fill(myTexture); // Fill with texture\n     *\n     * // Fill with complex style\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({\n     *         color: 0x00ff00,\n     *         alpha: 0.5,\n     *         texture: myTexture,\n     *         matrix: new Matrix()\n     *     });\n     *\n     * // Fill with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill(gradient);\n     * ```\n     * @param {FillInput} style - The style to fill the path with. Can be:\n     * - A ColorSource\n     * - A gradient\n     * - A pattern\n     * - A complex style object\n     * If omitted, uses current fill style.\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style or specified style.\n     * Outlines the shape using the stroke settings.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Stroke with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0xff0000\n     *     }); // 2px red stroke\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .stroke(myTexture); // Fill with texture\n     *\n     * // Stroke with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .stroke({\n     *         width: 4,\n     *         fill: gradient,\n     *         alignment: 0.5,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n     * - A stroke style object with width, color, etc.\n     * - A gradient\n     * - A pattern\n     * If omitted, uses current stroke style.\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link setStrokeStyle} For setting default stroke style\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple ways to draw textures\n     * including basic textures, tinted textures, and textures with custom dimensions.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic texture drawing\n     * graphics.texture(myTexture);\n     *\n     * // Tinted texture with position\n     * graphics.texture(myTexture, 0xff0000); // Red tint\n     *\n     * // Texture with custom position and dimensions\n     * graphics\n     *     .texture(\n     *         myTexture,    // texture\n     *         0xffffff,     // white tint\n     *         100, 100,     // position\n     *         200, 150      // dimensions\n     *     );\n     * ```\n     * Basic texture drawing:\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current Graphics for chaining.\n     *\n     * Extended texture drawing:\n     * @param texture - The Texture object to use.\n     *        tint - A ColorSource to tint the texture (defaults to white).\n     *        dx - The x-coordinate for the texture placement.\n     *        dy - The y-coordinate for the texture placement.\n     *        dw - The width to draw the texture (defaults to texture width).\n     *        dh - The height to draw the texture (defaults to texture height).\n     * @returns The instance of the current Graphics for chaining.\n     * @see {@link Texture} For texture creation\n     * @see {@link FillPattern} For pattern fills\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .circle(150, 150, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .beginPath() // Starts a new path\n     *     .circle(250, 150, 50)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for chaining\n     * @see {@link Graphics#moveTo} For starting a new subpath\n     * @see {@link Graphics#closePath} For closing the current path\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path.\n     *\n     * If a hole is not completely in a shape, it will fail to cut correctly.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw outer circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *     .circle(100, 100, 25) // Inner circle\n     *     .cut() // Cuts out the inner circle from the outer circle\n     * ```\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @example\n     * ```ts\n     * // Draw a simple arc (quarter circle)\n     * const graphics = new Graphics();\n     * graphics\n     *     .arc(100, 100, 50, 0, Math.PI/2)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Draw a full circle using an arc\n     * graphics\n     *     .arc(200, 200, 30, 0, Math.PI * 2)\n     *     .stroke({ color: 0x00ff00 });\n     *\n     * // Draw a counterclockwise arc\n     * graphics\n     *     .arc(150, 150, 40, Math.PI, 0, true)\n     *     .stroke({ width: 2, color: 0x0000ff });\n     * ```\n     * @param x - The x-coordinate of the arc's center\n     * @param y - The y-coordinate of the arc's center\n     * @param radius - The arc's radius (must be positive)\n     * @param startAngle - The starting point of the arc, in radians\n     * @param endAngle - The end point of the arc, in radians\n     * @param counterclockwise - Optional. If true, draws the arc counterclockwise.\n     *                          If false (default), draws clockwise.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing complete circles\n     * @see {@link Graphics#arcTo} For drawing arcs between points\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path that connects two points using a radius.\n     * The arc is drawn between the current point and the specified end point,\n     * using the given control point to determine the curve of the arc.\n     * @example\n     * ```ts\n     * // Draw a simple curved corner\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .arcTo(100, 50, 100, 100, 20) // Rounded corner with 20px radius\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a rounded rectangle using arcTo\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcTo(250, 150, 250, 250, 30) // Top right corner\n     *     .arcTo(250, 250, 150, 250, 30) // Bottom right corner\n     *     .arcTo(150, 250, 150, 150, 30) // Bottom left corner\n     *     .arcTo(150, 150, 250, 150, 30) // Top left corner\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x1 - The x-coordinate of the control point\n     * @param y1 - The y-coordinate of the control point\n     * @param x2 - The x-coordinate of the end point\n     * @param y2 - The y-coordinate of the end point\n     * @param radius - The radius of the arc in pixels (must be positive)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For drawing arcs using center point and angles\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * This is particularly useful when converting SVG paths to Graphics or creating complex curved shapes.\n     * @example\n     * ```ts\n     * // Draw a simple elliptical arc\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(100, 100)\n     *     .arcToSvg(50, 30, 0, 0, 1, 200, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a complex path with rotated elliptical arc\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcToSvg(\n     *         60,    // rx\n     *         30,    // ry\n     *         45,    // x-axis rotation (45 degrees)\n     *         1,     // large arc flag\n     *         0,     // sweep flag\n     *         250,   // end x\n     *         200    // end y\n     *     )\n     *     .stroke({ width: 4, color: 0x00ff00 });\n     *\n     * // Chain multiple arcs for complex shapes\n     * graphics\n     *     .moveTo(300, 100)\n     *     .arcToSvg(40, 20, 0, 0, 1, 350, 150)\n     *     .arcToSvg(40, 20, 0, 0, 1, 300, 200)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param rx - The x-radius of the ellipse (must be non-negative)\n     * @param ry - The y-radius of the ellipse (must be non-negative)\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative to the x-axis, in degrees\n     * @param largeArcFlag - Either 0 or 1, determines if the larger of the two possible arcs is chosen (1) or not (0)\n     * @param sweepFlag - Either 0 or 1, determines if the arc should be swept in\n     *                    a positive angle direction (1) or negative (0)\n     * @param x - The x-coordinate of the arc's end point\n     * @param y - The y-coordinate of the arc's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For simple circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     * @see {@link Graphics#svg} For parsing complete SVG paths\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bézier curve to the path, from the current point to the specified end point.\n     * The curve is influenced by two control points that define its shape and curvature.\n     * @example\n     * ```ts\n     * // Draw a simple curved line\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .bezierCurveTo(\n     *         100, 25,   // First control point\n     *         150, 75,   // Second control point\n     *         200, 50    // End point\n     *     )\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .bezierCurveTo(\n     *         100, 150,\n     *         200, 250,\n     *         250, 200,\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({ width: 4, color: 0x0000ff });\n     * ```\n     * @param cp1x - The x-coordinate of the first control point\n     * @param cp1y - The y-coordinate of the first control point\n     * @param cp2x - The x-coordinate of the second control point\n     * @param cp2y - The y-coordinate of the second control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#quadraticCurveTo} For simpler curves with one control point\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start point.\n     *\n     * This is useful for completing shapes and ensuring they are properly closed for fills.\n     * @example\n     * ```ts\n     * // Create a triangle with closed path\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .closePath()\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path\n     * @see {@link Graphics#fill} For filling closed paths\n     * @see {@link Graphics#stroke} For stroking paths\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic ellipse\n     * graphics\n     *     .ellipse(100, 100, 50, 30)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw an ellipse with stroke\n     * graphics\n     *     .ellipse(200, 100, 70, 40)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the center of the ellipse\n     * @param y - The y-coordinate of the center of the ellipse\n     * @param radiusX - The horizontal radius of the ellipse\n     * @param radiusY - The vertical radius of the ellipse\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing perfect circles\n     * @see {@link Graphics#arc} For drawing partial circular arcs\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape at the specified location with the given radius.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a circle with gradient fill\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *           { offset: 0, color: 0xff0000 }, // Red at start\n     *           { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *           { offset: 1, color: 0x0000ff }, // Blue at end\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(250, 100, 40)\n     *     .fill({ fill: gradient });\n     * ```\n     * @param x - The x-coordinate of the center of the circle\n     * @param y - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#ellipse} For drawing ellipses\n     * @see {@link Graphics#arc} For drawing partial circles\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * This allows for reuse of complex paths and shapes across different graphics instances.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * // Create a reusable path\n     * const heartPath = new GraphicsPath()\n     *     .moveTo(0, 0)\n     *     .bezierCurveTo(-50, -25, -50, -75, 0, -100)\n     *     .bezierCurveTo(50, -75, 50, -25, 0, 0);\n     *\n     * // Use the path multiple times\n     * graphics\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000 })\n     *     .translateTransform(200, 200)\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000, alpha: 0.5 });\n     * ```\n     * @param path - The `GraphicsPath` to add to the current path\n     * @returns The Graphics instance for method chaining\n     * @see {@link GraphicsPath} For creating reusable paths\n     * @see {@link Matrix} For creating transformations\n     * @see {@link Graphics#transform} For applying transformations\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line.\n     * Any subsequent drawing commands will start from this new point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a complex shape with multiple lines\n     * graphics\n     *     .moveTo(200, 50)\n     *     .lineTo(250, 50)\n     *     .lineTo(250, 100)\n     *     .lineTo(200, 100)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the line's end point\n     * @param y - The y-coordinate of the line's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#moveTo} For starting a new sub-path\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path.\n     *\n     * Moves the \"pen\" to a new location without drawing a line.\n     * Any subsequent drawing commands will start from this point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create multiple separate lines\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 50)\n     *     .moveTo(50, 100)    // Start a new line\n     *     .lineTo(100, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create disconnected shapes\n     * graphics\n     *     .moveTo(150, 50)\n     *     .rect(150, 50, 50, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .moveTo(250, 50)    // Start a new shape\n     *     .circle(250, 75, 25)\n     *     .fill({ color: 0x0000ff });\n     *\n     * // Position before curved paths\n     * graphics\n     *     .moveTo(300, 50)\n     *     .bezierCurveTo(\n     *         350, 25,   // Control point 1\n     *         400, 75,   // Control point 2\n     *         450, 50    // End point\n     *     )\n     *     .stroke({ width: 3, color: 0xff00ff });\n     * ```\n     * @param x - The x-coordinate to move to\n     * @param y - The y-coordinate to move to\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#lineTo} For drawing lines\n     * @see {@link Graphics#beginPath} For starting a completely new path\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple curve\n     * graphics\n     *     .moveTo(50, 50)\n     *     .quadraticCurveTo(100, 25, 150, 50)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .quadraticCurveTo(\n     *         150, 150,   // Control point\n     *         250, 200,   // End point\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({\n     *         width: 4,\n     *         color: 0x0000ff,\n     *         alpha: 0.7\n     *     });\n     * ```\n     * @param cpx - The x-coordinate of the control point\n     * @param cpy - The y-coordinate of the control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#bezierCurveTo} For curves with two control points\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape.\n     *\n     * This method adds a new rectangle path to the current drawing.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled rectangle\n     * graphics\n     *     .rect(50, 50, 100, 75)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Rectangle with stroke\n     * graphics\n     *     .rect(200, 50, 100, 75)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners. The corner radius can be specified to\n     * determine how rounded the corners should be.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic rounded rectangle\n     * graphics\n     *     .roundRect(50, 50, 100, 75, 15)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @param radius - The radius of the rectangle's corners (must be non-negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rect} For drawing rectangles with sharp corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed.\n     *\n     * An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle using array of numbers [x1,y1, x2,y2, x3,y3]\n     * graphics\n     *     .poly([50,50, 100,100, 0,100], true)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a polygon using point objects\n     * graphics\n     *     .poly([\n     *         { x: 200, y: 50 },\n     *         { x: 250, y: 100 },\n     *         { x: 200, y: 150 },\n     *         { x: 150, y: 100 }\n     *     ])\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Draw an open polygon with stroke\n     * graphics\n     *     .poly([300,50, 350,50, 350,100, 300,100], false)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0x0000ff,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param points - An array of numbers [x1,y1, x2,y2, ...] or an array of point objects [{x,y}, ...]\n     *                representing the vertices of the polygon in sequence\n     * @param close - Whether to close the polygon path by connecting the last point to the first.\n     *               Default is true.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal,\n     * making shapes like triangles, squares, pentagons, etc.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple triangle (3 sides)\n     * graphics\n     *     .regularPoly(100, 100, 50, 3)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a hexagon (6 sides) with rotation\n     * graphics\n     *     .regularPoly(\n     *         250, 100,    // center position\n     *         40,          // radius\n     *         6,           // sides\n     *         Math.PI / 6  // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Draw an octagon (8 sides) with transform\n     * const transform = new Matrix()\n     *     .scale(1.5, 1)      // stretch horizontally\n     *     .rotate(Math.PI/4); // rotate 45 degrees\n     *\n     * graphics\n     *     .regularPoly(400, 100, 30, 8, 0, transform)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @param transform - Optional Matrix to transform the polygon's shape\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     *\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic rounded triangle\n     * graphics\n     *     .roundPoly(100, 100, 50, 3, 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rounded hexagon with rotation\n     * graphics\n     *     .roundPoly(\n     *         250, 150,     // center position\n     *         40,           // radius\n     *         6,            // sides\n     *         8,            // corner radius\n     *         Math.PI / 6   // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param corner - The radius of the corner rounding (must be non-negative)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing polygons without rounded corners\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a custom shape with rounded corners\n     * graphics\n     *     .roundShape([\n     *         { x: 100, y: 100, radius: 20 },\n     *         { x: 200, y: 100, radius: 10 },\n     *         { x: 200, y: 200, radius: 15 },\n     *         { x: 100, y: 200, radius: 5 }\n     *     ], 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using quadratic curves for corners\n     * graphics\n     *     .roundShape([\n     *         { x: 250, y: 100 },\n     *         { x: 350, y: 100 },\n     *         { x: 350, y: 200 },\n     *         { x: 250, y: 200 }\n     *     ], 15, true, 0.5)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Shape with varying corner radii\n     * graphics\n     *     .roundShape([\n     *         { x: 400, y: 100, radius: 30 },\n     *         { x: 500, y: 100, radius: 5 },\n     *         { x: 450, y: 200, radius: 15 }\n     *     ], 10)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param points - An array of `RoundedPoint` representing the corners of the shape.\n     *                Each point can have its own radius or use the default.\n     *                A minimum of 3 points is required.\n     * @param radius - The default radius for corners without a specific radius defined.\n     *                Applied to any point that doesn't specify its own radius.\n     * @param useQuadratic - When true, corners are drawn using quadratic curves instead\n     *                      of arcs, creating a different visual style. Defaults to false.\n     * @param smoothness - Controls the smoothness of quadratic corners when useQuadratic\n     *                    is true. Values range from 0-1, higher values create smoother curves.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#roundPoly} For drawing regular polygons with rounded corners\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draws a rectangle with fillet corners. Unlike rounded rectangles, this supports negative corner\n     * radii which create external rounded corners rather than internal ones.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a rectangle with internal fillets\n     * graphics\n     *     .filletRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rectangle with external fillets\n     * graphics\n     *     .filletRect(200, 50, 100, 80, -20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param fillet - The radius of the corner fillets (can be positive or negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For standard rounded corners\n     * @see {@link Graphics#chamferRect} For angled corners\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draws a rectangle with chamfered (angled) corners. Each corner is cut off at\n     * a 45-degree angle based on the chamfer size.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic chamfered rectangle\n     * graphics\n     *     .chamferRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Add transform and stroke\n     * const transform = new Matrix()\n     *     .rotate(Math.PI / 4); // 45 degrees\n     *\n     * graphics\n     *     .chamferRect(200, 50, 100, 80, 20, transform)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param chamfer - The size of the corner chamfers (must be non-zero)\n     * @param transform - Optional Matrix to transform the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For rounded corners\n     * @see {@link Graphics#filletRect} For rounded corners with negative radius support\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     * of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     *\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic 5-pointed star\n     * graphics\n     *     .star(100, 100, 5, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Star with custom inner radius\n     * graphics\n     *     .star(250, 100, 6, 50, 20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the star\n     * @param y - The y-coordinate of the center of the star\n     * @param points - The number of points on the star (must be >= 3)\n     * @param radius - The outer radius of the star (distance from center to point tips)\n     * @param innerRadius - Optional. The inner radius of the star (distance from center to inner vertices).\n     *                     If not specified, defaults to half of the outer radius\n     * @param rotation - Optional. The rotation of the star in radians. Default is 0,\n     *                  which aligns one point straight up\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#path} For creating custom shapes\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes\n     * and paths defined in SVG format to be drawn within the graphics context.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .svg(`\n     *         <path d=\"M 50,50 L 100,50 L 100,100 L 50,100 Z\"\n     *               fill=\"blue\" />\n     *         <circle cx=\"150\" cy=\"75\" r=\"25\"\n     *               fill=\"green\" />\n     *     `)\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param svg - The SVG string to be parsed and rendered\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#path} For adding custom paths\n     * @see {@link Graphics#fill} For filling shapes after SVG parsing\n     * @see {@link Graphics#stroke} For stroking shapes after SVG parsing\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save current state\n     * graphics.save();\n     *\n     * // Make temporary changes\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .setFillStyle({ color: 0xff0000 })\n     *     .circle(0, 0, 50)\n     *     .fill();\n     *\n     * // Restore to previous state\n     * graphics.restore();\n     *\n     * // Draw with original transform and styles\n     * graphics\n     *     .circle(50, 50, 30)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#save} For saving the current state\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /**\n     * Saves the current graphics state onto a stack. The state includes:\n     * - Current transformation matrix\n     * - Current fill style\n     * - Current stroke style\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save state before complex operations\n     * graphics.save();\n     *\n     * // Create transformed and styled shape\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4)\n     *     .setFillStyle({\n     *         color: 0xff0000,\n     *         alpha: 0.5\n     *     })\n     *     .rect(-25, -25, 50, 50)\n     *     .fill();\n     *\n     * // Restore to original state\n     * graphics.restore();\n     *\n     * // Continue drawing with previous state\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#restore} For restoring the saved state\n     * @see {@link Graphics#setTransform} For setting transformations\n     */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * This matrix represents all accumulated transformations including translate, scale, and rotate.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply some transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4);\n     *\n     * // Get the current transform matrix\n     * const matrix = graphics.getTransform();\n     * console.log(matrix.tx, matrix.ty); // 100, 100\n     *\n     * // Use the matrix for other operations\n     * graphics\n     *     .setTransform(matrix)\n     *     .circle(0, 0, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @returns The current transformation matrix.\n     * @see {@link Graphics#setTransform} For setting the transform matrix\n     * @see {@link Matrix} For matrix operations\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .scaleTransform(2, 2)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * // Reset transform to default state\n     * graphics\n     *     .resetTransform()\n     *     .circle(50, 50, 25) // Will draw at actual coordinates\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#getTransform} For getting the current transform\n     * @see {@link Graphics#setTransform} For setting a specific transform\n     * @see {@link Graphics#save} For saving the current transform state\n     * @see {@link Graphics#restore} For restoring a previous transform state\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * Positive angles rotate clockwise, while negative angles rotate counterclockwise.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Rotate 45 degrees clockwise\n     * graphics\n     *     .rotateTransform(Math.PI / 4)\n     *     .rect(-25, -25, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param angle - The angle of rotation in radians\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#scaleTransform} For scaling transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally\n     * and by y vertically relative to the current origin.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Uniform scaling\n     * graphics\n     *     .scaleTransform(2)  // Scale both dimensions by 2\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Non-uniform scaling\n     * graphics\n     *     .scaleTransform(0.5, 2)  // Half width, double height\n     *     .rect(100, 100, 50, 50)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x - The scale factor in the horizontal direction\n     * @param y - The scale factor in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rotateTransform} For rotation transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context.\n     *\n     * This method can either\n     * take a Matrix object or individual transform values to create a new transformation matrix.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     *\n     * graphics\n     *     .setTransform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .setTransform(\n     *         2, 0,     // scale x by 2\n     *         0, 1,     // no skew\n     *         100, 100  // translate x,y by 100\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies a transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix. This allows for complex transformations\n     * combining multiple operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .scale(2, 1)      // Scale horizontally\n     *     .rotate(Math.PI/6); // Rotate 30 degrees\n     *\n     * graphics\n     *     .transform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .transform(\n     *         1, 0.5,    // Skew horizontally\n     *         0, 1,      // No vertical skew\n     *         100, 100   // Translate\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * This affects all subsequent drawing operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic translation\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The amount to translate in the horizontal direction\n     * @param y - The amount to translate in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#setTransform} For setting absolute transformations\n     * @see {@link Graphics#transform} For applying complex transformations\n     * @see {@link Graphics#save} For saving the current transform state\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it.\n     * This includes clearing the current path, fill style, stroke style, and transformations.\n     *\n     * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n     * > Instead, they are intended to be used for static or semi-static graphics that\n     * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw some shapes\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 })\n     *     .rect(200, 100, 100, 50)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Clear all graphics\n     * graphics.clear();\n     *\n     * // Start fresh with new shapes\n     * graphics\n     *     .circle(150, 150, 30)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n     * @see {@link Graphics#save} For saving the current state\n     * @see {@link Graphics#restore} For restoring a previous state\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * Gets or sets the current fill style for the graphics context. The fill style determines\n     * how shapes are filled when using the fill() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics.fillStyle = {\n     *     color: 0xff0000,  // Red\n     *     alpha: 1\n     * };\n     *\n     * // Using gradients\n     * const gradient = new FillGradient({\n     *     end: { x: 0, y: 1 }, // Vertical gradient\n     *     stops: [\n     *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n     *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n     *     ]\n     * });\n     *\n     * graphics.fillStyle = {\n     *     fill: gradient,\n     *     alpha: 0.8\n     * };\n     *\n     * // Using patterns\n     * graphics.fillStyle = {\n     *     texture: myTexture,\n     *     alpha: 1,\n     *     matrix: new Matrix()\n     *         .scale(0.5, 0.5)\n     *         .rotate(Math.PI / 4)\n     * };\n     * ```\n     * @type {ConvertedFillStyle}\n     * @see {@link FillStyle} For all available fill style options\n     * @see {@link FillGradient} For creating gradient fills\n     * @see {@link Graphics#fill} For applying the fill to paths\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * Gets or sets the current stroke style for the graphics context. The stroke style determines\n     * how paths are outlined when using the stroke() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic stroke style\n     * graphics.strokeStyle = {\n     *     width: 2,\n     *     color: 0xff0000,\n     *     alpha: 1\n     * };\n     *\n     * // Using with gradients\n     * const gradient = new FillGradient({\n     *   end: { x: 0, y: 1 },\n     *   stops: [\n     *       { offset: 0, color: 0xff0000, alpha: 1 },\n     *       { offset: 1, color: 0x0000ff, alpha: 1 }\n     *   ]\n     * });\n     *\n     * graphics.strokeStyle = {\n     *     width: 4,\n     *     fill: gradient,\n     *     alignment: 0.5,\n     *     join: 'round',\n     *     cap: 'round'\n     * };\n     *\n     * // Complex stroke settings\n     * graphics.strokeStyle = {\n     *     width: 6,\n     *     color: 0x00ff00,\n     *     alpha: 0.5,\n     *     join: 'miter',\n     *     miterLimit: 10,\n     * };\n     * ```\n     * @see {@link StrokeStyle} For all available stroke style options\n     * @see {@link Graphics#stroke} For applying the stroke to paths\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object that copies the current graphics content.\n     * The clone can either share the same context (shallow clone) or have its own independent\n     * context (deep clone).\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create original graphics content\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a shallow clone (shared context)\n     * const shallowClone = graphics.clone();\n     *\n     * // Changes to original affect the clone\n     * graphics\n     *     .circle(200, 100, 30)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Create a deep clone (independent context)\n     * const deepClone = graphics.clone(true);\n     *\n     * // Modify deep clone independently\n     * deepClone\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 40)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @param deep - Whether to create a deep clone of the graphics object.\n     *              If false (default), the context will be shared between objects.\n     *              If true, creates an independent copy of the context.\n     * @returns A new Graphics instance with either shared or copied context\n     * @see {@link Graphics#context} For accessing the underlying graphics context\n     * @see {@link GraphicsContext} For understanding the shared context behavior\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        if (color !== undefined) fillStyle.color = color;\n        if (alpha !== undefined) fillStyle.alpha = alpha;\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Matrix } from '../../../maths/matrix/Matrix';\nimport { Graphics } from '../../../scene/graphics/shared/Graphics';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { ShapePrimitive } from '../../../maths/shapes/ShapePrimitive';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { ShapePrimitiveWithHoles } from '../../../scene/graphics/shared/path/ShapePath';\nimport type { CrossPlatformCanvasRenderingContext2D } from '../../renderers/canvas/CanvasContextSystem';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMaskInstruction } from './StencilMaskTypes';\n\nfunction buildRoundedRectPath(\n    context: CrossPlatformCanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number\n): void\n{\n    radius = Math.max(0, Math.min(radius, Math.min(width, height) / 2));\n\n    context.moveTo(x + radius, y);\n    context.lineTo(x + width - radius, y);\n    context.quadraticCurveTo(x + width, y, x + width, y + radius);\n    context.lineTo(x + width, y + height - radius);\n    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    context.lineTo(x + radius, y + height);\n    context.quadraticCurveTo(x, y + height, x, y + height - radius);\n    context.lineTo(x, y + radius);\n    context.quadraticCurveTo(x, y, x + radius, y);\n}\n\nfunction buildShapePath(context: CrossPlatformCanvasRenderingContext2D, shape: ShapePrimitive): void\n{\n    switch (shape.type)\n    {\n        case 'rectangle':\n        {\n            const rect = shape as typeof shape & { width: number; height: number };\n\n            context.rect(rect.x, rect.y, rect.width, rect.height);\n            break;\n        }\n        case 'roundedRectangle':\n        {\n            const rect = shape as typeof shape & { width: number; height: number; radius: number };\n\n            buildRoundedRectPath(context, rect.x, rect.y, rect.width, rect.height, rect.radius);\n            break;\n        }\n        case 'circle':\n        {\n            const circle = shape as typeof shape & { radius: number };\n\n            context.moveTo(circle.x + circle.radius, circle.y);\n            context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);\n            break;\n        }\n        case 'ellipse':\n        {\n            const ellipse = shape as typeof shape & { halfWidth: number; halfHeight: number };\n\n            if (context.ellipse)\n            {\n                context.moveTo(ellipse.x + ellipse.halfWidth, ellipse.y);\n                context.ellipse(ellipse.x, ellipse.y, ellipse.halfWidth, ellipse.halfHeight, 0, 0, Math.PI * 2);\n            }\n            else\n            {\n                context.save();\n                context.translate(ellipse.x, ellipse.y);\n                context.scale(ellipse.halfWidth, ellipse.halfHeight);\n                context.moveTo(1, 0);\n                context.arc(0, 0, 1, 0, Math.PI * 2);\n                context.restore();\n            }\n            break;\n        }\n        case 'triangle':\n        {\n            const tri = shape as typeof shape & { x2: number; y2: number; x3: number; y3: number };\n\n            context.moveTo(tri.x, tri.y);\n            context.lineTo(tri.x2, tri.y2);\n            context.lineTo(tri.x3, tri.y3);\n            context.closePath();\n            break;\n        }\n        case 'polygon':\n        default:\n        {\n            const poly = shape as typeof shape & { points: number[]; closePath: boolean };\n            const points = poly.points;\n\n            if (!points?.length) break;\n\n            context.moveTo(points[0], points[1]);\n\n            for (let i = 2; i < points.length; i += 2)\n            {\n                context.lineTo(points[i], points[i + 1]);\n            }\n\n            if (poly.closePath)\n            {\n                context.closePath();\n            }\n            break;\n        }\n    }\n}\n\nfunction addHolePaths(\n    context: CrossPlatformCanvasRenderingContext2D,\n    holes?: ShapePrimitiveWithHoles[]\n): boolean\n{\n    if (!holes?.length) return false;\n\n    for (let i = 0; i < holes.length; i++)\n    {\n        const hole = holes[i];\n\n        if (!hole?.shape) continue;\n\n        const transform = hole.transform;\n        const hasTransform = transform && !transform.isIdentity();\n\n        if (hasTransform)\n        {\n            context.save();\n            context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n        }\n\n        buildShapePath(context, hole.shape);\n\n        if (hasTransform)\n        {\n            context.restore();\n        }\n    }\n\n    return true;\n}\n\n/** @internal */\nexport class CanvasStencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _warnedMaskTypes = new Set<string>();\n    private _canvasMaskStack: boolean[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            mask: _mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        if (instruction.action !== 'pushMaskBegin' && instruction.action !== 'popMaskEnd')\n        {\n            return;\n        }\n\n        const canvasRenderer = this._renderer as unknown as {\n            canvasContext: {\n                activeContext: CrossPlatformCanvasRenderingContext2D;\n                setContextTransform: (transform: Matrix, roundPixels?: boolean) => void;\n            };\n            _roundPixels: number;\n        };\n        const contextSystem = canvasRenderer.canvasContext;\n        const context = contextSystem?.activeContext;\n\n        if (!context) return;\n\n        if (instruction.action === 'popMaskEnd')\n        {\n            const didClip = this._canvasMaskStack.pop();\n\n            if (didClip)\n            {\n                context.restore();\n            }\n\n            return;\n        }\n\n        if (instruction.inverse)\n        {\n            this._warnOnce(\n                'inverse',\n                'CanvasRenderer: inverse masks are not supported on Canvas2D; '\n                + 'ignoring inverse flag.'\n            );\n        }\n\n        const maskContainer = instruction.mask.mask;\n\n        if (!(maskContainer instanceof Graphics))\n        {\n            this._warnOnce(\n                'nonGraphics',\n                'CanvasRenderer: only Graphics masks are supported in Canvas2D; '\n                + 'skipping mask.'\n            );\n            this._canvasMaskStack.push(false);\n\n            return;\n        }\n\n        const graphics = maskContainer;\n        const instructions = graphics.context?.instructions;\n\n        if (!instructions?.length)\n        {\n            this._canvasMaskStack.push(false);\n\n            return;\n        }\n\n        context.save();\n        contextSystem.setContextTransform(\n            graphics.groupTransform,\n            ((canvasRenderer._roundPixels | graphics._roundPixels) as 0 | 1) === 1\n        );\n        context.beginPath();\n\n        let drewPath = false;\n        let hasHoles = false;\n\n        for (let i = 0; i < instructions.length; i++)\n        {\n            const instructionData = instructions[i];\n            const action = instructionData.action;\n\n            if (action !== 'fill' && action !== 'stroke') continue;\n\n            const data = instructionData.data as {\n                path?: {\n                    shapePath?: {\n                        shapePrimitives?: ShapePrimitiveWithHoles[];\n                    };\n                };\n            };\n            const shapePath = data?.path?.shapePath;\n\n            if (!shapePath?.shapePrimitives?.length) continue;\n\n            const shapePrimitives = shapePath.shapePrimitives;\n\n            for (let j = 0; j < shapePrimitives.length; j++)\n            {\n                const primitive = shapePrimitives[j];\n\n                if (!primitive?.shape) continue;\n\n                const transform = primitive.transform;\n                const hasTransform = transform && !transform.isIdentity();\n\n                if (hasTransform)\n                {\n                    context.save();\n                    context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n                }\n\n                buildShapePath(context, primitive.shape as ShapePrimitive);\n                hasHoles = addHolePaths(context, primitive.holes) || hasHoles;\n                drewPath = true;\n\n                if (hasTransform)\n                {\n                    context.restore();\n                }\n            }\n        }\n\n        if (!drewPath)\n        {\n            context.restore();\n            this._canvasMaskStack.push(false);\n\n            return;\n        }\n\n        if (hasHoles)\n        {\n            context.clip('evenodd');\n        }\n        else\n        {\n            context.clip();\n        }\n\n        this._canvasMaskStack.push(true);\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._warnedMaskTypes = null;\n        this._canvasMaskStack = null;\n    }\n\n    private _warnOnce(key: string, message: string): void\n    {\n        if (this._warnedMaskTypes.has(key)) return;\n\n        this._warnedMaskTypes.add(key);\n        warn(message);\n    }\n}\n", "import { canUseNewCanvasBlendModes } from './canUseNewCanvasBlendModes';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\n\nconst FALLBACK_BLEND: GlobalCompositeOperation = 'source-over';\n\n/**\n * Builds the Canvas blend mode map for Pixi blend enums.\n * @returns A mapping of Pixi blend modes to canvas composite ops.\n * @internal\n */\nexport function mapCanvasBlendModesToPixi(): Record<BLEND_MODES, GlobalCompositeOperation | null>\n{\n    const supportsAdvanced = canUseNewCanvasBlendModes();\n    const map = Object.create(null) as Record<BLEND_MODES, GlobalCompositeOperation>;\n\n    map.inherit = FALLBACK_BLEND;\n    map.none = FALLBACK_BLEND;\n\n    map.normal = 'source-over';\n    map.add = 'lighter';\n    map.multiply = supportsAdvanced ? 'multiply' : FALLBACK_BLEND;\n    map.screen = supportsAdvanced ? 'screen' : FALLBACK_BLEND;\n    map.overlay = supportsAdvanced ? 'overlay' : FALLBACK_BLEND;\n    map.darken = supportsAdvanced ? 'darken' : FALLBACK_BLEND;\n    map.lighten = supportsAdvanced ? 'lighten' : FALLBACK_BLEND;\n    map['color-dodge'] = supportsAdvanced ? 'color-dodge' : FALLBACK_BLEND;\n    map['color-burn'] = supportsAdvanced ? 'color-burn' : FALLBACK_BLEND;\n    map['hard-light'] = supportsAdvanced ? 'hard-light' : FALLBACK_BLEND;\n    map['soft-light'] = supportsAdvanced ? 'soft-light' : FALLBACK_BLEND;\n    map.difference = supportsAdvanced ? 'difference' : FALLBACK_BLEND;\n    map.exclusion = supportsAdvanced ? 'exclusion' : FALLBACK_BLEND;\n    map.saturation = supportsAdvanced ? 'saturation' : FALLBACK_BLEND;\n    map.color = supportsAdvanced ? 'color' : FALLBACK_BLEND;\n    map.luminosity = supportsAdvanced ? 'luminosity' : FALLBACK_BLEND;\n\n    map['linear-burn'] = supportsAdvanced ? 'color-burn' : FALLBACK_BLEND;\n    map['linear-dodge'] = supportsAdvanced ? 'color-dodge' : FALLBACK_BLEND;\n    map['linear-light'] = supportsAdvanced ? 'hard-light' : FALLBACK_BLEND;\n    map['pin-light'] = supportsAdvanced ? 'hard-light' : FALLBACK_BLEND;\n    map['vivid-light'] = supportsAdvanced ? 'hard-light' : FALLBACK_BLEND;\n    map['hard-mix'] = FALLBACK_BLEND;\n    map.negation = supportsAdvanced ? 'difference' : FALLBACK_BLEND;\n\n    map['normal-npm'] = map.normal;\n    map['add-npm'] = map.add;\n    map['screen-npm'] = map.screen;\n\n    map.erase = 'destination-out';\n    map.subtract = FALLBACK_BLEND;\n    map.divide = FALLBACK_BLEND;\n    map.min = FALLBACK_BLEND;\n    map.max = FALLBACK_BLEND;\n\n    return map;\n}\n", "import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { mapCanvasBlendModesToPixi } from './utils/mapCanvasBlendModesToPixi';\n\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { BLEND_MODES } from '../shared/state/const';\nimport type { System } from '../shared/system/System';\nimport type { CanvasRenderer } from './CanvasRenderer';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Canvas 2D context with vendor image smoothing flags.\n * @internal\n */\nexport interface CrossPlatformCanvasRenderingContext2D extends ICanvasRenderingContext2D\n{\n    /** WebKit-specific image smoothing flag. */\n    webkitImageSmoothingEnabled: boolean;\n    /** Mozilla-specific image smoothing flag. */\n    mozImageSmoothingEnabled: boolean;\n    /** Opera-specific image smoothing flag. */\n    oImageSmoothingEnabled: boolean;\n    /** Microsoft-specific image smoothing flag. */\n    msImageSmoothingEnabled: boolean;\n}\n\n/**\n * Available image smoothing flags for the current context.\n * @internal\n */\nexport type SmoothingEnabledProperties =\n    'imageSmoothingEnabled' |\n    'webkitImageSmoothingEnabled' |\n    'mozImageSmoothingEnabled' |\n    'oImageSmoothingEnabled' |\n    'msImageSmoothingEnabled';\n\n/**\n * Canvas 2D context system for the CanvasRenderer.\n * @category rendering\n * @advanced\n */\nexport class CanvasContextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasContext',\n    } as const;\n\n    private readonly _renderer: CanvasRenderer;\n\n    /** Root 2D context tied to the renderer's canvas. */\n    public rootContext: CrossPlatformCanvasRenderingContext2D;\n    /** Active 2D context for rendering (root or render target). */\n    public activeContext: CrossPlatformCanvasRenderingContext2D;\n    /** Resolution of the active context. */\n    public activeResolution = 1;\n\n    /** The image smoothing property to toggle for this browser. */\n    public smoothProperty: SmoothingEnabledProperties = 'imageSmoothingEnabled';\n    /** Map of Pixi blend modes to canvas composite operations. */\n    public readonly blendModes = mapCanvasBlendModesToPixi();\n\n    /** Current canvas blend mode. */\n    public _activeBlendMode: BLEND_MODES = 'normal';\n    /** Optional projection transform for render targets. */\n    public _projTransform: Matrix = null;\n    /** True when external blend mode control is in use. */\n    public _outerBlend = false;\n    /** Tracks unsupported blend mode warnings to avoid spam. */\n    private readonly _warnedBlendModes = new Set<BLEND_MODES>();\n\n    /**\n     * @param renderer - The owning CanvasRenderer.\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected resolutionChange(resolution: number): void\n    {\n        this.activeResolution = resolution;\n    }\n\n    /** Initializes the root context and smoothing flag selection. */\n    public init(): void\n    {\n        const alpha = this._renderer.background.alpha < 1;\n\n        this.rootContext = this._renderer.canvas.getContext(\n            '2d',\n            { alpha }\n        ) as unknown as CrossPlatformCanvasRenderingContext2D;\n        this.activeContext = this.rootContext;\n        this.activeResolution = this._renderer.resolution;\n\n        if (!this.rootContext.imageSmoothingEnabled)\n        {\n            const rc = this.rootContext;\n\n            if (rc.webkitImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'webkitImageSmoothingEnabled';\n            }\n            else if (rc.mozImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'mozImageSmoothingEnabled';\n            }\n            else if (rc.oImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'oImageSmoothingEnabled';\n            }\n            else if (rc.msImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'msImageSmoothingEnabled';\n            }\n        }\n    }\n\n    /**\n     * Sets the current transform on the active context.\n     * @param transform - Transform to apply.\n     * @param roundPixels - Whether to round translation to integers.\n     * @param localResolution - Optional local resolution multiplier.\n     * @param skipGlobalTransform - If true, skip applying the global world transform matrix.\n     */\n    public setContextTransform(\n        transform: Matrix,\n        roundPixels?: boolean,\n        localResolution?: number,\n        skipGlobalTransform?: boolean\n    ): void\n    {\n        const globalTransform = skipGlobalTransform\n            ? Matrix.IDENTITY\n            : (this._renderer.globalUniforms.globalUniformData?.worldTransformMatrix || Matrix.IDENTITY);\n\n        let mat = tempMatrix;\n\n        mat.copyFrom(globalTransform);\n        mat.append(transform);\n\n        const proj = this._projTransform;\n        const contextResolution = this.activeResolution;\n\n        localResolution = localResolution || contextResolution;\n\n        if (proj)\n        {\n            const finalMat = Matrix.shared;\n\n            finalMat.copyFrom(mat);\n            finalMat.prepend(proj);\n            mat = finalMat;\n        }\n\n        if (roundPixels)\n        {\n            this.activeContext.setTransform(\n                mat.a * localResolution,\n                mat.b * localResolution,\n                mat.c * localResolution,\n                mat.d * localResolution,\n                (mat.tx * contextResolution) | 0,\n                (mat.ty * contextResolution) | 0\n            );\n        }\n        else\n        {\n            this.activeContext.setTransform(\n                mat.a * localResolution,\n                mat.b * localResolution,\n                mat.c * localResolution,\n                mat.d * localResolution,\n                mat.tx * contextResolution,\n                mat.ty * contextResolution\n            );\n        }\n    }\n\n    /**\n     * Clears the current render target, optionally filling with a color.\n     * @param clearColor - Color to fill after clearing.\n     * @param alpha - Alpha override for the clear color.\n     */\n    public clear(clearColor?: number[] | string | number, alpha?: number): void\n    {\n        const context = this.activeContext;\n        const renderer = this._renderer;\n\n        context.clearRect(0, 0, renderer.width, renderer.height);\n\n        if (clearColor)\n        {\n            const color = Color.shared.setValue(clearColor);\n\n            context.globalAlpha = alpha ?? color.alpha;\n            context.fillStyle = color.toHex();\n            context.fillRect(0, 0, renderer.width, renderer.height);\n            context.globalAlpha = 1;\n        }\n    }\n\n    /**\n     * Sets the active blend mode.\n     * @param blendMode - Pixi blend mode.\n     */\n    public setBlendMode(blendMode: BLEND_MODES): void\n    {\n        if (this._activeBlendMode === blendMode) return;\n\n        this._activeBlendMode = blendMode;\n        this._outerBlend = false;\n\n        const mappedBlend = this.blendModes[blendMode];\n\n        if (!mappedBlend)\n        {\n            if (!this._warnedBlendModes.has(blendMode))\n            {\n                console.warn(\n                    `CanvasRenderer: blend mode \"${blendMode}\" is not supported in Canvas2D; falling back to \"source-over\".`\n                );\n                this._warnedBlendModes.add(blendMode);\n            }\n\n            this.activeContext.globalCompositeOperation = 'source-over';\n\n            return;\n        }\n\n        this.activeContext.globalCompositeOperation = mappedBlend;\n    }\n\n    /** Releases context references. */\n    public destroy(): void\n    {\n        this.rootContext = null;\n        this.activeContext = null;\n        this._warnedBlendModes.clear();\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\n\n/**\n * Basic limits for CanvasRenderer.\n * @category rendering\n * @advanced\n */\nexport class CanvasLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    public maxTextures = 16;\n    public maxBatchableTextures = 16;\n    public maxUniformBindings = 0;\n\n    public init(): void\n    {\n        // fixed limits for canvas\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CanvasRenderer } from '../CanvasRenderer';\n\n/**\n * Canvas render target backing store.\n * @internal\n */\nexport type CanvasRenderTarget = {\n    /** Backing canvas element. */\n    canvas: ICanvas;\n    /** 2D context associated with the canvas. */\n    context: ICanvasRenderingContext2D;\n    /** Pixel width. */\n    width: number;\n    /** Pixel height. */\n    height: number;\n};\n\n/**\n * Canvas adaptor for render targets.\n * @category rendering\n * @advanced\n */\nexport class CanvasRenderTargetAdaptor implements RenderTargetAdaptor<CanvasRenderTarget>\n{\n    private _renderer: CanvasRenderer;\n    private _renderTargetSystem: RenderTargetSystem<CanvasRenderTarget>;\n\n    /**\n     * Initializes the adaptor.\n     * @param renderer - Canvas renderer instance.\n     * @param renderTargetSystem - The render target system.\n     * @advanced\n     */\n    public init(renderer: CanvasRenderer, renderTargetSystem: RenderTargetSystem<CanvasRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    /**\n     * Creates a GPU render target for canvas.\n     * @param renderTarget - Render target to initialize.\n     * @advanced\n     */\n    public initGpuRenderTarget(renderTarget: RenderTarget): CanvasRenderTarget\n    {\n        const colorTexture = renderTarget.colorTexture;\n        const { canvas, context } = this._ensureCanvas(colorTexture);\n\n        return {\n            canvas,\n            context,\n            width: canvas.width,\n            height: canvas.height,\n        };\n    }\n\n    /**\n     * Resizes the backing canvas for a render target.\n     * @param renderTarget - Render target to resize.\n     * @advanced\n     */\n    public resizeGpuRenderTarget(renderTarget: RenderTarget): void\n    {\n        const colorTexture = renderTarget.colorTexture;\n        const { canvas } = this._ensureCanvas(colorTexture);\n\n        canvas.width = renderTarget.pixelWidth;\n        canvas.height = renderTarget.pixelHeight;\n    }\n\n    /**\n     * Starts a render pass on the canvas target.\n     * @param renderTarget - Target to render to.\n     * @param clear - Clear mode.\n     * @param clearColor - Optional clear color.\n     * @param viewport - Optional viewport.\n     * @advanced\n     */\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearColor?: number[],\n        viewport?: Rectangle\n    ): void\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._renderer.canvasContext.activeContext = gpuRenderTarget.context as any;\n        this._renderer.canvasContext.activeResolution = renderTarget.resolution;\n\n        if (clear)\n        {\n            this.clear(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    /**\n     * Clears the render target.\n     * @param renderTarget - Target to clear.\n     * @param _clear - Clear mode (unused).\n     * @param clearColor - Optional clear color.\n     * @param viewport - Optional viewport rectangle.\n     * @advanced\n     */\n    public clear(\n        renderTarget: RenderTarget,\n        _clear: CLEAR_OR_BOOL,\n        clearColor?: number[],\n        viewport?: Rectangle\n    ): void\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n        const context = gpuRenderTarget.context as ICanvasRenderingContext2D;\n        const bounds = viewport || { x: 0, y: 0, width: renderTarget.pixelWidth, height: renderTarget.pixelHeight };\n\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);\n\n        if (clearColor)\n        {\n            const color = Color.shared.setValue(clearColor);\n\n            if (color.alpha > 0)\n            {\n                context.globalAlpha = color.alpha;\n                context.fillStyle = color.toHex();\n                context.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n                context.globalAlpha = 1;\n            }\n        }\n    }\n\n    /**\n     * Finishes the render pass (no-op for canvas).\n     * @advanced\n     */\n    public finishRenderPass(): void\n    {\n        // no-op for canvas\n    }\n\n    /**\n     * Copies a render target into a texture source.\n     * @param {RenderTarget} sourceRenderSurfaceTexture - Source render target.\n     * @param {Texture} destinationTexture - Destination texture.\n     * @param {object} originSrc - Source origin.\n     * @param {number} originSrc.x - Source x origin.\n     * @param {number} originSrc.y - Source y origin.\n     * @param {object} size - Copy size.\n     * @param {number} size.width - Copy width.\n     * @param {number} size.height - Copy height.\n     * @param {object} [originDest] - Destination origin.\n     * @param {number} originDest.x - Destination x origin.\n     * @param {number} originDest.y - Destination y origin.\n     * @advanced\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest?: { x: number; y: number },\n    ): Texture\n    {\n        const sourceGpuTarget = this._renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const sourceCanvas = sourceGpuTarget.canvas as CanvasImageSource;\n\n        const destSource = destinationTexture.source as TextureSource;\n        const { context } = this._ensureCanvas(destSource);\n\n        const dx = originDest?.x ?? 0;\n        const dy = originDest?.y ?? 0;\n\n        context.drawImage(\n            sourceCanvas,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height,\n            dx,\n            dy,\n            size.width,\n            size.height\n        );\n\n        destSource.update();\n\n        return destinationTexture;\n    }\n\n    /**\n     * Destroys a GPU render target (no-op for canvas).\n     * @param _gpuRenderTarget - Target to destroy.\n     * @advanced\n     */\n    public destroyGpuRenderTarget(_gpuRenderTarget: CanvasRenderTarget): void\n    {\n        // no-op for canvas\n    }\n\n    private _ensureCanvas(source: TextureSource)\n    {\n        let canvas = source.resource as ICanvas;\n\n        if (!canvas || !(CanvasSource.test(canvas)))\n        {\n            canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n            source.resource = canvas as any;\n        }\n\n        if (canvas.width !== source.pixelWidth || canvas.height !== source.pixelHeight)\n        {\n            canvas.width = source.pixelWidth;\n            canvas.height = source.pixelHeight;\n        }\n\n        const context = canvas.getContext('2d') as ICanvasRenderingContext2D;\n\n        return { canvas, context };\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { type CanvasRenderTarget, CanvasRenderTargetAdaptor } from './CanvasRenderTargetAdaptor';\n\nimport type { CanvasRenderer } from '../CanvasRenderer';\n\n/**\n * The Canvas adaptor for the render target system.\n * @category rendering\n * @advanced\n */\nexport class CanvasRenderTargetSystem extends RenderTargetSystem<CanvasRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.CanvasSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new CanvasRenderTargetAdaptor();\n\n    constructor(renderer: CanvasRenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { canvasUtils } from '../utils/canvasUtils';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CanvasRenderer } from '../CanvasRenderer';\n\n/**\n * Texture helper system for CanvasRenderer.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    /**\n     * @param renderer - The owning CanvasRenderer.\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        void renderer;\n    }\n\n    /** Initializes the system (no-op for canvas). */\n    public init(): void\n    {\n        // no-op\n    }\n\n    /**\n     * Initializes a texture source (no-op for canvas).\n     * @param _source - Texture source.\n     */\n    public initSource(_source: TextureSource): void\n    {\n        // no-op for canvas\n    }\n\n    /**\n     * Creates a canvas containing the texture's frame.\n     * @param texture - Texture to render.\n     */\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n        const context = canvas.getContext('2d');\n        const source = canvasUtils.getCanvasSource(texture);\n\n        if (!source)\n        {\n            return canvas;\n        }\n\n        const frame = texture.frame;\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n\n        const sx = frame.x * resolution;\n        const sy = frame.y * resolution;\n        const sw = frame.width * resolution;\n        const sh = frame.height * resolution;\n\n        canvas.width = Math.ceil(sw);\n        canvas.height = Math.ceil(sh);\n\n        context.drawImage(\n            source,\n            sx,\n            sy,\n            sw,\n            sh,\n            0,\n            0,\n            sw,\n            sh\n        );\n\n        return canvas;\n    }\n\n    /**\n     * Reads pixel data from a texture.\n     * @param texture - Texture to read.\n     */\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const canvas = this.generateCanvas(texture);\n        const context = canvas.getContext('2d', { willReadFrequently: true });\n        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\n        return {\n            pixels: imageData.data,\n            width: canvas.width,\n            height: canvas.height,\n        };\n    }\n\n    /** Destroys the system (no-op for canvas). */\n    public destroy(): void\n    {\n        // no-op\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { CustomRenderPipe } from '../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../scene/container/RenderGroupPipe';\nimport { CanvasGraphicsAdaptor } from '../../../scene/graphics/canvas/CanvasGraphicsAdaptor';\nimport { SpritePipe } from '../../../scene/sprite/SpritePipe';\nimport { CanvasBatchAdaptor } from '../../batcher/canvas/CanvasBatchAdaptor';\nimport { BatcherPipe } from '../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../mask/alpha/AlphaMaskPipe';\nimport { CanvasColorMaskPipe } from '../../mask/color/CanvasColorMaskPipe';\nimport { CanvasStencilMaskPipe } from '../../mask/stencil/CanvasStencilMaskPipe';\nimport { BlendModePipe } from '../shared/blendModes/BlendModePipe';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { CanvasContextSystem } from './CanvasContextSystem';\nimport { CanvasLimitsSystem } from './CanvasLimitsSystem';\nimport { CanvasRenderTargetSystem } from './renderTarget/CanvasRenderTargetSystem';\nimport { CanvasTextureSystem } from './texture/CanvasTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultCanvasSystems = [\n    ...SharedSystems,\n    CanvasContextSystem,\n    CanvasLimitsSystem,\n    CanvasTextureSystem,\n    CanvasRenderTargetSystem,\n];\n\nconst DefaultCanvasPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    CanvasStencilMaskPipe,\n    CanvasColorMaskPipe,\n    CustomRenderPipe,\n];\nconst DefaultCanvasAdapters = [\n    CanvasBatchAdaptor,\n    CanvasGraphicsAdaptor,\n];\n\n// installed systems will be added to this array by the extensions manager.\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.CanvasSystem, systems);\nextensions.handleByNamedList(ExtensionType.CanvasPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.CanvasPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultCanvasSystems, ...DefaultCanvasPipes, ...DefaultCanvasAdapters);\n\n/**\n * The default Canvas systems. These are the systems that are added by default to the CanvasRenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type CanvasSystems = ExtractSystemTypes<typeof DefaultCanvasSystems>\n& PixiMixins.RendererSystems & PixiMixins.CanvasSystems;\n\n/**\n * The Canvas renderer pipes. These are used to render the scene.\n * @see {@link CanvasRenderer}\n * @internal\n */\nexport type CanvasPipes = ExtractSystemTypes<typeof DefaultCanvasPipes> & PixiMixins.RendererPipes & PixiMixins.CanvasPipes;\n\n/**\n * Options for CanvasRenderer.\n * @category rendering\n * @standard\n */\nexport interface CanvasOptions\n    extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultCanvasSystems>,\n    PixiMixins.CanvasOptions {}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface CanvasRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<CanvasPipes, CanvasOptions, T>,\n    CanvasSystems {}\n\n/**\n * The Canvas PixiJS Renderer. This renderer allows you to use the HTML Canvas 2D context.\n * @category rendering\n * @standard\n */\nexport class CanvasRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<CanvasPipes, CanvasOptions, T>\n    implements CanvasSystems\n{\n    constructor()\n    {\n        const systemConfig = {\n            name: 'canvas',\n            type: RendererType.CANVAS,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],
  "mappings": "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",
  "names": ["data", "alpha", "tint", "generateTextureFillMatrix", "_CanvasBatchAdaptor", "_CanvasGraphicsContextSystem", "buildRoundedRectPath", "buildShapePath", "addHolePaths", "tempMatrix"]
}
