{
  "version": 3,
  "sources": ["../../pixi.js/src/environment/autoDetectEnvironment.ts", "../../pixi.js/src/utils/browser/unsafeEvalSupported.ts", "../../pixi.js/src/rendering/renderers/gl/const.ts", "../../pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts", "../../pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts", "../../pixi.js/src/scene/container/CustomRenderPipe.ts", "../../pixi.js/src/scene/sprite/BatchableSprite.ts", "../../pixi.js/src/scene/container/utils/executeInstructions.ts", "../../pixi.js/src/scene/container/RenderGroupPipe.ts", "../../pixi.js/src/scene/container/utils/clearList.ts", "../../pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts", "../../pixi.js/src/scene/container/utils/validateRenderables.ts", "../../pixi.js/src/scene/container/RenderGroupSystem.ts", "../../pixi.js/src/scene/sprite/SpritePipe.ts", "../../pixi.js/src/utils/const.ts", "../../pixi.js/src/utils/global/globalHooks.ts", "../../pixi.js/src/rendering/batcher/shared/BatcherPipe.ts", "../../pixi.js/lib/filters/mask/mask.frag.mjs", "../../pixi.js/lib/filters/mask/mask.vert.mjs", "../../pixi.js/lib/filters/mask/mask.wgsl.mjs", "../../pixi.js/src/filters/mask/MaskFilter.ts", "../../pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts", "../../pixi.js/src/rendering/mask/color/ColorMaskPipe.ts", "../../pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts", "../../pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts", "../../pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts", "../../pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts", "../../pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts", "../../pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts", "../../pixi.js/src/utils/data/clean.ts", "../../pixi.js/src/rendering/renderers/shared/GCSystem.ts", "../../pixi.js/src/scene/graphics/gpu/colorToUniform.ts", "../../pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts", "../../pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts", "../../pixi.js/src/utils/sayHello.ts", "../../pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts", "../../pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts", "../../pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts", "../../pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts", "../../pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts", "../../pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts", "../../pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts", "../../pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts", "../../pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts", "../../pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts"],
  "sourcesContent": ["import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n * @category environment\n * @advanced\n */\nexport async function loadEnvironmentExtensions(skip: boolean): Promise<void>\n{\n    if (skip) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n * @category environment\n * @advanced\n */\nexport async function autoDetectEnvironment(add: boolean): Promise<void>\n{\n    return loadEnvironmentExtensions(!add);\n}\n", "// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (_e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n", "/**\n * Constants used by the renderer for clearing the screen or render textures.\n * @category rendering\n * @advanced\n */\nexport enum CLEAR\n{\n    /** No clear operation. */\n    NONE = 0,\n    /** Clear the color buffer. */\n    COLOR = 16384,\n    /** Clear the stencil buffer. */\n    STENCIL = 1024,\n    /** Clear the depth buffer. */\n    DEPTH = 256,\n\n    /** Clear the color and depth buffers. */\n    COLOR_DEPTH = COLOR | DEPTH,\n    /** Clear the color and stencil buffers. */\n    COLOR_STENCIL = COLOR | STENCIL,\n    /** Clear the depth and stencil buffers. */\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    /** Clear the color, depth, and stencil buffers. */\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/**\n * Used for clearing render textures. true is the same as `ALL` false is the same as `NONE`\n * @category rendering\n * @advanced\n */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n", "/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @category rendering\n * @internal\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /* jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```ts\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\n/**\n * The configuration for the renderer.\n * This is used to define the systems and render pipes that will be used by the renderer.\n * @category rendering\n * @advanced\n */\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @category rendering\n * @standard\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @category rendering\n * @advanced\n */\nexport interface ClearOptions\n{\n    /**\n     * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n     * please ensure you have set `multiView` to `true` on renderer.\n     */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n\n    /**\n     * Mip level to render/clear to when the target is a texture-backed render surface.\n     * @default 0\n     *\n     * Note: When rendering to a {@link Texture} target, Pixi renders into the underlying {@link TextureSource}\n     * (via an internal {@link RenderTarget}). The texture's `frame` is interpreted in mip 0 space and is scaled/clamped\n     * to the requested mip level.\n     * @advanced\n     */\n    mipLevel?: number;\n\n    /**\n     * Array layer index to render/clear to when the target is an array-backed texture source (e.g. `arrayLayerCount > 1`).\n     *\n     * This maps to WebGPU's `GPUTextureViewDescriptor.baseArrayLayer` when creating render-attachment views.\n     * @default 0\n     * @advanced\n     */\n    layer?: number;\n}\n\n/**\n * Options for destroying the renderer.\n * This can be a boolean or an object.\n * @category rendering\n * @standard\n */\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions & {\n    /** Whether to clean up global resource pools/caches */\n    releaseGlobalResources?: boolean;\n}>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'resetState',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@link WebGLRenderer}\n * or {@link WebGPURenderer}.\n * Alternatively, you can also use {@link autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link EventSystem}           | This manages UI events.                                                       |\n * | {@link AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @category rendering\n * @advanced\n * @property {HelloSystem} hello - HelloSystem instance.\n * @property {TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {FilterSystem} filter - FilterSystem instance.\n * @property {GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {TextureSystem} texture - TextureSystem instance.\n * @property {EventSystem} events - EventSystem instance.\n * @property {ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    /** @internal */\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    /** The current tick of the renderer. */\n    public tick: number = 0;\n\n    /** @internal */\n    public readonly uid = uid('renderer');\n\n    /** @internal */\n    public _roundPixels: 0 | 1;\n\n    /** @internal */\n    public readonly runners: Runners = Object.create(null) as Runners;\n    /** @internal */\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        this.tick++;\n\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n\n            options.clearColor ??= this.background.colorRgba;\n            options.clear ??= this.background.clearBeforeRender;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        // Check if the container is visible before proceeding with rendering\n        if (!options.container.visible)\n        {\n            return;\n        }\n\n        // lets ensure this object is a render group so we can render it!\n        // the renderer only likes to render - render groups.\n        options.container.enableRenderGroup();\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    /**\n     * Clears the render target.\n     * @param options - The options to use when clearing the render target.\n     * @param options.target - The render target to clear.\n     * @param options.clearColor - The color to clear with.\n     * @param options.clear - The clear mode to use.\n     * @advanced\n     */\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target, mipLevel, layer } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray, mipLevel ?? 0, layer ?? 0);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @type {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n\n            this.runners.destroy.add((this.renderPipes as any)[name]);\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        if (options === true || (typeof options === 'object' && options.releaseGlobalResources))\n        {\n            GlobalResourceRegistry.release();\n        }\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n    /**\n     * Resets the rendering state of the renderer.\n     * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n     * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n     * render will reset all internal caches and ensure it executes correctly.\n     *\n     * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n     * ```js\n     * // Reset Three.js state\n     * threeRenderer.resetState();\n     *\n     * // Render a Three.js scene\n     * threeRenderer.render(threeScene, threeCamera);\n     *\n     * // Reset PixiJS state since Three.js modified the WebGL context\n     * pixiRenderer.resetState();\n     *\n     * // Now render Pixi content\n     * pixiRenderer.render(pixiScene);\n     * ```\n     * @advanced\n     */\n    public resetState(): void\n    {\n        this.runners.resetState.emit();\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @category rendering\n * @internal\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { type GPUData } from '../view/ViewContainer';\n\nimport type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement, GPUData\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        this.reset();\n    }\n}\n", "import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderer\n * @internal\n */\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderGroup } from './RenderGroup';\n\n/**\n * The RenderGroupPipe is a render pipe for rendering RenderGroups.\n * @internal\n */\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n\n        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = new Matrix().translate(\n                -renderGroup._textureBounds.x,\n                -renderGroup._textureBounds.y\n            );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n                offset: { x: 0, y: 0 },\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n", "/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n * @category utils\n * @internal\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n", "import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\n/**\n * @param renderGroup\n * @param updateChildRenderGroups\n * @internal\n */\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\n/**\n * @param renderGroup\n * @internal\n */\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\n/**\n * @param container\n * @param updateTick\n * @param updateFlags\n * @internal\n */\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n", "import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @internal\n */\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            // Early out as nothing further needs to be updated!\n            if (!renderGroup.textureNeedsUpdate) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        // Update the closest cache reference for children if this render group is cached as texture\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                const scaleMode = renderGroup.textureOptions.scaleMode ?? 'linear';\n                const lastTexture = renderGroup.texture;\n\n                bounds.ceil();\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture, true);\n                }\n\n                const texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                texture._source.style = new TextureStyle({ scaleMode });\n                renderGroup.texture = texture;\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture, true);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Sprite } from './Sprite';\n\n/** @internal */\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = new BatchableSprite();\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        sprite._gpuData[this._renderer.uid] = batchableSprite;\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\n\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @type {RegExp}\n * @default /(?:^data:image\\/([\\w+]+);(?:[\\w=]+|charset=[\\w-]+)?(?:;base64)?,)/i\n * @example\n * import { DATA_URI } from 'pixi.js';\n *\n * DATA_URI.test('data:image/png;base64,foobar'); // => true\n * @category utils\n * @advanced\n */\nexport const DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n// export the event emitter so we can use it in external modules\nexport { EventEmitter };\n\n/**\n * The current version of PixiJS. This is automatically replaced by the build process.\n * @internal\n */\nexport const VERSION = '$_VERSION';\n", "import { type ExtensionMetadata, ExtensionType } from '../../extensions/Extensions';\nimport { VERSION } from '../const';\n\nimport type { Application } from '../../app/Application';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\n\ndeclare global\n{\n    var __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    var __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n}\n\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @category app\n * @internal\n */\nexport class ApplicationInitHook\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    public static init(): void\n    {\n        globalThis.__PIXI_APP_INIT__?.(this as unknown as Application, VERSION);\n    }\n    public static destroy(): void\n    {\n        // nothing to do\n    }\n}\n\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @category rendering\n * @internal\n */\nexport class RendererInitHook implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'initHook',\n        priority: -10,\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n    public init(): void\n    {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n    }\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\n/** @internal */\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @category rendering\n * @advanced\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher({\n                maxTextures: this.renderer.limits.maxBatchableTextures,\n            });\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n", "var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n", "var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\n/** @internal */\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            clipToViewport: false,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\n/** @internal */\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\n/** @internal */\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\n/** @internal */\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\n/** @internal */\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\nimport type { ColorMaskInstruction } from './ColorMaskTypes';\n\n/** @internal */\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        (renderer as WebGLRenderer | WebGPURenderer).colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorStack = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\nimport type { StencilMaskInstruction } from './StencilMaskTypes';\n\n/** @internal */\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        const gpuRenderer = renderer as WebGLRenderer | WebGPURenderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            gpuRenderer.renderTarget.ensureDepthStencil();\n\n            gpuRenderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            gpuRenderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                gpuRenderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                gpuRenderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            gpuRenderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            gpuRenderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                gpuRenderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                gpuRenderer.renderTarget.clear(null, CLEAR.STENCIL);\n                gpuRenderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                gpuRenderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                gpuRenderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            gpuRenderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n/**\n * Options for the background system.\n * @category rendering\n * @advanced\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /** Alias for `backgroundColor` */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * This value determines whether the canvas is initialized with alpha transparency support.\n     * Note: This cannot be changed after initialization. If set to `1`, the canvas will remain opaque,\n     * even if a transparent background color is set later.\n     * @default 1\n     */\n    backgroundAlpha?: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @default true\n     */\n    clearBeforeRender?: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @category rendering\n * @advanced\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        // #if _DEBUG\n\n        const incoming = Color.shared.setValue(value);\n\n        if (incoming.alpha < 1 && this._backgroundColor.alpha === 1)\n        {\n            warn(\n                'Cannot set a transparent background on an opaque canvas. '\n                + 'To enable transparency, set backgroundAlpha < 1 when initializing your Application.'\n            );\n        }\n        // #endif\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n", "import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @category rendering\n * @internal\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList?: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n    private readonly _blendModeStack: BLEND_MODES[] = [];\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.prerender.add(this);\n    }\n\n    public prerender()\n    {\n        // make sure we reset the blend modes to normal\n        // this way the next render will register any changes\n        this._activeBlendMode = 'normal';\n        this._isAdvanced = false;\n    }\n\n    /**\n     * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n     * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n     * @param blendMode - The blend mode to activate.\n     * @param instructionSet - The instruction set being built.\n     */\n    public pushBlendMode(renderable: Renderable | RenderGroup, blendMode: BLEND_MODES, instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.push(blendMode);\n\n        this.setBlendMode(renderable, blendMode, instructionSet);\n    }\n\n    /**\n     * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public popBlendMode(instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.pop();\n        const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? 'normal';\n\n        this.setBlendMode(null, blendMode, instructionSet);\n    }\n\n    /**\n     * Ensure a blend mode switch is added to the instruction set when the mode changes.\n     * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n     * rendered within a single filter pass.\n     * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n     * @param blendMode - The target blend mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public setBlendMode(\n        renderable: Renderable | RenderGroup | null,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet\n    )\n    {\n        const isRenderGroup = renderable instanceof RenderGroup;\n\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced && renderable && !isRenderGroup)\n            {\n                this._renderableList?.push(renderable);\n            }\n\n            return;\n        }\n\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n\n        this._activeBlendMode = blendMode;\n\n        if (!renderable) return;\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);\n    }\n\n    private _beginAdvancedBlendMode(renderable: Renderable | RenderGroup, instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n                + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        const filterEffect = this._ensureFilterEffect(blendMode);\n        const isRenderGroup = renderable instanceof RenderGroup;\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            filterEffect,\n            renderables: isRenderGroup ? null : [renderable],\n            container: isRenderGroup ? renderable.root : null,\n            canBundle: false\n        };\n\n        this._renderableList = instruction.renderables;\n\n        instructionSet.add(instruction);\n    }\n\n    private _ensureFilterEffect(blendMode: BLEND_MODES): FilterEffect\n    {\n        let filterEffect: FilterEffect = this._filterHash[blendMode];\n\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        return filterEffect;\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._isAdvanced = false;\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (!this._isAdvanced) return;\n\n        this._endAdvancedBlendMode(instructionSet);\n    }\n\n    /** @internal */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * Controls the output format and quality of extracted images.\n * @example\n * ```ts\n * // Extract as PNG (default)\n * const pngImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // Extract as JPEG with quality setting\n * const jpgImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'jpg',\n *     quality: 0.8\n * });\n *\n * // Extract as WebP for better compression\n * const webpImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'webp',\n *     quality: 0.9\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface ImageOptions\n{\n    /**\n     * The format of the extracted image.\n     * - 'png': Lossless format, best for images with text or sharp edges\n     * - 'jpg': Lossy format, smaller file size, good for photos\n     * - 'webp': Modern format with better compression\n     * @example\n     * ```ts\n     * // Extract as PNG\n     * const pngImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'png'\n     * });\n     * // Extract as JPEG\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     * });\n     * ```\n     * @default 'png'\n     */\n    format?: Formats;\n\n    /**\n     * The quality of the extracted image, between 0 and 1.\n     * Only applies to lossy formats (jpg, webp).\n     * - 1: Maximum quality\n     * - 0: Maximum compression\n     * @example\n     * ```ts\n     * // Extract as JPEG with 80% quality\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     *     quality: 0.8\n     * });\n     * // Extract as WebP with 90% quality\n     * const webpImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'webp',\n     *     quality: 0.9\n     * });\n     * ```\n     * @default 1\n     */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * These options control how content is extracted and processed from the renderer.\n * @example\n * ```ts\n * // Basic extraction\n * const pixels = renderer.extract.pixels({\n *     target: sprite,\n * });\n *\n * // Extract with custom region and resolution\n * const canvas = renderer.extract.canvas({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n * });\n *\n * // Extract with background color and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface BaseExtractOptions\n{\n    /**\n     * The target to extract. Can be a Container or Texture.\n     * @example\n     * ```ts\n     * // Extract from a sprite\n     * const sprite = new Sprite(texture);\n     * renderer.extract.pixels({ target: sprite });\n     *\n     * // Extract from a texture directly\n     * renderer.extract.pixels({ target: texture });\n     * ```\n     */\n    target: Container | Texture;\n\n    /**\n     * The region of the target to extract. If not specified, extracts the entire target.\n     * @example\n     * ```ts\n     * // Extract a specific region\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the extracted content. Higher values create sharper images.\n     * @default 1\n     * @example\n     * ```ts\n     * // Extract at 2x resolution for retina displays\n     * renderer.extract.image({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the extracted content before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing during extraction.\n     * Improves quality but may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Enable anti-aliasing for smoother edges\n     * renderer.extract.image({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * Combines base extraction options with image-specific settings.\n * @example\n * ```ts\n * // Basic PNG extraction\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // High-quality JPEG with custom region\n * const image = await renderer.extract.image({\n *     target: container,\n *     format: 'jpg',\n *     quality: 0.9,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // WebP with background and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     format: 'webp',\n *     quality: 0.8,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - {@link ImageOptions} for image format and quality settings\n *\n * Common use cases:\n * - Capturing game screenshots\n * - Saving rendered content\n * - Creating image thumbnails\n * - Exporting canvas content\n * @see {@link ExtractSystem.image} For the method that uses these options\n * @see {@link ExtractSystem.base64} For base64 encoding\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * Combines base extraction options with download-specific settings.\n * @example\n * ```ts\n * // Basic download with default filename\n * renderer.extract.download({\n *     target: sprite\n * });\n *\n * // Download with custom filename and region\n * renderer.extract.download({\n *     target: container,\n *     filename: 'screenshot.png',\n *     frame: new Rectangle(0, 0, 100, 100)\n * });\n *\n * // Download with high resolution and background\n * renderer.extract.download({\n *     target: stage,\n *     filename: 'hd-capture.png',\n *     resolution: 2,\n *     clearColor: '#ff0000'\n * });\n *\n * // Download with anti-aliasing\n * renderer.extract.download({\n *     target: graphics,\n *     filename: 'smooth.png',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - Additional download-specific options\n *\n * Common use cases:\n * - Saving game screenshots\n * - Exporting rendered content\n * - Creating downloadable assets\n * - Saving canvas state\n * @see {@link ExtractSystem.download} For the method that uses these options\n * @see {@link ExtractSystem.image} For creating images without download\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /**\n     * The filename to use when downloading the content.\n     * Should include the desired file extension (e.g., .png).\n     * @default 'image.png'\n     * @example\n     * ```ts\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'my-screenshot.png'\n     * });\n     * ```\n     */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer. Represents a union of all possible extraction option types.\n * Used by various extraction methods to support different output formats and configurations.\n * @example\n * ```ts\n * // Basic canvas extraction\n * const canvas = renderer.extract.canvas({\n *     target: sprite\n * });\n *\n * // Image extraction with format\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png',\n *     quality: 1\n * });\n *\n * // Download with filename\n * renderer.extract.download({\n *     target: sprite,\n *     filename: 'screenshot.png'\n * });\n *\n * // Advanced extraction with multiple options\n * const image = await renderer.extract.image({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     format: 'webp',\n *     quality: 0.8\n * });\n * ```\n *\n * Supports three types of options:\n * - {@link BaseExtractOptions} - Basic extraction settings\n * - {@link ExtractImageOptions} - Image-specific settings with format and quality\n * - {@link ExtractDownloadOptions} - Download settings with filename\n *\n * Common use cases:\n * - Extracting raw pixels\n * - Creating canvas elements\n * - Generating downloadable images\n * - Taking screenshots\n * - Creating thumbnails\n * @see {@link ExtractSystem.canvas} For canvas extraction\n * @see {@link ExtractSystem.image} For image extraction\n * @see {@link ExtractSystem.download} For downloading content\n * @category rendering\n * @advanced\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * ```ts\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n * ```\n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n * @category rendering\n * @standard\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /**\n     * Default options for image extraction.\n     * @example\n     * ```ts\n     * // Customize default options\n     * ExtractSystem.defaultImageOptions.format = 'webp';\n     * ExtractSystem.defaultImageOptions.quality = 0.8;\n     *\n     * // Use defaults\n     * const image = await renderer.extract.image(sprite);\n     * ```\n     */\n    public static defaultImageOptions: ImageOptions = {\n        format: 'png' as Formats,\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Creates an IImage from a display object or texture.\n     * @param options - Options for creating the image, or the target to extract\n     * @returns Promise that resolves with the generated IImage\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const image = await renderer.extract.image(sprite);\n     * document.body.appendChild(image);\n     *\n     * // Advanced usage with options\n     * const image = await renderer.extract.image({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2,\n     *     clearColor: '#ff0000',\n     *     antialias: true\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const image = await renderer.extract.image(texture);\n     * ```\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.base64} For base64 string output\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ImageLike} For the image interface\n     * @category rendering\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>\n    {\n        const image = DOMAdapter.get().createImage();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Converts the target into a base64 encoded string.\n     *\n     * This method works by first creating\n     * a canvas using `Extract.canvas` and then converting it to a base64 string.\n     * @param options - The options for creating the base64 string, or the target to extract\n     * @returns Promise that resolves with the base64 encoded string\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const base64 = await renderer.extract.base64(sprite);\n     * console.log(base64); // data:image/png;base64,...\n     *\n     * // Advanced usage with options\n     * const base64 = await renderer.extract.base64({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2\n     * });\n     * ```\n     * @throws Will throw an error if the platform doesn't support any of:\n     * - ICanvas.toDataURL\n     * - ICanvas.toBlob\n     * - ICanvas.convertToBlob\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @category rendering\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders the target to it and returns it.\n     * This method is useful for creating static images or when you need direct canvas access.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns A Canvas element with the texture rendered on\n     * @example\n     * ```ts\n     * // Basic canvas extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const canvas = renderer.extract.canvas(sprite);\n     * document.body.appendChild(canvas);\n     *\n     * // Extract with custom region\n     * const canvas = renderer.extract.canvas({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const canvas = renderer.extract.canvas({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const canvas = renderer.extract.canvas(texture);\n     *\n     * // Extract with anti-aliasing\n     * const canvas = renderer.extract.canvas({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n     * with integer values between 0 and 255 (inclusive).\n     * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n     * @example\n     * ```ts\n     * // Basic pixel extraction\n     * const sprite = new Sprite(texture);\n     * const pixels = renderer.extract.pixels(sprite);\n     * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n     *\n     * // Extract with custom region\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For image output\n     * @category rendering\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Creates a texture from a display object or existing texture.\n     *\n     * This is useful for creating\n     * reusable textures from rendered content or making copies of existing textures.\n     * > [!NOTE] The returned texture should be destroyed when no longer needed\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns A new texture containing the extracted content\n     * @example\n     * ```ts\n     * // Basic texture extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const extractedTexture = renderer.extract.texture(sprite);\n     *\n     * // Extract with custom region\n     * const regionTexture = renderer.extract.texture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const hiResTexture = renderer.extract.texture({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Create a new sprite from extracted texture\n     * const newSprite = new Sprite(\n     *     renderer.extract.texture({\n     *         target: graphics,\n     *         antialias: true\n     *     })\n     * );\n     *\n     * // Clean up when done\n     * extractedTexture.destroy(true);\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link Texture} For texture management\n     * @see {@link GenerateTextureSystem} For texture generation\n     * @category rendering\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Extracts and downloads content from the renderer as an image file.\n     * This is a convenient way to save screenshots or export rendered content.\n     * > [!NOTE] The download will use PNG format regardless of the filename extension\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     * @example\n     * ```ts\n     * // Basic download with default filename\n     * const sprite = new Sprite(texture);\n     * renderer.extract.download(sprite); // Downloads as 'image.png'\n     *\n     * // Download with custom filename\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'screenshot.png'\n     * });\n     *\n     * // Download with custom region\n     * renderer.extract.download({\n     *     target: container,\n     *     filename: 'region.png',\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Download with high resolution and background\n     * renderer.extract.download({\n     *     target: stage,\n     *     filename: 'hd-screenshot.png',\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Download with anti-aliasing\n     * renderer.extract.download({\n     *     target: graphics,\n     *     filename: 'smooth.png',\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractDownloadOptions} For detailed options\n     * @see {@link ExtractSystem.image} For creating images without download\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @category rendering\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        /* eslint-disable no-restricted-globals */\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        /* eslint-enable no-restricted-globals */\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * The image will be displayed in the browser's console using CSS background images.\n     * @param options - The options for logging the image, or the target to log\n     * @param options.width - The width of the logged image preview in the console (in pixels)\n     * @example\n     * ```ts\n     * // Basic usage\n     * const sprite = new Sprite(texture);\n     * renderer.extract.log(sprite);\n     * ```\n     * @see {@link ExtractSystem.canvas} For getting raw canvas output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     * @advanced\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link Texture}\n * @category rendering\n * @advanced\n */\nexport class RenderTexture extends Texture\n{\n    /**\n     * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n     * @param options - Options for the RenderTexture, including width, height, and dynamic.\n     * @returns A new RenderTexture instance.\n     * @example\n     * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n     * rt.resize(500, 500);\n     */\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        // Pass dynamic to the RenderTexture constructor if present in options\n        const { dynamic, ...rest } = options;\n\n        return new RenderTexture({\n            source: new TextureSource(rest),\n            dynamic: dynamic ?? false,\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n", "import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n    /**\n     * The container to generate the texture from.\n     * This can be any display object like Sprite, Container, or Graphics.\n     * @example\n     * ```ts\n     * const graphics = new Graphics()\n     *     .circle(0, 0, 50)\n     *     .fill('red');\n     *\n     * const texture = renderer.generateTexture({\n     *     target: graphics\n     * });\n     * ```\n     */\n    target: Container;\n\n    /**\n     * The region of the container that should be rendered.\n     * If not specified, defaults to the local bounds of the container.\n     * @example\n     * ```ts\n     * // Extract only a portion of the container\n     * const texture = renderer.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the texture being generated.\n     * Higher values create sharper textures at the cost of memory.\n     * @default renderer.resolution\n     * @example\n     * ```ts\n     * // Generate a high-resolution texture\n     * const hiResTexture = renderer.generateTexture({\n     *     target: sprite,\n     *     resolution: 2 // 2x resolution\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the texture before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Generate a smooth texture\n     * const texture = renderer.generateTexture({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n\n    /**\n     * Advanced options for configuring the texture source.\n     * Controls texture properties like scale mode and filtering.\n     * @advanced\n     * @example\n     * ```ts\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     textureSourceOptions: {\n     *         scaleMode: 'linear',\n     *     }\n     * });\n     * ```\n     */\n    textureSourceOptions?: GenerateTextureSourceOptions;\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Creates a texture from a display object that can be used for creating sprites and other textures.\n     * This is particularly useful for optimizing performance when a complex container needs to be reused.\n     * @param options - Generate texture options or a container to convert to texture\n     * @returns A new RenderTexture containing the rendered display object\n     * @example\n     * ```ts\n     * // Basic usage with a container\n     * const container = new Container();\n     * container.addChild(\n     *     new Graphics()\n     *         .circle(0, 0, 50)\n     *         .fill('red')\n     * );\n     *\n     * const texture = renderer.textureGenerator.generateTexture(container);\n     *\n     * // Advanced usage with options\n     * const texture = renderer.textureGenerator.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n     *     resolution: 2,                        // High DPI\n     *     clearColor: '#ff0000',               // Red background\n     *     antialias: true                      // Smooth edges\n     * });\n     *\n     * // Create a sprite from the generated texture\n     * const sprite = new Sprite(texture);\n     *\n     * // Clean up when done\n     * texture.destroy(true);\n     * ```\n     * @see {@link GenerateTextureOptions} For detailed texture generation options\n     * @see {@link RenderTexture} For the type of texture created\n     * @category rendering\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @category utils\n * @internal\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @category utils\n * @internal\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../utils/data/clean';\nimport { type GPUDataOwner, type Renderer } from '../types';\nimport { type Renderable } from './Renderable';\nimport { type RenderOptions } from './system/AbstractRenderer';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { System } from './system/System';\n\n/**\n * Data stored on a GC-managed resource.\n * @category rendering\n * @advanced\n */\nexport interface GCData\n{\n    /** Index in the managed resources array */\n    index?: number;\n    /** Type of the resource */\n    type: 'resource' | 'renderable';\n}\n\n/**\n * Interface for resources that can be garbage collected.\n * @category rendering\n * @advanced\n */\nexport interface GCable extends GPUDataOwner\n{\n    /** Timestamp of last use */\n    _gcLastUsed: number;\n    /** GC tracking data, null if not being tracked */\n    _gcData?: GCData | null;\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    autoGarbageCollect?: boolean;\n    /** An optional callback for when an item is touched */\n    _onTouch?(now: number): void;\n}\n\ntype GCableEventEmitter = GCable & Pick<EventEmitter, 'once' | 'off'>;\n\ninterface GCResourceHashEntry\n{\n    context: any;\n    hash: string;\n    type: GCData['type'];\n    priority: number;\n}\n\n/**\n * Options for the {@link GCSystem}.\n * @category rendering\n * @advanced\n */\nexport interface GCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector.\n     * @default true\n     */\n    gcActive: boolean;\n    /**\n     * The maximum time in milliseconds a resource can be unused before being garbage collected.\n     * @default 60000\n     */\n    gcMaxUnusedTime: number;\n    /**\n     * How frequently to run garbage collection in milliseconds.\n     * @default 30000\n     */\n    gcFrequency: number;\n}\n\n/**\n * A unified garbage collection system for managing GPU resources.\n * Resources register themselves with a cleanup callback and are automatically\n * cleaned up when they haven't been used for a specified amount of time.\n * @example\n * ```ts\n * // Register a resource for GC\n * gc.addResource(myResource, () => {\n *     // cleanup logic here\n *     myResource.unload();\n * });\n *\n * // Touch the resource when used (resets idle timer)\n * gc.touch(myResource);\n *\n * // Remove from GC tracking (e.g., on manual destroy)\n * gc.removeResource(myResource);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GCSystem implements System<GCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'gc',\n        priority: 0,\n    } as const;\n\n    /** Default options for the GCSystem */\n    public static defaultOptions: GCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        gcActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        gcMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        gcFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of resources being tracked for garbage collection */\n    private readonly _managedResources: GCableEventEmitter[] = [];\n    private readonly _managedResourceHashes: GCResourceHashEntry[] = [];\n    private readonly _managedCollections: {context: any, collection: string, type: 'hash' | 'array'}[] = [];\n\n    /** ID of the GC scheduler handler */\n    private _handler: number;\n    private _collectionsHandler: number;\n\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n\n    /** Current timestamp used for age calculations */\n    public now: number;\n\n    private _ready = false;\n\n    /**\n     * Creates a new GCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options\n     */\n    public init(options: GCSystemOptions): void\n    {\n        options = { ...GCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.gcMaxUnusedTime;\n        this._frequency = options.gcFrequency;\n\n        this.enabled = options.gcActive;\n        this.now = performance.now();\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            this._handler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    this._ready = true;\n                },\n                this._frequency,\n                false\n            );\n            // Schedule periodic hash table cleanup\n            this._collectionsHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedCollections)\n                    {\n                        const { context, collection, type } = hash;\n\n                        if (type === 'hash')\n                        {\n                            context[collection] = cleanHash(context[collection]);\n                        }\n                        else\n                        {\n                            context[collection] = cleanArray(context[collection]);\n                        }\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._collectionsHandler);\n            this._handler = 0;\n            this._collectionsHandler = 0;\n        }\n    }\n\n    /**\n     * Called before rendering. Updates the current timestamp.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    protected prerender({ container }: RenderOptions): void\n    {\n        this.now = performance.now();\n        container.renderGroup.gcTick = this._renderer.tick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /** Performs garbage collection after rendering. */\n    protected postrender(): void\n    {\n        if (!this._ready || !this.enabled) return;\n\n        this.run();\n        this._ready = false;\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n        renderGroup.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n\n    /**\n     * Registers a collection for garbage collection tracking.\n     * @param context - The object containing the collection\n     * @param collection - The property name on context that holds the collection\n     * @param type - The type of collection to track ('hash' or 'array')\n     */\n    public addCollection(context: any, collection: string, type: 'hash' | 'array'): void\n    {\n        this._managedCollections.push({\n            context,\n            collection,\n            type,\n        });\n    }\n\n    /**\n     * Registers a resource for garbage collection tracking.\n     * @param resource - The resource to track\n     * @param type - The type of resource to track\n     */\n    public addResource(resource: GCableEventEmitter, type: GCData['type']): void\n    {\n        // Already being tracked\n        if (resource._gcLastUsed !== -1)\n        {\n            resource._gcLastUsed = this.now;\n            resource._onTouch?.(this.now);\n\n            return;\n        }\n\n        const index = this._managedResources.length;\n\n        resource._gcData = {\n            index,\n            type,\n        };\n        resource._gcLastUsed = this.now;\n        resource._onTouch?.(this.now);\n        resource.once('unload', this.removeResource, this);\n\n        this._managedResources.push(resource);\n    }\n\n    /**\n     * Removes a resource from garbage collection tracking.\n     * Call this when manually destroying a resource.\n     * @param resource - The resource to stop tracking\n     */\n    public removeResource(resource: GCable): void\n    {\n        const gcData = resource._gcData;\n\n        if (!gcData) return;\n\n        const index = gcData.index;\n        const last = this._managedResources.length - 1;\n\n        // Swap with last element for O(1) removal\n        if (index !== last)\n        {\n            const lastResource = this._managedResources[last];\n\n            this._managedResources[index] = lastResource;\n            lastResource._gcData.index = index;\n        }\n\n        this._managedResources.length--;\n        resource._gcData = null;\n        resource._gcLastUsed = -1;\n    }\n\n    /**\n     * Registers a hash-based resource collection for garbage collection tracking.\n     * Resources in the hash will be automatically tracked and cleaned up when unused.\n     * @param context - The object containing the hash property\n     * @param hash - The property name on context that holds the resource hash\n     * @param type - The type of resources in the hash ('resource' or 'renderable')\n     * @param priority - Processing priority (lower values are processed first)\n     */\n    public addResourceHash(context: any, hash: string, type: GCData['type'], priority: number = 0): void\n    {\n        this._managedResourceHashes.push({\n            context,\n            hash,\n            type,\n            priority,\n        });\n\n        this._managedResourceHashes.sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused resources.\n     * Removes resources that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = performance.now();\n        const managedResourceHashes = this._managedResourceHashes;\n\n        for (const hashEntry of managedResourceHashes)\n        {\n            this.runOnHash(hashEntry, now);\n        }\n\n        let writeIndex = 0;\n\n        for (let i = 0; i < this._managedResources.length; i++)\n        {\n            const resource = this._managedResources[i];\n\n            writeIndex = this.runOnResource(resource, now, writeIndex);\n        }\n\n        this._managedResources.length = writeIndex;\n    }\n\n    protected updateRenderableGCTick(renderable: Renderable & GCable, now: number): void\n    {\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n        const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n        // Update last used time if the renderable's group was rendered this tick\n        if ((renderGroup?.gcTick ?? 0) === currentTick)\n        {\n            renderable._gcLastUsed = now;\n            renderable._onTouch?.(now);\n        }\n    }\n\n    protected runOnResource(resource: GCableEventEmitter, now: number, writeIndex: number): number\n    {\n        const gcData = resource._gcData;\n\n        // special case for renderables as we do not check every frame if they are being used\n        if (gcData.type === 'renderable')\n        {\n            this.updateRenderableGCTick(resource as Renderable, now);\n        }\n\n        const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n        if (isRecentlyUsed || !resource.autoGarbageCollect)\n        {\n            this._managedResources[writeIndex] = resource;\n            gcData.index = writeIndex;\n            writeIndex++;\n        }\n        else\n        {\n            // Call the cleanup function\n            resource.unload();\n            resource._gcData = null;\n            resource._gcLastUsed = -1;\n            resource.off('unload', this.removeResource, this);\n        }\n\n        return writeIndex;\n    }\n\n    /**\n     * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n     * @param hashValue - The original hash to clone from\n     * @param stopKey - The key to stop at (exclusive)\n     * @returns A new hash object with copied entries\n     */\n    private _createHashClone(hashValue: Record<string, GCable>, stopKey: string): Record<string, GCable>\n    {\n        const hashClone: Record<string, GCable> = Object.create(null);\n\n        for (const k in hashValue)\n        {\n            if (k === stopKey) break;\n            if (hashValue[k] !== null) hashClone[k] = hashValue[k];\n        }\n\n        return hashClone;\n    }\n\n    protected runOnHash(hashEntry: GCResourceHashEntry, now: number): void\n    {\n        const { context, hash, type } = hashEntry;\n\n        const hashValue = context[hash] as Record<string, GCable>;\n        let hashClone: Record<string, GCable> | null = null;\n        let nullCount = 0;\n\n        for (const key in hashValue)\n        {\n            const resource = hashValue[key];\n\n            // check if the value is null\n            if (resource === null)\n            {\n                nullCount++;\n\n                // Lazily create the clone to clean up null entries when threshold is reached\n                if (nullCount === 10000 && !hashClone)\n                {\n                    hashClone = this._createHashClone(hashValue, key);\n                }\n\n                continue;\n            }\n\n            // If no GC data, then the resource has been added since the last garbage collection\n            if (resource._gcLastUsed === -1)\n            {\n                resource._gcLastUsed = now;\n                resource._onTouch?.(now);\n\n                if (hashClone) hashClone[key] = resource;\n\n                continue;\n            }\n\n            // special case for renderables as we do not check every frame if they are being used\n            if (type === 'renderable')\n            {\n                this.updateRenderableGCTick(resource as Renderable, now);\n            }\n\n            const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n            if (!isRecentlyUsed && resource.autoGarbageCollect)\n            {\n                // Lazily create the clone only when we need to remove something\n                if (!hashClone)\n                {\n                    // we can set the value to null here to avoid having to create a new hash object\n                    // only when it crosses the 10000 threshold do we need to create a new hash object\n                    if (nullCount + 1 !== 10000)\n                    {\n                        hashValue[key] = null;\n                        nullCount++;\n                    }\n                    else\n                    {\n                        hashClone = this._createHashClone(hashValue, key);\n                    }\n                }\n\n                if (type === 'renderable')\n                {\n                    const res = resource as Renderable;\n                    const renderGroup = res.renderGroup ?? res.parentRenderGroup;\n\n                    if (renderGroup) renderGroup.structureDidChange = true;\n                }\n\n                // Call the cleanup function\n                resource.unload();\n                resource._gcData = null;\n                resource._gcLastUsed = -1;\n            }\n            else if (hashClone)\n            {\n                hashClone[key] = resource;\n            }\n        }\n\n        // Only replace the hash if something was removed\n        if (hashClone)\n        {\n            context[hash] = hashClone;\n        }\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n\n        this._managedResources.forEach((resource) =>\n        {\n            resource.off('unload', this.removeResource, this);\n        });\n        this._managedResources.length = 0;\n        this._managedResourceHashes.length = 0;\n        this._managedCollections.length = 0;\n        this._renderer = null as any as Renderer;\n    }\n}\n", "/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\n/**\n * Type definition for the global uniforms used in the renderer.\n * This includes projection matrix, world transform matrix, world color, and resolution.\n * @category rendering\n * @advanced\n */\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\n/**\n * Options for the global uniforms system.\n * This includes size, projection matrix, world transform matrix, world color, and offset.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\n/**\n * Data structure for the global uniforms used in the renderer.\n * This includes the projection matrix, world transform matrix, world color, resolution, and bind group.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\n/** @internal */\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @category rendering\n * @advanced\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._globalUniformDataStack.length = 0;\n        this._uniformsPool.length = 0;\n        this._activeUniforms.length = 0;\n        this._bindGroupPool.length = 0;\n        this._activeBindGroups.length = 0;\n        this._currentGlobalUniformData = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @category rendering\n * @advanced\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n", "import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n * @category utils\n * @advanced\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @category rendering\n * @advanced\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @category rendering\n * @advanced\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { deprecation } from '../../../../utils/logging/deprecation';\n\nimport type { Renderer } from '../../types';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @category rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n * @advanced\n * @deprecated since 8.15.0\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n * @example\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     * @deprecated since 8.15.0\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'RenderableGCSystem.enabled is deprecated, please use the GCSystem.enabled instead.');\n        // #endif\n\n        return this._renderer.gc.enabled;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'RenderableGCSystem.enabled is deprecated, please use the GCSystem.enabled instead.');\n        // #endif\n        this._renderer.gc.enabled = value;\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation('8.15.0', 'RenderableGCSystem.addManagedHash is deprecated, please use the GCSystem.addCollection instead.');\n        // #endif\n        this._renderer.gc.addCollection(context, hash, 'hash');\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation('8.15.0', 'RenderableGCSystem.addManagedArray is deprecated, please use the GCSystem.addCollection instead.');\n        // #endif\n        this._renderer.gc.addCollection(context, hash, 'array');\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param _renderable - The renderable to track\n     * @deprecated since 8.15.0\n     */\n    public addRenderable(_renderable: Renderable): void\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'RenderableGCSystem.addRenderable is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.addResource(_renderable, 'renderable');\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'RenderableGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.run();\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { type Renderer } from '../../types';\n\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @deprecated since 8.15.0\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @deprecated since 8.15.0\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @deprecated since 8.15.0\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /**\n     * Default options for the TextureGCSystem\n     * @deprecated since 8.15.0\n     */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get count() { return this._renderer.tick; }\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get checkCount() { return this._checkCount; }\n    public set checkCount(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._checkCount = value;\n    }\n    private _checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     * @deprecated since 8.15.0\n     */\n    public get maxIdle() { return (this._renderer.gc.maxUnusedTime / 1000) * 60; }\n    public set maxIdle(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.maxUnusedTime = (value / 60) * 1000;\n    }\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     * @deprecated since 8.15.0\n     */\n    // eslint-disable-next-line dot-notation\n    public get checkCountMax() { return Math.floor(this._renderer.gc['_frequency'] / 1000); }\n    public set checkCountMax(_value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n    }\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     * @deprecated since 8.15.0\n     */\n    public get active() { return this._renderer.gc.enabled; }\n    public set active(value: boolean)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.enabled = value;\n    }\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        if (options.textureGCActive !== TextureGCSystem.defaultOptions.textureGCActive)\n        { this.active = options.textureGCActive; }\n        if (options.textureGCMaxIdle !== TextureGCSystem.defaultOptions.textureGCMaxIdle)\n        { this.maxIdle = options.textureGCMaxIdle; }\n        if (options.textureGCCheckCountMax !== TextureGCSystem.defaultOptions.textureGCCheckCountMax)\n        { this.checkCountMax = options.textureGCCheckCountMax; }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     * @deprecated since 8.15.0\n     */\n    public run(): void\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.run();\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @category rendering\n * @advanced\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @category rendering\n * @advanced\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n", "import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry';\nimport { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nGlobalResourceRegistry.register(canvasCache);\n\n/**\n * @param canvas\n * @param options\n * @internal\n */\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\n/**\n * @param canvas\n * @internal\n */\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { type RendererOptions } from '../../types';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     */\n    height?: number;\n    /** The canvas to use as a view, optional. */\n    canvas?: ICanvas;\n    /**\n     * Alias for `canvas`.\n     * @deprecated since 8.0.0\n     */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     *\n     * This is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** The resolution / device pixel ratio of the renderer. */\n    resolution?: number;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer. */\n    depth?: boolean;\n}\n\n/**\n * Options for destroying the ViewSystem.\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @advanced\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions> >\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n     * @type {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = (options as RendererOptions).backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @example\n     * viewSystem.destroy();\n     * viewSystem.destroy(true);\n     * viewSystem.destroy({ removeView: true });\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        this.texture.destroy();\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n", "import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GCSystem } from '../GCSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\n/**\n * Shared systems for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    GCSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\n/**\n * Shared render pipes for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n", "import type { Matrix } from '../../../../maths/matrix/Matrix';\n\n/**\n * @param pm\n * @param x\n * @param y\n * @param width\n * @param height\n * @param flipY\n * @internal\n */\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n", "/* eslint-disable no-restricted-globals */\nimport type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n * @internal\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CanvasRenderTarget } from '../../canvas/renderTarget/CanvasRenderTargetAdaptor';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @category rendering\n * @see environment.ICanvas\n * @see Texture\n * @see RenderTarget\n * @advanced\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle;\n    /** mip level to render to (subresource) */\n    mipLevel: number;\n    /** array layer to render to (subresource) */\n    layer: number;\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\ntype RendererRenderTarget = GlRenderTarget | GpuRenderTarget | CanvasRenderTarget;\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @category rendering\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends RendererRenderTarget>\n{\n    /**\n     * Initializes the adaptor.\n     * @param {Renderer} renderer - the renderer\n     * @param {RenderTargetSystem} renderTargetSystem - the render target system\n     */\n    init(\n        renderer: Renderer,\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /**\n     * A function copies the contents of a render surface to a texture\n     * @param {RenderTarget} sourceRenderSurfaceTexture - the render surface to copy from\n     * @param {Texture} destinationTexture - the texture to copy to\n     * @param {object} originSrc - the origin of the copy\n     * @param {number} originSrc.x - the x origin of the copy\n     * @param {number} originSrc.y - the y origin of the copy\n     * @param {object} size - the size of the copy\n     * @param {number} size.width - the width of the copy\n     * @param {number} size.height - the height of the copy\n     * @param {object} originDest - the destination origin (top left to paste from!)\n     * @param {number} originDest.x - the x destination origin of the copy\n     * @param {number} originDest.y - the y destination origin of the copy\n     */\n    copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /**\n     * starts a render pass on the render target\n     * @param {RenderTarget} renderTarget - the render target to start the render pass on\n     * @param {CLEAR_OR_BOOL} clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111*\n     * @param {RgbaArray} [clearColor] - the color to clear to\n     * @param {Rectangle} [viewport] - the viewport to use\n     */\n    startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle,\n        /** mip level to render to (subresource) */\n        mipLevel?: number,\n        /** array layer to render to (subresource) */\n        layer?: number\n    ): void\n\n    /**\n     * clears the current render target to the specified color\n     * @param {RenderTarget} renderTarget - the render target to clear\n     * @param {CLEAR_OR_BOOL} clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111*\n     * @param {RgbaArray} [clearColor] - the color to clear to\n     * @param {Rectangle} [viewport] - the viewport to use\n     */\n    clear(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle,\n        /** mip level to clear (subresource) */\n        mipLevel?: number,\n        /** array layer to clear (subresource) */\n        layer?: number\n    ): void\n\n    /**\n     * finishes the current render pass\n     * @param {RenderTarget} renderTarget - the render target to finish the render pass for\n     */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /**\n     * called after the render pass is finished\n     * @param {RenderTarget} renderTarget - the render target that was rendered to\n     */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /**\n     * called before the render main pass is started\n     * @param {RenderTarget} renderTarget - the render target that will be rendered to\n     */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target\n     * @param {RenderTarget} renderTarget - the render target to initialize\n     */\n    initGpuRenderTarget(\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /**\n     * resizes the gpu render target\n     * @param {RenderTarget} renderTarget - the render target to resize\n     */\n    resizeGpuRenderTarget(\n        renderTarget: RenderTarget\n    ): void\n\n    /**\n     * destroys the gpu render target\n     * @param {RendererRenderTarget} gpuRenderTarget - the gpu render target to destroy\n     */\n    destroyGpuRenderTarget(gpuRenderTarget: RENDER_TARGET): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderTargetSystem<RENDER_TARGET extends RendererRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass */\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /** the current mip level being rendered to (for texture subresources) */\n    public mipLevel = 0;\n    /** the current array layer being rendered to (for array-backed targets) */\n    public layer = 0;\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.gc.addCollection(this, '_gpuRenderTargetHash', 'hash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     * @param options.mipLevel - the mip level to render to\n     * @param options.layer - The layer of the render target to render to. Used for array or 3D textures, or when rendering\n     * to a specific layer of a layered render target. Optional.\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame,\n        mipLevel,\n        layer\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle;\n        mipLevel?: number;\n        layer?: number;\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame,\n            mipLevel ?? 0,\n            layer ?? 0\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provided and the render surface is a {@link Texture}, the frame of the texture will be used.\n     *\n     * IMPORTANT:\n     * - `frame` is treated as **base mip (mip 0) pixel space**.\n     * - When `mipLevel > 0`, the viewport derived from `frame` is scaled by \\(2^{mipLevel}\\) and clamped to the\n     *   mip dimensions. This keeps \"render the same region\" semantics consistent across mip levels.\n     * - When `renderSurface` is a {@link Texture}, `renderer.render({ container, target: texture, mipLevel })` will\n     *   render into\n     *   the underlying {@link TextureSource} (Pixi will create/use a {@link RenderTarget} for the source) using the\n     *   texture's frame to define the region (in mip 0 space).\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @param mipLevel - the mip level to render to\n     * @param layer - the layer (or slice) of the render surface to render to. For array textures,\n     * 3D textures, or cubemaps, this specifies the target layer or face. Defaults to 0 (the first layer/face).\n     * Ignored for surfaces that do not support layers.\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle,\n        mipLevel = 0,\n        layer = 0\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n        const arrayLayerCount = source.arrayLayerCount || 1;\n\n        if ((layer | 0) !== layer)\n        {\n            layer |= 0;\n        }\n\n        if (layer < 0 || layer >= arrayLayerCount)\n        {\n            throw new Error(`[RenderTargetSystem] layer ${layer} is out of bounds (arrayLayerCount=${arrayLayerCount}).`);\n        }\n\n        this.mipLevel = mipLevel | 0;\n        this.layer = layer | 0;\n\n        const pixelWidth = Math.max(source.pixelWidth >> mipLevel, 1);\n        const pixelHeight = Math.max(source.pixelHeight >> mipLevel, 1);\n\n        // If no explicit frame was provided, Texture targets default to their frame.\n        // IMPORTANT: frame is treated as base-level (mip 0) coordinates; when rendering to mip N,\n        // the viewport is scaled down by 2^N.\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n            const scale = 1 << Math.max(mipLevel | 0, 0);\n\n            // Convert frame to pixel units (mip 0), then scale to the requested mip level.\n            const baseX = ((frame.x * resolution) + 0.5) | 0;\n            const baseY = ((frame.y * resolution) + 0.5) | 0;\n            const baseW = ((frame.width * resolution) + 0.5) | 0;\n            const baseH = ((frame.height * resolution) + 0.5) | 0;\n\n            // Use floor for origin and ceil for size to avoid collapsing to zero due to rounding.\n            // (When mipLevel === 0, scale === 1 so this behaves like the base-level case.)\n            let x = Math.floor(baseX / scale);\n            let y = Math.floor(baseY / scale);\n            let w = Math.ceil(baseW / scale);\n            let h = Math.ceil(baseH / scale);\n\n            // Clamp to mip dimensions.\n            x = Math.min(Math.max(x, 0), pixelWidth - 1);\n            y = Math.min(Math.max(y, 0), pixelHeight - 1);\n            w = Math.min(Math.max(w, 1), pixelWidth - x);\n            h = Math.min(Math.max(h, 1), pixelHeight - y);\n\n            viewport.x = x;\n            viewport.y = y;\n            viewport.width = w;\n            viewport.height = h;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport, mipLevel, layer);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        mipLevel = this.mipLevel,\n        layer = this.layer,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport,\n            mipLevel,\n            layer\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     * @param mipLevel - the mip level to render to\n     * @param layer - The layer of the render surface to render to. For array textures or cube maps, this specifies\n     * which layer or face to target. Defaults to 0 (the first layer).\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle,\n        mipLevel = 0,\n        layer = 0\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame, mipLevel, layer);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n            mipLevel,\n            layer,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(\n            currentRenderTargetData.renderTarget,\n            false,\n            null,\n            currentRenderTargetData.frame,\n            currentRenderTargetData.mipLevel,\n            currentRenderTargetData.layer\n        );\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture.\n     *\n     * NOTE:\n     * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n     *\n     * The following is not valid:\n     * @example\n     * const canvas = document.createElement('canvas')\n     * canvas.width = 200;\n     * canvas.height = 200;\n     *\n     * const ctx = canvas2.getContext('2d')!\n     * ctx.fillStyle = 'red'\n     * ctx.fillRect(0, 0, 200, 200);\n     *\n     * const texture = RenderTexture.create({\n     *   width: 200,\n     *   height: 200,\n     * })\n     * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n     *\n     * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n     *\n     * The best way to copy a canvas is to create a texture from it. Then render with that.\n     *\n     * Parsing in a RenderTarget canvas context (with a 2d context)\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param {Texture} destinationTexture - the texture to copy to\n     * @param {object} originSrc - the origin of the copy\n     * @param {number} originSrc.x - the x origin of the copy\n     * @param {number} originSrc.y - the y origin of the copy\n     * @param {object} size - the size of the copy\n     * @param {number} size.width - the width of the copy\n     * @param {number} size.height - the height of the copy\n     * @param {object} originDest - the destination origin (top left to paste from!)\n     * @param {number} originDest.x - the x origin of the paste\n     * @param {number} originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport, 0, this.layer);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (renderSurface.source instanceof CanvasSource)\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAM,eAAiG,CAAA;AAEvG,WAAW,kBAAkB,cAAc,aAAa,YAAY;AAQpE,eAAsB,0BAA0B,MAChD;AACI,MAAI,KAAM;AAEV,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KACzC;AACI,UAAM,MAAM,aAAa,CAAC;AAE1B,QAAI,IAAI,MAAM,KAAA,GACd;AACI,YAAM,IAAI,MAAM,KAAA;AAEhB;IACJ;EACJ;AACJ;AAQA,eAAsB,sBAAsB,KAC5C;AACI,SAAO,0BAA0B,CAAC,GAAG;AACzC;;;ACrCA,IAAI;AAQG,SAAS,sBAChB;AACI,MAAI,OAAO,eAAe,WAC1B;AACI,WAAO;EACX;AAEA,MACA;AAEI,UAAM,OAAO,IAAI,SAAS,UAAU,UAAU,UAAU,mCAAmC;AAG3F,iBAAa,KAAK,EAAE,GAAG,IAAA,GAAO,KAAK,GAAG,MAAM;EAChD,SACO,IACP;AACI,iBAAa;EACjB;AAEA,SAAO;AACX;;;ACzBO,IAAK,SAAA,CAAAA,WAAL;AAGHA,SAAAA,OAAA,MAAA,IAAO,CAAA,IAAP;AAEAA,SAAAA,OAAA,OAAA,IAAQ,KAAA,IAAR;AAEAA,SAAAA,OAAA,SAAA,IAAU,IAAA,IAAV;AAEAA,SAAAA,OAAA,OAAA,IAAQ,GAAA,IAAR;AAGAA,SAAAA,OAAA,aAAA,IAAc,KAAA,IAAd;AAEAA,SAAAA,OAAA,eAAA,IAAgB,KAAA,IAAhB;AAEAA,SAAAA,OAAA,eAAA,IAAgB,IAAA,IAAhB;AAEAA,SAAAA,OAAA,KAAA,IAAM,KAAA,IAAN;AAlBQ,SAAAA;AAAA,GAAA,SAAA,CAAA,CAAA;;;ACsCL,IAAM,eAAN,MACP;;;;EAOI,YAAY,MACZ;AACI,SAAK,QAAQ,CAAA;AACb,SAAK,QAAQ;EACjB;;;;;;;EAQO,KAAK,IAAc,IAAc,IAAc,IAClD,IAAc,IAAc,IAAc,IAC9C;AACI,UAAM,EAAE,MAAM,MAAA,IAAU;AAExB,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAC7C;AACI,YAAM,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;IACjD;AAEA,WAAO;EACX;;;;;;;;;;;;;;;;;;;EAoBO,IAAI,MACX;AACI,QAAK,KAAa,KAAK,KAAK,GAC5B;AACI,WAAK,OAAO,IAAI;AAChB,WAAK,MAAM,KAAK,IAAI;IACxB;AAEA,WAAO;EACX;;;;;EAMO,OAAO,MACd;AACI,UAAM,QAAQ,KAAK,MAAM,QAAQ,IAAI;AAErC,QAAI,UAAU,IACd;AACI,WAAK,MAAM,OAAO,OAAO,CAAC;IAC9B;AAEA,WAAO;EACX;;;;;EAMO,SAAS,MAChB;AACI,WAAO,KAAK,MAAM,QAAQ,IAAI,MAAM;EACxC;;EAGO,YACP;AACI,SAAK,MAAM,SAAS;AAEpB,WAAO;EACX;;EAGO,UACP;AACI,SAAK,UAAA;AACL,SAAK,QAAQ;AACb,SAAK,QAAQ;EACjB;;;;;EAMA,IAAW,QACX;AACI,WAAO,KAAK,MAAM,WAAW;EACjC;;;;;EAMA,IAAW,OACX;AACI,WAAO,KAAK;EAChB;AACJ;;;AC1DA,IAAM,iBAAiB;EACnB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AAsDO,IAAM,oBAAN,MAAMC,2BAEH,sBACV;;;;;;EA0EI,YAAY,QACZ;AACI,UAAA;AAhCJ,SAAO,OAAe;AAGtB,SAAgB,MAAM,IAAI,UAAU;AAMpC,SAAgB,UAAmB,uBAAO,OAAO,IAAI;AAErD,SAAgB,cAAc,uBAAO,OAAO,IAAI;AAQhD,SAAU,eAAwB,CAAA;AAGlC,SAAQ,eAAuC,uBAAO,OAAO,IAAI;AAW7D,SAAK,OAAO,OAAO;AACnB,SAAK,OAAO,OAAO;AACnB,SAAK,SAAS;AAEd,UAAM,kBAAkB,CAAC,GAAG,gBAAgB,GAAI,KAAK,OAAO,WAAW,CAAA,CAAG;AAE1E,SAAK,YAAY,GAAG,eAAe;AAEnC,SAAK,iBAAA;EACT;;;;;EAMA,MAAa,KAAK,UAA4B,CAAA,GAC9C;AACI,UAAM,OAAO,QAAQ,yBAAyB,OAAO,OAAO,QAAQ,kBAAkB;AAEtF,UAAM,0BAA0B,IAAI;AAEpC,SAAK,YAAY,KAAK,OAAO,OAAO;AACpC,SAAK,UAAU,KAAK,OAAO,aAAa,KAAK,OAAO,kBAAkB;AAGtE,eAAW,cAAc,KAAK,cAC9B;AACI,YAAM,SAAS,KAAK,aAAa,UAAU;AAE3C,YAAM,uBAAwB,OAAO,YAAoB;AAEzD,gBAAU,EAAE,GAAG,sBAAsB,GAAG,QAAA;IAC5C;AAEA,cAAU,EAAE,GAAGA,mBAAiB,gBAAgB,GAAG,QAAA;AACnD,SAAK,eAAe,QAAQ,cAAc,IAAI;AAG9C,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,MAAM,QAAQ,KACpD;AACI,YAAM,KAAK,QAAQ,KAAK,MAAM,CAAC,EAAE,KAAK,OAAO;IACjD;AAGA,SAAK,eAAe;EACxB;EAWO,OAAO,MAAiC,YAC/C;AACI,SAAK;AAEL,QAAI,UAAU;AAEd,QAAI,mBAAmB,WACvB;AACI,gBAAU,EAAE,WAAW,QAAA;AAEvB,UAAI,YACJ;AAEI,oBAAY,QAAQ,4EAA4E;AAGhG,gBAAQ,SAAS,WAAW;MAChC;IACJ;AAEA,YAAQ,WAAR,QAAQ,SAAW,KAAK,KAAK;AAG7B,QAAI,QAAQ,WAAW,KAAK,KAAK,cACjC;AAEI,WAAK,sBAAsB,QAAQ;AAEnC,cAAQ,eAAR,QAAQ,aAAe,KAAK,WAAW;AACvC,cAAQ,UAAR,QAAQ,QAAU,KAAK,WAAW;IACtC;AAEA,QAAI,QAAQ,YACZ;AACI,YAAM,cAAc,MAAM,QAAQ,QAAQ,UAAU,KAAK,QAAQ,WAAW,WAAW;AAEvF,cAAQ,aAAa,cAAc,QAAQ,aAAa,MAAM,OAAO,SAAS,QAAQ,UAAU,EAAE,QAAA;IACtG;AAEA,QAAI,CAAC,QAAQ,WACb;AACI,cAAQ,UAAU,qBAAA;AAClB,cAAQ,YAAY,QAAQ,UAAU;IAC1C;AAGA,QAAI,CAAC,QAAQ,UAAU,SACvB;AACI;IACJ;AAIA,YAAQ,UAAU,kBAAA;AAElB,SAAK,QAAQ,UAAU,KAAK,OAAO;AACnC,SAAK,QAAQ,YAAY,KAAK,OAAO;AACrC,SAAK,QAAQ,OAAO,KAAK,OAAO;AAChC,SAAK,QAAQ,UAAU,KAAK,OAAO;AACnC,SAAK,QAAQ,WAAW,KAAK,OAAO;EACxC;;;;;;;EAQO,OAAO,oBAA4B,qBAA6B,YACvE;AACI,UAAM,qBAAqB,KAAK,KAAK;AAErC,SAAK,KAAK,OAAO,oBAAoB,qBAAqB,UAAU;AACpE,SAAK,KAAK,UAAU,KAAK,KAAK,OAAO,OAAO,KAAK,KAAK,OAAO,QAAQ,KAAK,KAAK,UAAU;AACzF,QAAI,eAAe,UAAa,eAAe,oBAC/C;AACI,WAAK,QAAQ,iBAAiB,KAAK,UAAU;IACjD;EACJ;;;;;;;;;EAUO,MAAM,UAAwB,CAAA,GACrC;AAEI,UAAM,WAAW;AAEjB,YAAQ,WAAR,QAAQ,SAAW,SAAS,aAAa;AACzC,YAAQ,eAAR,QAAQ,aAAe,KAAK,WAAW;AACvC,YAAQ,UAAR,QAAQ,QAAU,MAAM;AAExB,UAAM,EAAE,OAAO,YAAY,QAAQ,UAAU,MAAA,IAAU;AAEvD,UAAM,OAAO,SAAS,cAAc,KAAK,WAAW,SAAS;AAE7D,aAAS,aAAa,MAAM,QAAQ,OAAO,MAAM,OAAO,QAAA,GAAwB,YAAY,GAAG,SAAS,CAAC;EAC7G;;EAGA,IAAI,aACJ;AACI,WAAO,KAAK,KAAK;EACrB;EAEA,IAAI,WAAW,OACf;AACI,SAAK,KAAK,aAAa;AACvB,SAAK,QAAQ,iBAAiB,KAAK,KAAK;EAC5C;;;;;;;EAQA,IAAI,QACJ;AACI,WAAO,KAAK,KAAK,QAAQ,MAAM;EACnC;;;;;EAMA,IAAI,SACJ;AACI,WAAO,KAAK,KAAK,QAAQ,MAAM;EACnC;;;;;;EAOA,IAAI,SACJ;AACI,WAAO,KAAK,KAAK;EACrB;;;;;EAMA,IAAI,qBACJ;AACI,WAAO,KAAK;EAChB;;;;;;EAOA,IAAI,oBACJ;AACI,UAAM,WAAW;AAEjB,WAAO,SAAS,aAAa;EACjC;;;;;;EAOA,IAAI,SACJ;AACI,WAAO,KAAK,KAAK;EACrB;;;;;EAMQ,eAAe,WACvB;AACI,cAAU,QAAQ,CAAC,aACnB;AACI,WAAK,QAAQ,QAAQ,IAAI,IAAI,aAAa,QAAQ;IACtD,CAAC;EACL;EAEQ,YAAY,SACpB;AACI,QAAI;AAEJ,SAAK,KAAK,SACV;AACI,YAAM,MAAM,QAAQ,CAAC;AAErB,WAAK,WAAW,IAAI,OAAO,IAAI,IAAI;IACvC;EACJ;;;;;;;;;;EAWQ,WAAW,UAA6B,MAChD;AACI,UAAM,SAAS,IAAI,SAAS,IAA2B;AAEvD,QAAK,KAAa,IAAI,GACtB;AACI,YAAM,IAAI,MAAM,qBAAqB,IAAI,qBAAqB;IAClE;AAEC,SAAa,IAAI,IAAI;AAEtB,SAAK,aAAa,IAAI,IAAI;AAE1B,eAAW,KAAK,KAAK,SACrB;AACI,WAAK,QAAQ,CAAC,EAAE,IAAI,MAAM;IAC9B;AAEA,WAAO;EACX;EAEQ,UAAU,OAAsC,cACxD;AACI,UAAM,WAAW,aAAa,OAAO,CAAC,KAAK,YAC3C;AACI,UAAI,QAAQ,IAAI,IAAI,QAAQ;AAE5B,aAAO;IACX,GAAG,CAAA,CAAyB;AAE5B,UAAM,QAAQ,CAAC,SACf;AACI,YAAM,YAAY,KAAK;AACvB,YAAM,OAAO,KAAK;AAElB,YAAM,UAAU,SAAS,IAAI;AAG5B,WAAK,YAAoB,IAAI,IAAI,IAAI;QAClC;QACA,UAAU,IAAI,QAAA,IAAY;MAAA;AAG9B,WAAK,QAAQ,QAAQ,IAAK,KAAK,YAAoB,IAAI,CAAC;IAC5D,CAAC;EACL;EAEO,QAAQ,UAAkC,OACjD;AACI,SAAK,QAAQ,QAAQ,MAAM,QAAA;AAC3B,SAAK,QAAQ,QAAQ,KAAK,OAAO;AAEjC,QAAI,YAAY,QAAS,OAAO,YAAY,YAAY,QAAQ,wBAChE;AACI,6BAAuB,QAAA;IAC3B;AAGA,WAAO,OAAO,KAAK,OAAO,EAAE,QAAQ,CAAC,WACrC;AACI,aAAO,QAAA;IACX,CAAC;AAED,SAAK,eAAe;AAGnB,SAAK,cAAuB;EACjC;;;;;;EAOO,gBAAgB,SACvB;AACI,WAAO,KAAK,iBAAiB,gBAAgB,OAAO;EACxD;;;;;EAMA,IAAI,cACJ;AACI,WAAO,CAAC,CAAC,KAAK;EAClB;;;;;;;EAQO,mBACP;AACI,QAAI,CAAC,oBAAA,GACL;AACI,YAAM,IAAI,MAAM,0GAC+C;IACnE;EACJ;;;;;;;;;;;;;;;;;;;;;;;EAuBO,aACP;AACI,SAAK,QAAQ,WAAW,KAAA;EAC5B;AACJ;AA1da,kBAKK,iBAAiB;;;;;EAK3B,YAAY;;;;;;;;;;;;;;;;;;;;;;;EAuBZ,8BAA8B;;;;;EAK9B,aAAa;AACjB;AAvCG,IAAM,mBAAN;;;ACtJA,IAAM,mBAAN,MACP;EAYI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EAEO,mBAAmB;EAAe;EAClC,oBAAoB;EAAe;EACnC,qBAAqB;AAAE,WAAO;EAAO;EAErC,cAAc,WAA4B,gBACjD;AACI,SAAK,UAAU,YAAY,MAAM,MAAM,cAAc;AAErD,mBAAe,IAAI,SAAS;EAChC;EAEO,QAAQ,WACf;AACI,QAAI,CAAC,UAAU,aAAc;AAE7B,cAAU,OAAO,KAAK,SAAS;EACnC;EAEO,UACP;AACI,SAAK,YAAY;EACrB;AACJ;AAxCa,iBAEK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;AChBG,IAAM,kBAAN,MACP;EADO,cAAA;AAEH,SAAO,cAAc;AACrB,SAAO,WAAqB;AAG5B,SAAgB,gBAAgB;AAChC,SAAgB,YAAY;AAC5B,SAAgB,aAAa;AAQ7B,SAAO,cAAqB;AAI5B,SAAO,kBAAkB;AACzB,SAAO,WAAoB;AAC3B,SAAO,SAAgB;EAAA;EAEvB,IAAI,YAAY;AAAE,WAAO,KAAK,WAAW;EAAgB;EACzD,IAAI,QAAQ;AAAE,WAAO,KAAK,WAAW;EAAiB;EAE/C,QACP;AACI,SAAK,aAAa;AAClB,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,SAAS;EAClB;EAEO,UACP;AACI,SAAK,MAAA;EACT;AACJ;;;AC7CO,SAAS,oBAAoB,aAA0B,UAC9D;AACI,QAAM,iBAAiB,YAAY;AACnC,QAAM,eAAe,eAAe;AAEpC,WAAS,IAAI,GAAG,IAAI,eAAe,iBAAiB,KACpD;AACI,UAAM,cAAc,aAAa,CAAC;AAEjC,aAAS,YAAY,YAAiC,EAA2B,QAAQ,WAAW;EACzG;AACJ;;;ACLO,IAAM,kBAAN,MACP;EAYI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EAEO,eAAe,aAA0B,gBAChD;AACI,QAAI,YAAY,mBAChB;AACI,WAAK,6BAA6B,aAAa,cAAc;IACjE,OAEA;AACI,WAAK,qBAAqB,aAAa,cAAc;IACzD;EACJ;EAEO,QAAQ,aACf;AACI,QAAI,CAAC,YAAY,aAAc;AAE/B,QAAI,YAAY,mBAChB;AACI,WAAK,uBAAuB,WAAW;IAC3C,OAEA;AACI,WAAK,eAAe,WAAW;IACnC;EACJ;EAEO,UACP;AACI,SAAK,YAAY;EACrB;EAEQ,qBAAqB,aAA0B,gBACvD;AACI,SAAK,UAAU,YAAY,MAAM,MAAM,cAAc;AAErD,QAAI,YAAY,uBAChB;AACI,cAAQ,OAAO,YAAY,qBAAqB;AAChD,kBAAY,wBAAwB;IACxC;AAEA,mBAAe,IAAI,WAAW;EAClC;EAEQ,6BAA6B,aAA0B,gBAC/D;AACI,UAAM,uBAAuB,YAAY,0BAAZ,YAAY,wBAA0B,QAAQ,IAAI,eAAe;AAE9F,yBAAqB,aAAa,YAAY;AAC9C,yBAAqB,YAAY,YAAY,KAAK;AAClD,yBAAqB,UAAU,YAAY;AAC3C,yBAAqB,SAAS,YAAY;AAE1C,mBAAe,IAAI,WAAW;AAE9B,SAAK,UAAU,YAAY,UAAU,cAAc,aAAa,YAAY,KAAK,gBAAgB,cAAc;AAC/G,SAAK,UAAU,YAAY,MAAM,WAAW,sBAAsB,cAAc;AAChF,SAAK,UAAU,YAAY,UAAU,aAAa,cAAc;EACpE;EAEQ,uBAAuB,aAC/B;AACI,QAAI,YAAY,oBAChB;AACI,kBAAY,qBAAqB;AAEjC,YAAM,uBAAuB,IAAI,OAAA,EAAS;QACtC,CAAC,YAAY,eAAe;QAC5B,CAAC,YAAY,eAAe;MAAA;AAGhC,WAAK,UAAU,aAAa,KAAK,YAAY,SAAS,MAAM,MAAM,YAAY,QAAQ,KAAK;AAE3F,WAAK,UAAU,eAAe,KAAK;QAC/B;QACA,YAAY;QACZ,QAAQ,EAAE,GAAG,GAAG,GAAG,EAAA;MAAE,CACxB;AAED,0BAAoB,aAAa,KAAK,UAAU,WAAW;AAE3D,WAAK,UAAU,aAAa,iBAAA;AAE5B,WAAK,UAAU,aAAa,IAAA;AAC5B,WAAK,UAAU,eAAe,IAAA;IAClC;AAEA,gBAAY,sBAAsB,SAAS,cAAc,YAAY,qBAAqB;AAC1F,gBAAY,sBAAsB,SAAS,SAAS,QAAQ,CAAC,EAAE,OAAA;EACnE;EAEQ,eAAe,aACvB;AACI,SAAK,UAAU,eAAe,KAAK;MAC/B,sBAAsB,YAAY;MAClC,YAAY,YAAY;IAAA,CAC3B;AAED,wBAAoB,aAAa,KAAK,UAAU,WAAW;AAE3D,SAAK,UAAU,eAAe,IAAA;EAClC;AACJ;AAxHa,gBAEK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;ACfG,SAAS,UAAU,MAAsB,OAChD;AACI,YAAA,QAAU;AAEV,WAAS,IAAI,OAAO,IAAI,KAAK,QAAQ,KACrC;AACI,QAAI,KAAK,CAAC,GACV;AACI,WAAK,CAAC,IAAI;IACd,OAEA;AACI;IACJ;EACJ;AACJ;;;ACjBA,IAAM,gBAAgB,IAAI,UAAA;AAC1B,IAAM,6BAA6B,iBAAiB,eAAe;AAO5D,SAAS,4BAA4B,aAA0B,0BAA0B,OAChG;AACI,6BAA2B,WAAW;AAEtC,QAAM,mBAAmB,YAAY;AAErC,QAAM,aAAa,YAAY;AAE/B,aAAW,KAAK,kBAChB;AACI,UAAM,mBAAmB,OAAO,CAAC;AAEjC,UAAM,kBAAkB,iBAAiB,CAAC;AAE1C,UAAM,OAAO,gBAAgB;AAC7B,UAAM,QAAQ,gBAAgB;AAE9B,aAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACI,YAAM,QAAQ,KAAK,CAAC;AAMpB,UAAI,MAAM,sBAAsB,eAAe,MAAM,6BAA6B,kBAClF;AACI,mCAA2B,OAAO,YAAY,CAAC;MACnD;IACJ;AAEA,cAAU,MAAM,KAAK;AAErB,oBAAgB,QAAQ;EAC5B;AAEA,MAAI,yBACJ;AACI,aAAS,IAAI,GAAG,IAAI,YAAY,oBAAoB,QAAQ,KAC5D;AACI,kCAA4B,YAAY,oBAAoB,CAAC,GAAG,uBAAuB;IAC3F;EACJ;AACJ;AAMO,SAAS,2BAA2B,aAC3C;AACI,QAAM,OAAO,YAAY;AAEzB,MAAI;AAEJ,MAAI,YAAY,mBAChB;AACI,UAAM,oBAAoB,YAAY;AAEtC,gBAAY,eAAe;MACvB,KAAK;MACL,kBAAkB;IAAA;AAGtB,gBAAY,aAAa;MACrB,KAAK;MACL,kBAAkB;IAAA;AAGtB,iBAAa,KAAK,aAAa,kBAAkB;EACrD,OAEA;AACI,gBAAY,eAAe,SAAS,KAAK,cAAc;AACvD,gBAAY,aAAa,KAAK;AAC9B,iBAAa,KAAK;EACtB;AAGA,eAAa,aAAa,IAAI,IAAK,aAAa,IAAI,IAAI;AACxD,cAAY,aAAa;AAEzB,cAAY,kBAAkB,YAAY,eAC7B,aAAa,MAAO,MAAM;AAC3C;AAQO,SAAS,2BAA2B,WAAsB,YAAoB,aACrF;AACI,MAAI,eAAe,UAAU,WAAY;AACzC,YAAU,aAAa;AAEvB,YAAU,YAAY;AAEtB,QAAM,iBAAiB,UAAU;AAEjC,YAAU,qBAAA;AAEV,QAAM,SAAS,UAAU;AAEzB,MAAK,UAAU,CAAC,OAAO,aACvB;AACI,mBAAe,UAAU;AAEzB,cAAU,uBAAuB;MAC7B;MACA,OAAO;IAAA;AAGX,QAAI,cAAc,4BAClB;AACI,iCAA2B,WAAW,QAAQ,WAAW;IAC7D;EACJ,OAEA;AACI,kBAAc,UAAU;AAExB,cAAU,uBAAuB,SAAS,cAAc;AAExD,QAAI,cAAc,4BAClB;AACI,iCAA2B,WAAW,eAAe,WAAW;IACpE;EACJ;AAGA,MAAI,CAAC,UAAU,aACf;AACI,UAAM,WAAW,UAAU;AAC3B,UAAM,SAAS,SAAS;AAExB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAC5B;AACI,iCAA2B,SAAS,CAAC,GAAG,YAAY,WAAW;IACnE;AAEA,UAAM,cAAc,UAAU;AAC9B,UAAM,aAAa;AAEnB,QAAI,WAAW,gBAAgB,CAAC,YAAY,oBAC5C;AACI,kBAAY,iBAAiB,UAAU;IAC3C;EACJ;AACJ;AAEA,SAAS,2BACL,WACA,QACA,aAEJ;AACI,MAAI,cAAc,cAClB;AACI,cAAU,aAAa;MACnB,UAAU;MACV,OAAO;IAAA;AAGX,QAAI,aAAa,UAAU,aAAa,OAAO;AAG/C,iBAAa,aAAa,IAAI,IAAK,aAAa,IAAI,IAAI;AAExD,cAAU,aAAa;AACvB,cAAU,kBAAkB,UAAU,eAAgB,aAAa,MAAO,MAAM;EACpF;AAEA,MAAI,cAAc,cAClB;AACI,cAAU,iBAAiB,UAAU,mBAAmB,YAAY,OAAO,iBAAiB,UAAU;EAC1G;AAEA,MAAI,cAAc,gBAClB;AACI,cAAU,sBAAsB,UAAU,qBAAqB,OAAO;EAC1E;AAEA,YAAU,eAAe;AAC7B;;;AC/LO,SAAS,oBAAoB,aAA0B,aAC9D;AACI,QAAM,EAAE,KAAA,IAAS,YAAY;AAE7B,MAAI,kBAAkB;AAEtB,WAAS,IAAI,GAAG,IAAI,YAAY,4BAA4B,OAAO,KACnE;AACI,UAAM,YAAY,KAAK,CAAC;AAMxB,UAAM,aAAa;AACnB,UAAM,OAAO,YAAY,WAAW,YAAiC;AAErE,sBAAkB,KAAK,mBAAmB,SAAS;AAEnD,QAAI,iBACJ;AACI;IACJ;EACJ;AAEA,cAAY,qBAAqB;AAEjC,SAAO;AACX;;;ACpBA,IAAM,aAAa,IAAI,OAAA;AAQhB,IAAM,oBAAN,MACP;EAaI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EAEU,OAAO,EAAE,WAAW,UAAA,GAC9B;AAEI,UAAM,SAAS,UAAU;AACzB,UAAM,oBAAoB,UAAU,YAAY;AAGhD,cAAU,SAAS;AACnB,cAAU,YAAY,oBAAoB;AAE1C,UAAM,WAAW,KAAK;AAGtB,UAAM,yBAAiC;AAEvC,QAAI,WACJ;AACI,6BAAuB,SAAS,UAAU,YAAY,cAAc;AACpE,gBAAU,YAAY,eAAe,SAAS,SAAS;IAC3D;AAGA,UAAM,cAAe,SAA4B;AAEjD,SAAK,0BAA0B,UAAU,aAAa,IAAI;AAE1D,SAAK,oBAAoB,UAAU,WAAW;AAE9C,aAAS,eAAe,MAAM;MAC1B,sBAAsB,YAAY,UAAU,YAAY,iBAAiB,UAAU,YAAY;MAC/F,YAAY,UAAU,YAAY;IAAA,CACrC;AAED,wBAAoB,UAAU,aAAa,WAAW;AAGtD,QAAI,YAAY,cAChB;AACI,kBAAY,aAAa,UAAA;IAC7B;AAGA,QAAI,WACJ;AACI,gBAAU,YAAY,eAAe,SAAS,sBAAsB;IACxE;AAEA,cAAU,SAAS;AACnB,cAAU,YAAY,oBAAoB;EAC9C;EAEO,UACP;AACK,SAAK,YAAqB;EAC/B;EAEQ,0BAA0B,aAA0B,uBAC5D;AACI,gBAAY,mCAAmC;AAE/C,QAAI,YAAY,mBAChB;AAEI,UAAI,CAAC,YAAY,mBAAoB;AAErC,8BAAwB;IAC5B;AAGA,aAAS,IAAI,YAAY,oBAAoB,SAAS,GAAG,KAAK,GAAG,KACjE;AACI,WAAK,0BAA0B,YAAY,oBAAoB,CAAC,GAAG,qBAAqB;IAC5F;AAEA,gBAAY,mBAAA;AAEZ,QAAI,YAAY,mBAChB;AACI,UAAI,YAAY,oBAChB;AAKI,cAAM,SAAS,YAAY,KAAK,eAAA;AAChC,cAAM,WAAW,KAAK;AACtB,cAAM,aAAa,YAAY,eAAe,cAAc,SAAS,KAAK;AAC1E,cAAM,YAAY,YAAY,eAAe,aAAa,SAAS,KAAK;AACxE,cAAM,YAAY,YAAY,eAAe,aAAa;AAC1D,cAAM,cAAc,YAAY;AAEhC,eAAO,KAAA;AAEP,YAAI,YAAY,SAChB;AACI,sBAAY,cAAc,YAAY,SAAS,IAAI;QACvD;AAEA,cAAM,UAAU,YAAY;UACxB,OAAO;UACP,OAAO;UACP;UACA;QAAA;AAGJ,gBAAQ,QAAQ,QAAQ,IAAI,aAAa,EAAE,UAAA,CAAW;AACtD,oBAAY,UAAU;AACtB,oBAAY,mBAAZ,YAAY,iBAAmB,IAAI,OAAA;AACnC,oBAAY,eAAe,SAAS,MAAM;AAE1C,YAAI,gBAAgB,YAAY,SAChC;AACI,cAAI,YAAY,mBAChB;AACI,wBAAY,kBAAkB,qBAAqB;UACvD;QACJ;MACJ;IACJ,WACS,YAAY,SACrB;AACI,kBAAY,cAAc,YAAY,SAAS,IAAI;AACnD,kBAAY,UAAU;IAC1B;EACJ;EAEQ,oBAAoB,aAC5B;AACI,UAAM,WAAW,KAAK;AACtB,UAAM,cAAc,SAAS;AAE7B,gBAAY,YAAY,QAAQ;AAEhC,gBAAY,eAAe,cAAc;AAEzC,QAAI,CAAC,YAAY,oBACjB;AAEI,0BAAoB,aAAa,WAAW;IAChD,OAEA;AACI,gBAAU,YAAY,4BAA4B,MAAM,CAAC;IAC7D;AAIA,gCAA4B,WAAW;AAEvC,QAAI,YAAY,oBAChB;AACI,kBAAY,qBAAqB;AAGjC,WAAK,mBAAmB,aAAa,QAAQ;IACjD,OAEA;AAEI,WAAK,mBAAmB,WAAW;IACvC;AAGA,gBAAY,4BAA4B,QAAQ;AAGhD,aAAS,YAAY,MAAM,OAAO,YAAY,cAAc;AAG5D,QAAI,YAAY,qBAAqB,CAAC,YAAY,mBAAoB;AAEtE,aAAS,IAAI,GAAG,IAAI,YAAY,oBAAoB,QAAQ,KAC5D;AACI,WAAK,oBAAoB,YAAY,oBAAoB,CAAC,CAAC;IAC/D;EACJ;EAEQ,mBAAmB,aAC3B;AACI,UAAM,EAAE,MAAM,MAAA,IAAU,YAAY;AAEpC,aAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACI,YAAM,YAAY,KAAK,CAAC;AAExB,UAAI,UAAU,eACd;AACI,oBAAY,iBAAiB,SAA0B;MAC3D;IACJ;AAEA,cAAU,MAAM,KAAK;EACzB;EASQ,mBAAmB,aAA0B,iBACrD;AAEI,UAAM,OAAO,YAAY;AACzB,UAAM,iBAAiB,YAAY;AAEnC,mBAAe,MAAA;AAGf,UAAM,WAAY,gBAA6B,cACxC,kBACA,gBAAgC,MAAM;AAC7C,UAAM,cAAc,SAAS;AAG7B,gBAAY,MAAM,WAAW,cAAc;AAC3C,gBAAY,UAAU,WAAA;AACtB,gBAAY,UAAU,WAAA;AAEtB,QAAI,KAAK,kBACT;AACI,WAAK,aAAA;IACT;AAEA,SAAK,8BAA8B,gBAAgB,UAAU,IAAI;AAGjE,gBAAY,MAAM,SAAS,cAAc;AACzC,gBAAY,UAAU,SAAS,cAAc;EACjD;AACJ;AA1Pa,kBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;AC1BG,IAAM,aAAN,MACP;EAaI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EAEO,cAAc,QAAgB,gBACrC;AACI,UAAM,YAAY,KAAK,cAAc,MAAM;AAE3C,QAAI,OAAO,cAAe,MAAK,uBAAuB,QAAQ,SAAS;AAGvE,SAAK,UAAU,YAAY,MAAM,WAAW,WAAW,cAAc;EACzE;EAEO,iBAAiB,QACxB;AACI,UAAM,YAAY,KAAK,cAAc,MAAM;AAE3C,QAAI,OAAO,cAAe,MAAK,uBAAuB,QAAQ,SAAS;AAEvE,cAAU,SAAS,cAAc,SAAS;EAC9C;EAEO,mBAAmB,QAC1B;AACI,UAAM,YAAY,KAAK,cAAc,MAAM;AAE3C,WAAO,CAAC,UAAU,SAAS;MACvB;MACA,OAAO;IAAA;EAEf;EAEQ,uBAAuB,QAAgB,iBAC/C;AACI,oBAAgB,SAAS,OAAO;AAChC,oBAAgB,UAAU,OAAO;EACrC;EAEQ,cAAc,QACtB;AACI,WAAO,OAAO,SAAS,KAAK,UAAU,GAAG,KAAK,KAAK,eAAe,MAAM;EAC5E;EAEQ,eAAe,QACvB;AACI,UAAM,kBAAkB,IAAI,gBAAA;AAE5B,oBAAgB,aAAa;AAE7B,oBAAgB,YAAY,OAAO;AACnC,oBAAgB,UAAU,OAAO;AACjC,oBAAgB,SAAS,OAAO;AAChC,oBAAgB,cAAe,KAAK,UAAU,eAAe,OAAO;AAEpE,WAAO,SAAS,KAAK,UAAU,GAAG,IAAI;AAEtC,WAAO;EACX;EAEO,UACP;AACI,SAAK,YAAY;EACrB;AACJ;AA/Ea,WAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;ACLG,IAAM,WAAW;AASjB,IAAM,UAAU;;;ACLhB,IAAM,sBAAN,MACP;EAGI,OAAc,OACd;;AACI,qBAAW,sBAAX,oCAA+B,MAAgC;EACnE;EACA,OAAc,UACd;EAEA;AACJ;AAZa,oBAGK,YAA+B,cAAc;AAgBxD,IAAM,mBAAN,MACP;EAaI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EACO,OACP;;AACI,qBAAW,2BAAX,oCAAoC,KAAK,WAAW;EACxD;EACO,UACP;AACI,SAAK,YAAY;EACrB;AACJ;AA1Ba,iBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;EACN,UAAU;AACd;;;ACnBG,IAAM,eAAN,MAAMC,cACb;EA+BI,YAAY,UAAoB,SAChC;;AArBA,SAAO,QAAe,MAAM,MAAA;AAG5B,SAAiB,4BAAqE,uBAAO,OAAO,IAAI;AAKxG,SAAQ,iBAA0C,uBAAO,OAAO,IAAI;AAchE,SAAK,WAAW;AAChB,SAAK,WAAW;AAEhB,qBAAK,UAAS,SAAd,4BAAqB;EACzB;EAXA,OAAc,WAAW,MACzB;AACI,WAAO,IAAI,KAAK,mBAAmB,IAA4C,EAAA;EACnF;EAUO,WAAW,gBAClB;AACI,QAAI,WAAW,KAAK,0BAA0B,eAAe,GAAG;AAEhE,QAAI,CAAC,UACL;AACI,iBAAW,KAAK,0BAA0B,eAAe,GAAG,IAAI,uBAAO,OAAO,IAAI;AAClF,eAAS,YAAT,SAAS,UAAY,IAAI,eAAe;QACpC,aAAa,KAAK,SAAS,OAAO;MAAA,CACrC;IACL;AAEA,SAAK,iBAAiB;AAEtB,SAAK,eAAe,KAAK,eAAe;AAExC,eAAW,KAAK,KAAK,gBACrB;AACI,WAAK,eAAe,CAAC,EAAE,MAAA;IAC3B;EACJ;EAEO,WAAW,iBAAmC,gBACrD;AACI,QAAI,KAAK,aAAa,SAAS,gBAAgB,aAC/C;AACI,WAAK,aAAa,MAAM,cAAc;AAEtC,UAAI,QAAQ,KAAK,eAAe,gBAAgB,WAAW;AAE3D,UAAI,CAAC,OACL;AACI,gBAAQ,KAAK,eAAe,gBAAgB,WAAW,IACjDA,cAAY,WAAW,gBAAgB,WAAW;AACxD,cAAM,MAAA;MACV;AAEA,WAAK,eAAe;IACxB;AAEA,SAAK,aAAa,IAAI,eAAe;EACzC;EAEO,MAAM,gBACb;AACI,SAAK,aAAa,MAAM,cAAc;EAC1C;EAEO,SAAS,gBAChB;AACI,SAAK,aAAa,MAAM,cAAc;AAEtC,UAAM,UAAU,KAAK;AAErB,eAAW,KAAK,SAChB;AACI,YAAM,QAAQ,QAAQ,CAAyB;AAC/C,YAAM,WAAW,MAAM;AAEvB,eAAS,YAAY,gBAAgB,MAAM,aAAa,MAAM,WAAW,IAAI;AAE7E,eAAS,QAAQ,CAAC,EAAE,gBAAgB,MAAM,gBAAgB,aAAa,MAAM,eAAe,KAAK;IACrG;EACJ;EAEO,OAAO,gBACd;AACI,UAAM,WAAW,KAAK,0BAA0B,eAAe,GAAG;AAElE,eAAW,KAAK,UAChB;AACI,YAAM,UAAU,SAAS,CAA0B;AACnD,YAAM,WAAW,QAAQ;AAEzB,UAAI,QAAQ,OACZ;AACI,gBAAQ,QAAQ;AAEhB,iBAAS,QAAQ,CAAC,EAAE,OAAO,QAAQ,gBAAgB,CAAC;MACxD;IACJ;EACJ;EAEO,QAAQ,OACf;AACI,QAAI,MAAM,WAAW,cACrB;AACI,YAAM,UAAU,MAAM;AACtB,YAAM,WAAW,QAAQ;AACzB,YAAM,SAAS,QAAQ;AAEvB,WAAK,SAAS,MAAM,MAAM,UAAU,MAAM;IAC9C;AAEA,SAAK,SAAS,QAAQ,MAAM,KAAK;EACrC;EAEO,UACP;AACI,SAAK,QAAQ;AACb,SAAK,WAAW;AAEhB,SAAK,WAAW;AAEhB,eAAW,KAAK,KAAK,gBACrB;AACI,WAAK,eAAe,CAAC,EAAE,QAAA;IAC3B;AAEA,SAAK,iBAAiB;EAC1B;AACJ;AAvJa,aAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;AAVS,aAyBK,qBAAwD,uBAAO,OAAO,IAAI;AAzBrF,IAAM,cAAN;AAyJP,WAAW,YAAY,cAAc,SAAS,YAAY,kBAAkB;AAE5E,WAAW,IAAI,cAAc;;;ACvL7B,IAAI,WAAW;;;ACAf,IAAI,SAAS;;;ACAb,IAAI,SAAS;;;ACwBN,IAAM,aAAN,cAAyB,OAChC;EAII,YAAY,SACZ;AACI,UAAM,EAAE,QAAQ,GAAG,KAAA,IAAS;AAE5B,UAAM,gBAAgB,IAAI,cAAc,OAAO,OAAO;AAEtD,UAAM,iBAAiB,IAAI,aAAa;MACpC,eAAe,EAAE,OAAO,IAAI,OAAA,GAAU,MAAM,cAAA;MAC5C,YAAY,EAAE,OAAO,cAAc,aAAa,MAAM,YAAA;MACtD,QAAQ,EAAE,OAAO,GAAG,MAAM,MAAA;MAC1B,UAAU,EAAE,OAAO,QAAQ,UAAU,IAAI,GAAG,MAAM,MAAA;IAAM,CAC3D;AAED,UAAM,aAAa,WAAW,KAAK;MAC/B,QAAQ;QACJ;QACA,YAAY;MAAA;MAEhB,UAAU;QACN;QACA,YAAY;MAAA;IAChB,CACH;AAED,UAAM,YAAY,UAAU,KAAK;MAC7B;MACA;MACA,MAAM;IAAA,CACT;AAED,UAAM;MACF,GAAG;MACH;MACA;MACA,gBAAgB;MAChB,WAAW;QACP;QACA,cAAc,OAAO,QAAQ;MAAA;IACjC,CACH;AAED,SAAK,SAAS;AAEd,SAAK,iBAAiB;EAC1B;EAEA,IAAI,QAAQ,OACZ;AACI,SAAK,UAAU,eAAe,SAAS,WAAW,QAAQ,IAAI;EAClE;EAEA,IAAI,UACJ;AACI,WAAO,KAAK,UAAU,eAAe,SAAS,aAAa;EAC/D;EAEO,MACH,eACA,OACA,QACA,WAEJ;AAEI,SAAK,eAAe,UAAU,KAAK,OAAO;AAE1C,kBAAc;MACV,KAAK,UAAU,eAAe,SAAS;MACvC,KAAK;IAAA,EACP,QAAQ,KAAK,eAAe,QAAQ;AAEtC,SAAK,UAAU,eAAe,KAAK,OAAO,QAAQ;AAElD,kBAAc,YAAY,MAAM,OAAO,QAAQ,SAAS;EAC5D;AACJ;;;ACjFA,IAAM,aAAa,IAAI,OAAA;AAGvB,IAAM,kBAAN,cAA8B,aAC9B;EACI,cACA;AACI,UAAA;AAEA,SAAK,UAAU,CAAC,IAAI,WAAW;MAC3B,QAAQ,IAAI,OAAO,QAAQ,KAAK;MAChC,SAAS;MACT,YAAY;MACZ,WAAW;IAAA,CACd,CAAC;EACN;EAEA,IAAI,SACJ;AACI,WAAQ,KAAK,QAAQ,CAAC,EAAiB;EAC3C;EAEA,IAAI,OAAO,OACX;AACK,SAAK,QAAQ,CAAC,EAAiB,SAAS;EAC7C;EAEA,IAAI,UACJ;AACI,WAAQ,KAAK,QAAQ,CAAC,EAAiB;EAC3C;EAEA,IAAI,QAAQ,OACZ;AACK,SAAK,QAAQ,CAAC,EAAiB,UAAU;EAC9C;AAGJ;AAuBO,IAAM,gBAAN,MACP;EAcI,YAAY,UACZ;AAHA,SAAQ,mBAAoC,CAAA;AAIxC,SAAK,YAAY;EACrB;EAEO,KAAK,MAAc,iBAA4B,gBACtD;AACI,UAAM,WAAW,KAAK;AAEtB,aAAS,YAAY,MAAM,MAAM,cAAc;AAE/C,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR;MACA,SAAS,gBAAgB,aAAa;MACtC,WAAW;MACX;IAAA,CACqB;AAExB,SAAmB,UAAU,gBAAgB,aAAa;AAE3D,QAAK,KAAmB,qBACxB;AACI,YAAM,gBAAiB,KAAmB;AAE1C,oBAAc,iBAAiB;AAE/B,oBAAc;QACV;QACA;QACA;MAAA;AAGJ,oBAAc,iBAAiB;IACnC;AAEA,aAAS,YAAY,MAAM,MAAM,cAAc;AAE/C,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR;MACA;MACA,SAAS,gBAAgB,aAAa;MACtC,WAAW;IAAA,CACU;EAC7B;EAEO,IAAI,MAAc,kBAA6B,gBACtD;AACI,UAAM,WAAW,KAAK;AAEtB,aAAS,YAAY,MAAM,MAAM,cAAc;AAE/C,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR;MACA,SAAS,iBAAiB,aAAa;MACvC,WAAW;IAAA,CACU;EAC7B;EAEO,QAAQ,aACf;AACI,UAAM,WAAW,KAAK;AACtB,UAAM,aAAa,YAAY,KAAK;AAEpC,QAAI,YAAY,WAAW,iBAC3B;AACI,YAAM,eAAe,QAAQ,IAAI,eAAe;AAEhD,mBAAa,UAAU,YAAY;AAEnC,UAAI,YACJ;AACI,oBAAY,KAAK,KAAK,aAAa;AAEnC,cAAM,SAAS,gBAAgB,YAAY,KAAK,MAAM,MAAM,UAAU;AAEtE,oBAAY,KAAK,KAAK,aAAa;AAEnC,eAAO,KAAA;AAEP,cAAM,qBAAqB,SAAS,aAAa,aAAa,aAAa;AAC3E,cAAM,gBAAgB,YAAY;UAC9B,OAAO;UACP,OAAO;UACP,mBAAmB;UACnB,mBAAmB;QAAA;AAGvB,iBAAS,aAAa,KAAK,eAAe,IAAI;AAE9C,iBAAS,eAAe,KAAK;UACzB,QAAQ;UACR,YAAY;QAAA,CACf;AAED,cAAM,SAAS,aAAa;AAE5B,eAAO,UAAU;AAEjB,eAAO,eAAe,KAAK,OAAO;AAClC,eAAO,eAAe,KAAK,OAAO;AAElC,aAAK,iBAAiB,KAAK;UACvB;UACA,iBAAiB,YAAY;UAC7B;QAAA,CACH;MACL,OAEA;AACI,qBAAa,SAAS,YAAY,KAAK;AAEvC,aAAK,iBAAiB,KAAK;UACvB;UACA,iBAAiB,YAAY;QAAA,CAChC;MACL;IACJ,WACS,YAAY,WAAW,eAChC;AACI,YAAM,WAAW,KAAK,iBAAiB,KAAK,iBAAiB,SAAS,CAAC;AAEvE,UAAI,YACJ;AAEI,YAAI,SAAS,SAAS,aAAa,OACnC;AACI,mBAAS,aAAa,iBAAA;QAC1B;AAEA,iBAAS,aAAa,IAAA;AACtB,iBAAS,eAAe,IAAA;MAC5B;AAEA,eAAS,OAAO,KAAK;QACjB,cAAc;QACd,QAAQ;QACR,WAAW,SAAS;QACpB,cAAc,SAAS;QACvB,WAAW;MAAA,CACd;IACL,WACS,YAAY,WAAW,cAChC;AACI,eAAS,OAAO,IAAA;AAEhB,YAAM,WAAW,KAAK,iBAAiB,IAAA;AAEvC,UAAI,YACJ;AACI,oBAAY,cAAc,SAAS,aAAa;MACpD;AAEA,cAAQ,OAAO,SAAS,YAAY;IACxC;EACJ;EAEO,UACP;AACI,SAAK,YAAY;AACjB,SAAK,mBAAmB;EAC5B;AACJ;AAtLa,cAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;ACjFG,IAAM,gBAAN,MACP;EAeI,YAAY,UACZ;AALA,SAAQ,cAAwB,CAAA;AAChC,SAAQ,mBAAmB;AAC3B,SAAQ,gBAAgB;AAIpB,SAAK,YAAY;EACrB;EAEO,aACP;AACI,SAAK,YAAY,CAAC,IAAI;AACtB,SAAK,mBAAmB;AACxB,SAAK,gBAAgB;EACzB;EAEO,KAAK,MAAc,YAAuB,gBACjD;AACI,UAAM,WAAW,KAAK;AAEtB,aAAS,YAAY,MAAM,MAAM,cAAc;AAE/C,UAAM,aAAa,KAAK;AAExB,eAAW,KAAK,gBAAgB,IAAI,WAAW,KAAK,mBAAmB,CAAC,IAAK,KAAmB;AAEhG,UAAM,eAAe,KAAK,YAAY,KAAK,gBAAgB;AAE3D,QAAI,iBAAiB,KAAK,eAC1B;AACI,WAAK,gBAAgB;AACrB,qBAAe,IAAI;QACf,cAAc;QACd,WAAW;QACX,WAAW;MAAA,CACU;IAC7B;AAEA,SAAK;EACT;EAEO,IAAI,OAAe,YAAuB,gBACjD;AACI,UAAM,WAAW,KAAK;AAEtB,aAAS,YAAY,MAAM,MAAM,cAAc;AAE/C,UAAM,aAAa,KAAK;AAExB,SAAK;AAEL,UAAM,eAAe,WAAW,KAAK,mBAAmB,CAAC;AAEzD,QAAI,iBAAiB,KAAK,eAC1B;AACI,WAAK,gBAAgB;AAErB,qBAAe,IAAI;QACf,cAAc;QACd,WAAW;QACX,WAAW;MAAA,CACU;IAC7B;EACJ;EAEO,QAAQ,aACf;AACI,UAAM,WAAW,KAAK;AAErB,aAA4C,UAAU,QAAQ,YAAY,SAAS;EACxF;EAEO,UACP;AACK,SAAK,YAAqB;AAC3B,SAAK,cAAc;EACvB;AACJ;AAzFa,cAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;ACNG,IAAM,kBAAN,MACP;EAmBI,YAAY,UACZ;AARA,SAAQ,iBAAyC,CAAA;AAEjD,SAAQ,YAAA,oBAAgB,QAAA;AAOpB,SAAK,YAAY;EACrB;EAEO,KAAK,MAAc,YAAuB,gBACjD;AA1CJ,QAAA;AA2CQ,UAAM,SAAS;AAEf,UAAM,WAAW,KAAK;AAEtB,aAAS,YAAY,MAAM,MAAM,cAAc;AAE/C,aAAS,YAAY,UAAU,aAAa,OAAO,MAAoB,QAAQ,cAAc;AAE7F,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR;MACA,SAAS,WAAW,aAAa;MACjC,WAAW;IAAA,CACY;AAE3B,UAAM,gBAAgB,OAAO;AAE7B,kBAAc,iBAAiB;AAE/B,QAAI,CAAC,KAAK,UAAU,IAAI,MAAM,GAC9B;AACI,WAAK,UAAU,IAAI,QAAQ;QACvB,mBAAmB;QACnB,oBAAoB;MAAA,CACvB;IACL;AAEA,UAAM,WAAW,KAAK,UAAU,IAAI,MAAM;AAE1C,aAAS,oBAAoB,eAAe;AAE5C,kBAAc;MACV;MACA;MACA;IAAA;AAGJ,kBAAc,iBAAiB;AAE/B,aAAS,YAAY,MAAM,MAAM,cAAc;AAE/C,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR;MACA,SAAS,WAAW,aAAa;MACjC,WAAW;IAAA,CACY;AAE3B,UAAM,qBAAqB,eAAe,kBAAkB,SAAS,oBAAoB;AAEzF,aAAS,qBAAqB;AAE9B,UAAM,kBAAkB,SAAS,aAAa,aAAa;AAE3D,KAAA,KAAA,KAAK,gBAAL,eAAA,MAAA,GAAA,eAAA,IAAyC;EAC7C;EAEO,IAAI,MAAc,YAAuB,gBAChD;AACI,UAAM,SAAS;AAEf,UAAM,WAAW,KAAK;AAGtB,aAAS,YAAY,MAAM,MAAM,cAAc;AAC/C,aAAS,YAAY,UAAU,aAAa,OAAO,MAAoB,QAAQ,cAAc;AAE7F,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR,SAAS,WAAW,aAAa;MACjC,WAAW;IAAA,CACY;AAE3B,UAAM,WAAW,KAAK,UAAU,IAAI,IAAmB;AAEvD,aAAS,IAAI,GAAG,IAAI,SAAS,oBAAoB,KACjD;AAEI,qBAAe,aAAa,eAAe,iBAAiB,IAAI,eAAe,aAAa,SAAS,mBAAmB;IAC5H;AAEA,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR,WAAW;IAAA,CACd;EACL;EAEO,QAAQ,aACf;AAvIJ,QAAA;AAwIQ,UAAM,WAAW,KAAK;AAEtB,UAAM,cAAc;AACpB,UAAM,kBAAkB,SAAS,aAAa,aAAa;AAE3D,QAAI,kBAAiB,KAAA,KAAK,gBAAL,eAAA,MAAA,GAAA,eAAA,IAAyC;AAE9D,QAAI,YAAY,WAAW,iBAC3B;AAGI,kBAAY,aAAa,mBAAA;AAEzB,kBAAY,QAAQ,eAAe,cAAc,oBAAoB,cAAc;AAEnF;AAEA,kBAAY,UAAU,QAAQ,CAAC;IACnC,WACS,YAAY,WAAW,eAChC;AACI,UAAI,YAAY,SAChB;AACI,oBAAY,QAAQ,eAAe,cAAc,qBAAqB,cAAc;MACxF,OAEA;AACI,oBAAY,QAAQ,eAAe,cAAc,aAAa,cAAc;MAChF;AAEA,kBAAY,UAAU,QAAQ,EAAG;IACrC,WACS,YAAY,WAAW,gBAChC;AACI,kBAAY,UAAU,QAAQ,CAAC;AAE/B,UAAI,mBAAmB,GACvB;AACI,oBAAY,QAAQ,eAAe,cAAc,uBAAuB,cAAc;MAC1F,OAEA;AACI,oBAAY,aAAa,MAAM,MAAM,MAAM,OAAO;AAClD,oBAAY,QAAQ,eAAe,cAAc,UAAU,cAAc;MAC7E;AAEA;IACJ,WACS,YAAY,WAAW,cAChC;AACI,UAAI,YAAY,SAChB;AACI,oBAAY,QAAQ,eAAe,cAAc,qBAAqB,cAAc;MACxF,OAEA;AACI,oBAAY,QAAQ,eAAe,cAAc,aAAa,cAAc;MAChF;AAEA,kBAAY,UAAU,QAAQ,EAAG;IACrC;AAEA,SAAK,eAAe,eAAe,IAAI;EAC3C;EAEO,UACP;AACI,SAAK,YAAY;AACjB,SAAK,iBAAiB;AACtB,SAAK,YAAY;EACrB;AACJ;AA/La,gBAEK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;ACgBG,IAAM,oBAAN,MAAMC,mBACb;EA0CI,cACA;AACI,SAAK,oBAAoB;AAEzB,SAAK,mBAAmB,IAAI,MAAM,CAAQ;AAE1C,SAAK,QAAQ,KAAK;AAClB,SAAK,QAAQ;EACjB;;;;;EAMO,KAAK,SACZ;AACI,cAAU,EAAE,GAAGA,mBAAiB,gBAAgB,GAAG,QAAA;AAEnD,SAAK,oBAAoB,QAAQ;AACjC,SAAK,QAAQ,QAAQ,cAAc,QAAQ,mBAAmB,KAAK;AACnE,SAAK,QAAQ,QAAQ;AAErB,SAAK,iBAAiB,SAAS,QAAQ,eAAe;EAC1D;;EAGA,IAAI,QACJ;AACI,WAAO,KAAK;EAChB;EAEA,IAAI,MAAM,OACV;AAGI,UAAM,WAAW,MAAM,OAAO,SAAS,KAAK;AAE5C,QAAI,SAAS,QAAQ,KAAK,KAAK,iBAAiB,UAAU,GAC1D;AACI;QACI;MAAA;IAGR;AAEA,SAAK,iBAAiB,SAAS,KAAK;EACxC;;EAGA,IAAI,QACJ;AACI,WAAO,KAAK,iBAAiB;EACjC;EAEA,IAAI,MAAM,OACV;AACI,SAAK,iBAAiB,SAAS,KAAK;EACxC;;EAGA,IAAI,YACJ;AACI,WAAO,KAAK,iBAAiB,QAAA;EACjC;;;;;EAMO,UACP;EAEA;AACJ;AApHa,kBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;EACN,UAAU;AACd;AAXS,kBAcK,iBAA0C;;;;;EAKpD,iBAAiB;;;;;EAKjB,iBAAiB;;;;;EAKjB,mBAAmB;AACvB;AA9BG,IAAM,mBAAN;;;AClBP,IAAM,qBAA8E,CAAA;AAEpF,WAAW,OAAO,cAAc,WAAW,CAAC,UAC5C;AACI,MAAI,CAAC,MAAM,MACX;AACI,UAAM,IAAI,MAAM,+CAA+C;EACnE;AACA,qBAAmB,MAAM,IAAmB,IAAI,MAAM;AAC1D,GAAG,CAAC,UACJ;AACI,SAAO,mBAAmB,MAAM,IAAmB;AACvD,CAAC;AAeM,IAAM,gBAAN,MACP;EAqBI,YAAY,UACZ;AAPA,SAAiB,kBAAiC,CAAA;AAElD,SAAQ,cAAc;AAEtB,SAAQ,cAA0D,uBAAO,OAAO,IAAI;AAIhF,SAAK,YAAY;AACjB,SAAK,UAAU,QAAQ,UAAU,IAAI,IAAI;EAC7C;EAEO,YACP;AAGI,SAAK,mBAAmB;AACxB,SAAK,cAAc;EACvB;;;;;;;EAQO,cAAc,YAAsC,WAAwB,gBACnF;AACI,SAAK,gBAAgB,KAAK,SAAS;AAEnC,SAAK,aAAa,YAAY,WAAW,cAAc;EAC3D;;;;;EAMO,aAAa,gBACpB;AACI,SAAK,gBAAgB,IAAA;AACrB,UAAM,YAAY,KAAK,gBAAgB,KAAK,iBAAiB,SAAS,CAAC,KAAK;AAE5E,SAAK,aAAa,MAAM,WAAW,cAAc;EACrD;;;;;;;;;EAUO,aACH,YACA,WACA,gBAEJ;;AACI,UAAM,gBAAgB,sBAAsB;AAE5C,QAAI,KAAK,qBAAqB,WAC9B;AACI,UAAI,KAAK,eAAe,cAAc,CAAC,eACvC;AACI,mBAAK,oBAAL,mBAAsB,KAAK;MAC/B;AAEA;IACJ;AAEA,QAAI,KAAK,YAAa,MAAK,sBAAsB,cAAc;AAE/D,SAAK,mBAAmB;AAExB,QAAI,CAAC,WAAY;AAEjB,SAAK,cAAc,CAAC,CAAC,mBAAmB,SAAS;AAEjD,QAAI,KAAK,YAAa,MAAK,wBAAwB,YAAY,cAAc;EACjF;EAEQ,wBAAwB,YAAsC,gBACtE;AACI,SAAK,UAAU,YAAY,MAAM,MAAM,cAAc;AAErD,UAAM,YAAY,KAAK;AAEvB,QAAI,CAAC,mBAAmB,SAAS,GACjC;AAEI,WAAK,gCAAgC,SAAS,mEACwB;AAGtE;IACJ;AAEA,UAAM,eAAe,KAAK,oBAAoB,SAAS;AACvD,UAAM,gBAAgB,sBAAsB;AAC5C,UAAM,cAAiC;MACnC,cAAc;MACd,QAAQ;MACR;MACA,aAAa,gBAAgB,OAAO,CAAC,UAAU;MAC/C,WAAW,gBAAgB,WAAW,OAAO;MAC7C,WAAW;IAAA;AAGf,SAAK,kBAAkB,YAAY;AAEnC,mBAAe,IAAI,WAAW;EAClC;EAEQ,oBAAoB,WAC5B;AACI,QAAI,eAA6B,KAAK,YAAY,SAAS;AAE3D,QAAI,CAAC,cACL;AACI,qBAAe,KAAK,YAAY,SAAS,IAAI,IAAI,aAAA;AACjD,mBAAa,UAAU,CAAC,IAAI,mBAAmB,SAA4C,EAAA,CAAG;IAClG;AAEA,WAAO;EACX;EAEQ,sBAAsB,gBAC9B;AACI,SAAK,cAAc;AACnB,SAAK,kBAAkB;AACvB,SAAK,UAAU,YAAY,MAAM,MAAM,cAAc;AAErD,mBAAe,IAAI;MACf,cAAc;MACd,QAAQ;MACR,WAAW;IAAA,CACd;EACL;;;;;EAMO,aACP;AACI,SAAK,cAAc;EACvB;;;;;;;EAQO,SAAS,gBAChB;AACI,QAAI,CAAC,KAAK,YAAa;AAEvB,SAAK,sBAAsB,cAAc;EAC7C;;EAGO,UACP;AACI,SAAK,YAAY;AACjB,SAAK,kBAAkB;AAEvB,eAAW,KAAK,KAAK,aACrB;AACI,WAAK,YAAY,CAAgB,EAAE,QAAA;IACvC;AAEA,SAAK,cAAc;EACvB;AACJ;AA/La,cAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;AC7CJ,IAAM,aAAa;EACf,KAAK;EACL,KAAK;EACL,MAAM;AACV;AA4ZO,IAAM,iBAAN,MAAMC,gBACb;;EA+BI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;EAEQ,kBACJ,SACA,WAAuB,CAAA,GAE3B;AACI,QAAI,mBAAmB,aAAa,mBAAmB,SACvD;AACI,aAAO;QACH,QAAQ;QACR,GAAG;MAAA;IAEX;AAEA,WAAO;MACH,GAAG;MACH,GAAG;IAAA;EAEX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAkCA,MAAa,MAAM,SACnB;AACI,UAAM,QAAQ,WAAW,IAAA,EAAM,YAAA;AAE/B,UAAM,MAAM,MAAM,KAAK,OAAO,OAAO;AAErC,WAAO;EACX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAkCA,MAAa,OAAO,SACpB;AACI,cAAU,KAAK;MACX;MACAA,gBAAc;IAAA;AAGlB,UAAM,EAAE,QAAQ,QAAA,IAAY;AAE5B,UAAM,SAAS,KAAK,OAAO,OAAO;AAElC,QAAI,OAAO,WAAW,QACtB;AACI,aAAO,IAAI,QAAgB,CAAC,SAAS,WACrC;AACI,eAAO,OAAQ,CAAC,SAChB;AACI,cAAI,CAAC,MACL;AACI,mBAAO,IAAI,MAAM,wBAAwB,CAAC;AAE1C;UACJ;AAEA,gBAAM,SAAS,IAAI,WAAA;AAEnB,iBAAO,SAAS,MAAM,QAAQ,OAAO,MAAgB;AACrD,iBAAO,UAAU;AACjB,iBAAO,cAAc,IAAI;QAC7B,GAAG,WAAW,MAAM,GAAG,OAAO;MAClC,CAAC;IACL;AACA,QAAI,OAAO,cAAc,QACzB;AACI,aAAO,OAAO,UAAU,WAAW,MAAM,GAAG,OAAO;IACvD;AACA,QAAI,OAAO,kBAAkB,QAC7B;AACI,YAAM,OAAO,MAAM,OAAO,cAAc,EAAE,MAAM,WAAW,MAAM,GAAG,QAAA,CAAS;AAE7E,aAAO,IAAI,QAAgB,CAAC,SAAS,WACrC;AACI,cAAM,SAAS,IAAI,WAAA;AAEnB,eAAO,SAAS,MAAM,QAAQ,OAAO,MAAgB;AACrD,eAAO,UAAU;AACjB,eAAO,cAAc,IAAI;MAC7B,CAAC;IACL;AAEA,UAAM,IAAI,MAAM,yGACkC;EACtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0CO,OAAO,SACd;AACI,cAAU,KAAK,kBAAkB,OAAO;AAExC,UAAM,SAAS,QAAQ;AAEvB,UAAM,WAAW,KAAK;AAEtB,QAAI,kBAAkB,SACtB;AACI,aAAO,SAAS,QAAQ,eAAe,MAAM;IACjD;AAEA,UAAM,UAAU,SAAS,iBAAiB,gBAAgB,OAAiC;AAE3F,UAAM,SAAS,SAAS,QAAQ,eAAe,OAAO;AAEtD,YAAQ,QAAQ,IAAI;AAEpB,WAAO;EACX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgCO,OAAO,SACd;AACI,cAAU,KAAK,kBAAkB,OAAO;AAExC,UAAM,SAAS,QAAQ;AAEvB,UAAM,WAAW,KAAK;AACtB,UAAM,UAAU,kBAAkB,UAC5B,SACA,SAAS,iBAAiB,gBAAgB,OAAiC;AAEjF,UAAM,YAAY,SAAS,QAAQ,UAAU,OAAO;AAEpD,QAAI,kBAAkB,WACtB;AAEI,cAAQ,QAAQ,IAAI;IACxB;AAEA,WAAO;EACX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6CO,QAAQ,SACf;AACI,cAAU,KAAK,kBAAkB,OAAO;AAExC,QAAI,QAAQ,kBAAkB,QAAS,QAAO,QAAQ;AAEtD,WAAO,KAAK,UAAU,iBAAiB,gBAAgB,OAAiC;EAC5F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8CO,SAAS,SAChB;AAEI,cAAU,KAAK,kBAA0C,OAAO;AAEhE,UAAM,SAAS,KAAK,OAAO,OAAO;AAElC,UAAM,OAAO,SAAS,cAAc,GAAG;AAEvC,SAAK,WAAW,QAAQ,YAAY;AACpC,SAAK,OAAO,OAAO,UAAU,WAAW;AACxC,aAAS,KAAK,YAAY,IAAI;AAC9B,SAAK,MAAA;AACL,aAAS,KAAK,YAAY,IAAI;EAElC;;;;;;;;;;;;;;;;;EAkBO,IAAI,SACX;AACI,UAAM,QAAQ,QAAQ,SAAS;AAE/B,cAAU,KAAK,kBAAkB,OAAO;AAExC,UAAM,SAAS,KAAK,OAAO,OAAO;AAElC,UAAM,SAAS,OAAO,UAAA;AAGtB,YAAQ,IAAI,kBAAkB,OAAO,KAAK,MAAM,OAAO,MAAM,IAAI;AAEjE,UAAM,QAAQ;MACV;MACA,YAAY,KAAK,MAAM,GAAG;MAC1B,mBAAmB,MAAM;MACzB;IAAA,EACF,KAAK,GAAG;AAGV,YAAQ,IAAI,OAAO,KAAK;EAC5B;EAEO,UACP;AACI,SAAK,YAAY;EACrB;AACJ;AAtca,eAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;AAVS,eAwBK,sBAAoC;EAC9C,QAAQ;EACR,SAAS;AACb;AA3BG,IAAM,gBAAN;;;ACnaA,IAAM,gBAAN,MAAM,uBAAsB,QACnC;;;;;;;;;EASI,OAAc,OAAO,SACrB;AAEI,UAAM,EAAE,SAAS,GAAG,KAAA,IAAS;AAE7B,WAAO,IAAI,eAAc;MACrB,QAAQ,IAAI,cAAc,IAAI;MAC9B,SAAS,WAAW;IAAA,CACvB;EACL;;;;;;;;EASO,OAAO,OAAe,QAAgB,YAC7C;AACI,SAAK,OAAO,OAAO,OAAO,QAAQ,UAAU;AAE5C,WAAO;EACX;AACJ;;;ACyGA,IAAM,WAAW,IAAI,UAAA;AACrB,IAAMC,cAAa,IAAI,OAAA;AACvB,IAAM,UAAuB,CAAC,GAAG,GAAG,GAAG,CAAC;AAgEjC,IAAM,wBAAN,MACP;EAaI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsCO,gBAAgB,SACvB;;AACI,QAAI,mBAAmB,WACvB;AACI,gBAAU;QACN,QAAQ;QACR,OAAO;QACP,sBAAsB,CAAA;QACtB,YAAY;MAAA;IAEpB;AAEA,UAAM,aAAa,QAAQ,cAAc,KAAK,UAAU;AACxD,UAAM,YAAY,QAAQ,aAAa,KAAK,UAAU,KAAK;AAE3D,UAAM,YAAY,QAAQ;AAE1B,QAAI,aAAa,QAAQ;AAEzB,QAAI,YACJ;AACI,YAAM,cAAc,MAAM,QAAQ,UAAU,KAAK,WAAW,WAAW;AAEvE,mBAAa,cAAc,aAAa,MAAM,OAAO,SAAS,UAAU,EAAE,QAAA;IAC9E,OAEA;AACI,mBAAa;IACjB;AAEA,UAAM,WAAS,aAAQ,UAAR,mBAAe,OAAO,cAC9B,eAAe,WAAWA,WAAU,EAAE;AAE7C,WAAO,QAAQ,KAAK,IAAI,OAAO,OAAO,IAAI,UAAU,IAAI;AACxD,WAAO,SAAS,KAAK,IAAI,OAAO,QAAQ,IAAI,UAAU,IAAI;AAE1D,UAAM,SAAS,cAAc,OAAO;MAChC,GAAG,QAAQ;MACX,OAAO,OAAO;MACd,QAAQ,OAAO;MACf;MACA;IAAA,CACH;AAED,UAAM,YAAY,OAAO,OAAO,UAAU,CAAC,OAAO,GAAG,CAAC,OAAO,CAAC;AAE9D,SAAK,UAAU,OAAO;MAClB;MACA;MACA;MACA;IAAA,CACH;AAED,WAAO,OAAO,cAAA;AAEd,WAAO;EACX;EAEO,UACP;AACK,SAAK,YAAqB;EAC/B;AACJ;AArHa,sBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;ACxNG,SAAS,UAAa,MAC7B;AACI,MAAI,QAAQ;AAEZ,aAAW,KAAK,MAChB;AAEI,QAAI,KAAK,CAAC,KAAK,QACf;AACI,cAAQ;AACR;IACJ;EACJ;AAEA,MAAI,CAAC,MAAO,QAAO;AAEnB,QAAMC,aAAY,uBAAO,OAAO,IAAI;AAEpC,aAAW,KAAK,MAChB;AACI,UAAM,QAAQ,KAAK,CAAC;AAEpB,QAAI,OACJ;AACIA,iBAAU,CAAC,IAAI;IACnB;EACJ;AAEA,SAAOA;AACX;AAkBO,SAAS,WAAc,KAC9B;AACI,MAAI,SAAS;AAEb,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAChC;AAEI,QAAI,IAAI,CAAC,KAAK,QACd;AACI;IACJ,OAEA;AACI,UAAI,IAAI,MAAM,IAAI,IAAI,CAAC;IAC3B;EACJ;AAEA,MAAI,UAAU;AAEd,SAAO;AACX;;;ACkBO,IAAM,YAAN,MAAMC,WACb;;;;;EAiDI,YAAY,UACZ;AArBA,SAAiB,oBAA0C,CAAA;AAC3D,SAAiB,yBAAgD,CAAA;AACjE,SAAiB,sBAAoF,CAAA;AAYrG,SAAQ,SAAS;AAQb,SAAK,YAAY;EACrB;;;;;EAMO,KAAK,SACZ;AACI,cAAU,EAAE,GAAGA,WAAS,gBAAgB,GAAG,QAAA;AAE3C,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,aAAa,QAAQ;AAE1B,SAAK,UAAU,QAAQ;AACvB,SAAK,MAAM,YAAY,IAAA;EAC3B;;;;;EAMA,IAAI,UACJ;AACI,WAAO,CAAC,CAAC,KAAK;EAClB;;;;;;EAOA,IAAI,QAAQ,OACZ;AACI,QAAI,KAAK,YAAY,MAAO;AAE5B,QAAI,OACJ;AACI,WAAK,WAAW,KAAK,UAAU,UAAU;QACrC,MACA;AACI,eAAK,SAAS;QAClB;QACA,KAAK;QACL;MAAA;AAGJ,WAAK,sBAAsB,KAAK,UAAU,UAAU;QAChD,MACA;AACI,qBAAW,QAAQ,KAAK,qBACxB;AACI,kBAAM,EAAE,SAAS,YAAY,KAAA,IAAS;AAEtC,gBAAI,SAAS,QACb;AACI,sBAAQ,UAAU,IAAI,UAAU,QAAQ,UAAU,CAAC;YACvD,OAEA;AACI,sBAAQ,UAAU,IAAI,WAAW,QAAQ,UAAU,CAAC;YACxD;UACJ;QACJ;QACA,KAAK;MAAA;IAEb,OAEA;AACI,WAAK,UAAU,UAAU,OAAO,KAAK,QAAQ;AAC7C,WAAK,UAAU,UAAU,OAAO,KAAK,mBAAmB;AACxD,WAAK,WAAW;AAChB,WAAK,sBAAsB;IAC/B;EACJ;;;;;;EAOU,UAAU,EAAE,UAAA,GACtB;AACI,SAAK,MAAM,YAAY,IAAA;AACvB,cAAU,YAAY,SAAS,KAAK,UAAU;AAE9C,SAAK,yBAAyB,UAAU,aAAa,UAAU,YAAY,MAAM;EACrF;;EAGU,aACV;AACI,QAAI,CAAC,KAAK,UAAU,CAAC,KAAK,QAAS;AAEnC,SAAK,IAAA;AACL,SAAK,SAAS;EAClB;;;;;;EAOQ,yBAAyB,aAA0B,QAC3D;AACI,gBAAY,eAAe,SAAS;AACpC,gBAAY,SAAS;AAErB,eAAW,SAAS,YAAY,qBAChC;AACI,WAAK,yBAAyB,OAAO,MAAM;IAC/C;EACJ;;;;;;;EAQO,cAAc,SAAc,YAAoB,MACvD;AACI,SAAK,oBAAoB,KAAK;MAC1B;MACA;MACA;IAAA,CACH;EACL;;;;;;EAOO,YAAY,UAA8B,MACjD;;AAEI,QAAI,SAAS,gBAAgB,IAC7B;AACI,eAAS,cAAc,KAAK;AAC5B,qBAAS,aAAT,kCAAoB,KAAK;AAEzB;IACJ;AAEA,UAAM,QAAQ,KAAK,kBAAkB;AAErC,aAAS,UAAU;MACf;MACA;IAAA;AAEJ,aAAS,cAAc,KAAK;AAC5B,mBAAS,aAAT,kCAAoB,KAAK;AACzB,aAAS,KAAK,UAAU,KAAK,gBAAgB,IAAI;AAEjD,SAAK,kBAAkB,KAAK,QAAQ;EACxC;;;;;;EAOO,eAAe,UACtB;AACI,UAAM,SAAS,SAAS;AAExB,QAAI,CAAC,OAAQ;AAEb,UAAM,QAAQ,OAAO;AACrB,UAAM,OAAO,KAAK,kBAAkB,SAAS;AAG7C,QAAI,UAAU,MACd;AACI,YAAM,eAAe,KAAK,kBAAkB,IAAI;AAEhD,WAAK,kBAAkB,KAAK,IAAI;AAChC,mBAAa,QAAQ,QAAQ;IACjC;AAEA,SAAK,kBAAkB;AACvB,aAAS,UAAU;AACnB,aAAS,cAAc;EAC3B;;;;;;;;;EAUO,gBAAgB,SAAc,MAAc,MAAsB,WAAmB,GAC5F;AACI,SAAK,uBAAuB,KAAK;MAC7B;MACA;MACA;MACA;IAAA,CACH;AAED,SAAK,uBAAuB,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,QAAQ;EACtE;;;;;EAMO,MACP;AACI,UAAM,MAAM,YAAY,IAAA;AACxB,UAAM,wBAAwB,KAAK;AAEnC,eAAW,aAAa,uBACxB;AACI,WAAK,UAAU,WAAW,GAAG;IACjC;AAEA,QAAI,aAAa;AAEjB,aAAS,IAAI,GAAG,IAAI,KAAK,kBAAkB,QAAQ,KACnD;AACI,YAAM,WAAW,KAAK,kBAAkB,CAAC;AAEzC,mBAAa,KAAK,cAAc,UAAU,KAAK,UAAU;IAC7D;AAEA,SAAK,kBAAkB,SAAS;EACpC;EAEU,uBAAuB,YAAiC,KAClE;;AACI,UAAM,cAAc,WAAW,eAAe,WAAW;AACzD,UAAM,gBAAc,gDAAa,mBAAb,mBAA6B,WAAU;AAG3D,UAAK,2CAAa,WAAU,OAAO,aACnC;AACI,iBAAW,cAAc;AACzB,uBAAW,aAAX,oCAAsB;IAC1B;EACJ;EAEU,cAAc,UAA8B,KAAa,YACnE;AACI,UAAM,SAAS,SAAS;AAGxB,QAAI,OAAO,SAAS,cACpB;AACI,WAAK,uBAAuB,UAAwB,GAAG;IAC3D;AAEA,UAAM,iBAAiB,MAAM,SAAS,cAAc,KAAK;AAEzD,QAAI,kBAAkB,CAAC,SAAS,oBAChC;AACI,WAAK,kBAAkB,UAAU,IAAI;AACrC,aAAO,QAAQ;AACf;IACJ,OAEA;AAEI,eAAS,OAAA;AACT,eAAS,UAAU;AACnB,eAAS,cAAc;AACvB,eAAS,IAAI,UAAU,KAAK,gBAAgB,IAAI;IACpD;AAEA,WAAO;EACX;;;;;;;EAQQ,iBAAiB,WAAmC,SAC5D;AACI,UAAM,YAAoC,uBAAO,OAAO,IAAI;AAE5D,eAAW,KAAK,WAChB;AACI,UAAI,MAAM,QAAS;AACnB,UAAI,UAAU,CAAC,MAAM,KAAA,WAAgB,CAAC,IAAI,UAAU,CAAC;IACzD;AAEA,WAAO;EACX;EAEU,UAAU,WAAgC,KACpD;;AACI,UAAM,EAAE,SAAS,MAAM,KAAA,IAAS;AAEhC,UAAM,YAAY,QAAQ,IAAI;AAC9B,QAAI,YAA2C;AAC/C,QAAI,YAAY;AAEhB,eAAW,OAAO,WAClB;AACI,YAAM,WAAW,UAAU,GAAG;AAG9B,UAAI,aAAa,MACjB;AACI;AAGA,YAAI,cAAc,OAAS,CAAC,WAC5B;AACI,sBAAY,KAAK,iBAAiB,WAAW,GAAG;QACpD;AAEA;MACJ;AAGA,UAAI,SAAS,gBAAgB,IAC7B;AACI,iBAAS,cAAc;AACvB,uBAAS,aAAT,kCAAoB;AAEpB,YAAI,UAAW,WAAU,GAAG,IAAI;AAEhC;MACJ;AAGA,UAAI,SAAS,cACb;AACI,aAAK,uBAAuB,UAAwB,GAAG;MAC3D;AAEA,YAAM,iBAAiB,MAAM,SAAS,cAAc,KAAK;AAEzD,UAAI,CAAC,kBAAkB,SAAS,oBAChC;AAEI,YAAI,CAAC,WACL;AAGI,cAAI,YAAY,MAAM,KACtB;AACI,sBAAU,GAAG,IAAI;AACjB;UACJ,OAEA;AACI,wBAAY,KAAK,iBAAiB,WAAW,GAAG;UACpD;QACJ;AAEA,YAAI,SAAS,cACb;AACI,gBAAM,MAAM;AACZ,gBAAM,cAAc,IAAI,eAAe,IAAI;AAE3C,cAAI,YAAA,aAAyB,qBAAqB;QACtD;AAGA,iBAAS,OAAA;AACT,iBAAS,UAAU;AACnB,iBAAS,cAAc;MAC3B,WACS,WACT;AACI,kBAAU,GAAG,IAAI;MACrB;IACJ;AAGA,QAAI,WACJ;AACI,cAAQ,IAAI,IAAI;IACpB;EACJ;;EAGO,UACP;AACI,SAAK,UAAU;AAEf,SAAK,kBAAkB,QAAQ,CAAC,aAChC;AACI,eAAS,IAAI,UAAU,KAAK,gBAAgB,IAAI;IACpD,CAAC;AACD,SAAK,kBAAkB,SAAS;AAChC,SAAK,uBAAuB,SAAS;AACrC,SAAK,oBAAoB,SAAS;AAClC,SAAK,YAAY;EACrB;AACJ;AAjca,UAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;EACN,UAAU;AACd;AAXS,UAcK,iBAAkC;;EAE5C,UAAU;;EAEV,iBAAiB;;EAEjB,aAAa;AACjB;AArBG,IAAM,WAAN;;;ACxFA,SAAS,eAAe,KAAa,OAAe,KAAmB,QAC9E;AAEI,MAAI,QAAQ,KAAM,OAAO,KAAM,OAAQ;AACvC,MAAI,QAAQ,KAAM,OAAO,IAAK,OAAQ;AACtC,MAAI,QAAQ,KAAK,MAAM,OAAQ;AAC/B,MAAI,QAAQ,IAAI;AACpB;AAQO,SAAS,oBAAoB,MAAc,KAAmB,QACrE;AACI,QAAM,SAAU,QAAQ,KAAM,OAAQ;AAEtC,MAAI,QAAQ,KAAM,OAAO,OAAQ,MAAO;AACxC,MAAI,QAAQ,KAAO,QAAQ,IAAK,OAAQ,MAAO;AAC/C,MAAI,QAAQ,KAAO,QAAQ,KAAM,OAAQ,MAAO;AAChD,MAAI,QAAQ,IAAI;AACpB;;;AC2CO,IAAM,sBAAN,MACP;EAwBI,YAAY,UACZ;AAZA,SAAQ,cAAc;AACtB,SAAQ,0BAA+C,CAAA;AAEvD,SAAiB,gBAAsC,CAAA;AACvD,SAAiB,kBAAwC,CAAA;AAEzD,SAAiB,iBAA8B,CAAA;AAC/C,SAAiB,oBAAiC,CAAA;AAM9C,SAAK,YAAY;EACrB;EAEO,QACP;AACI,SAAK,cAAc;AAEnB,aAAS,IAAI,GAAG,IAAI,KAAK,gBAAgB,QAAQ,KACjD;AACI,WAAK,cAAc,KAAK,KAAK,gBAAgB,CAAC,CAAC;IACnD;AAEA,aAAS,IAAI,GAAG,IAAI,KAAK,kBAAkB,QAAQ,KACnD;AACI,WAAK,eAAe,KAAK,KAAK,kBAAkB,CAAC,CAAC;IACtD;AAEA,SAAK,gBAAgB,SAAS;AAC9B,SAAK,kBAAkB,SAAS;EACpC;EAEO,MAAM,SACb;AACI,SAAK,MAAA;AAEL,SAAK,KAAK,OAAO;EACrB;EAEO,KAAK;IACR;IACA;IACA;IACA;IACA;EAAA,GAEJ;AACI,UAAM,eAAe,KAAK,UAAU,aAAa;AAEjD,UAAM,2BAA2B,KAAK,cAAc,KAAK,wBAAwB,KAAK,cAAc,CAAC,IAAI;MACrG,gBAAgB;MAChB,sBAAsB,IAAI,OAAA;MAC1B,YAAY;MACZ,QAAQ,IAAI,MAAA;IAAM;AAGtB,UAAM,oBAAuC;MACzC,kBAAkB,oBAAoB,KAAK,UAAU,aAAa;MAClE,YAAY,QAAQ,aAAa;MACjC,sBAAsB,wBAAwB,yBAAyB;MACvE,YAAY,cAAc,yBAAyB;MACnD,QAAQ,UAAU,yBAAyB;MAC3C,WAAW;IAAA;AAGf,UAAM,eAAe,KAAK,cAAc,IAAA,KAAS,KAAK,gBAAA;AAEtD,SAAK,gBAAgB,KAAK,YAAY;AAEtC,UAAM,WAAW,aAAa;AAE9B,aAAS,oBAAoB,kBAAkB;AAE/C,aAAS,cAAc,kBAAkB;AAEzC,aAAS,sBAAsB,SAAS,kBAAkB,oBAAoB;AAE9E,aAAS,sBAAsB,MAAM,kBAAkB,OAAO;AAC9D,aAAS,sBAAsB,MAAM,kBAAkB,OAAO;AAE9D;MACI,kBAAkB;MAClB,SAAS;MACT;IAAA;AAGJ,iBAAa,OAAA;AAEb,QAAI;AAEJ,QAAK,KAAK,UAA6B,YAAY,cACnD;AACI,kBAAa,KAAK,UAA6B,YAAY,aAAa,oBAAoB,cAAc,KAAK;IACnH,OAEA;AACI,kBAAY,KAAK,eAAe,IAAA,KAAS,IAAI,UAAA;AAC7C,WAAK,kBAAkB,KAAK,SAAS;AACrC,gBAAU,YAAY,cAAc,CAAC;IACzC;AAEA,sBAAkB,YAAY;AAE9B,SAAK,4BAA4B;EACrC;EAEO,KAAK,SACZ;AACI,SAAK,KAAK,OAAO;AAEjB,SAAK,wBAAwB,KAAK,aAAa,IAAI,KAAK;EAC5D;EAEO,MACP;AACI,SAAK,4BAA4B,KAAK,wBAAwB,EAAE,KAAK,cAAc,CAAC;AAIpF,QAAI,KAAK,UAAU,SAAS,aAAa,OACzC;AACK,WAAK,0BAA0B,UAAU,UAAU,CAAC,EAAmB,OAAA;IAC5E;EACJ;EAEA,IAAI,YACJ;AACI,WAAO,KAAK,0BAA0B;EAC1C;EAEA,IAAI,oBACJ;AACI,WAAO,KAAK;EAChB;EAEA,IAAI,eACJ;AACI,WAAO,KAAK,0BAA0B,UAAU,UAAU,CAAC;EAC/D;EAEQ,kBACR;AACI,UAAM,iBAAiB,IAAI,aAAa;MACpC,mBAAmB,EAAE,OAAO,IAAI,OAAA,GAAU,MAAM,cAAA;MAChD,uBAAuB,EAAE,OAAO,IAAI,OAAA,GAAU,MAAM,cAAA;;MAEpD,kBAAkB,EAAE,OAAO,IAAI,aAAa,CAAC,GAAG,MAAM,YAAA;MACtD,aAAa,EAAE,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,YAAA;IAAY,GACjD;MACC,UAAU;IAAA,CACb;AAED,WAAO;EACX;EAEO,UACP;AACK,SAAK,YAAqB;AAC3B,SAAK,wBAAwB,SAAS;AACtC,SAAK,cAAc,SAAS;AAC5B,SAAK,gBAAgB,SAAS;AAC9B,SAAK,eAAe,SAAS;AAC7B,SAAK,kBAAkB,SAAS;AAChC,SAAK,4BAA4B;EACrC;AACJ;AArLa,oBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;;;AC7EJ,IAAIC,OAAM;AAOH,IAAM,kBAAN,MACP;EADO,cAAA;AAaH,SAAiB,SAQX,CAAA;AAGN,SAAQ,UAAU;EAAA;;EAGX,OACP;AACI,WAAO,OAAO,IAAI,KAAK,SAAS,IAAI;EACxC;;;;;;;;EASO,OAAO,MAAiC,UAAkB,YAAY,MAC7E;AACI,UAAM,KAAKA;AAEX,QAAI,SAAS;AAEb,QAAI,WACJ;AACI,WAAK,WAAW;AAChB,eAAS,KAAK;IAClB;AAEA,SAAK,OAAO,KAAK;MACb;MACA;MACA,OAAO,YAAY,IAAA;MACnB;MACA,MAAM,YAAY,IAAA;MAClB,QAAQ;MACR;IAAA,CACH;AAED,WAAO;EACX;;;;;EAMO,OAAO,IACd;AACI,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KACxC;AACI,UAAI,KAAK,OAAO,CAAC,EAAE,OAAO,IAC1B;AACI,aAAK,OAAO,OAAO,GAAG,CAAC;AAEvB;MACJ;IACJ;EACJ;;;;;EAMQ,UACR;AACI,UAAM,MAAM,YAAY,IAAA;AAExB,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KACxC;AACI,YAAM,OAAO,KAAK,OAAO,CAAC;AAE1B,UAAK,MAAM,KAAK,SAAU,KAAK,QAAQ,KAAK,UAC5C;AACI,cAAM,UAAU,MAAM,KAAK;AAE3B,aAAK,KAAK,OAAO;AACjB,aAAK,OAAO;MAChB;IACJ;EACJ;;;;;EAMO,UACP;AACI,WAAO,OAAO,OAAO,KAAK,SAAS,IAAI;AAEvC,SAAK,OAAO,SAAS;EACzB;AACJ;AAjHa,gBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;EACN,UAAU;AACd;;;ACrBJ,IAAI,YAAY;AAST,SAAS,SAAS,MACzB;AACI,MAAI,WACJ;AACI;EACJ;AAEA,MAAI,WAAW,IAAA,EAAM,aAAA,EAAe,UAAU,YAAA,EAAc,QAAQ,QAAQ,IAAI,IAChF;AACI,UAAM,OAAO;MACT,iCAAiC,OAAO,KAAK,IAAI;;;MACjD;MACA;MACA;MACA;MACA;MACA;IAAA;AAGJ,eAAW,QAAQ,IAAI,GAAG,IAAI;EAClC,WACS,WAAW,SACpB;AACI,eAAW,QAAQ,IAAI,UAAU,OAAO,MAAM,IAAI,2BAA2B;EACjF;AAEA,cAAY;AAChB;;;ACZO,IAAM,cAAN,MACP;EAoBI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;;;;;EAMO,KAAK,SACZ;AACI,QAAI,QAAQ,OACZ;AACI,UAAI,OAAO,KAAK,UAAU;AAE1B,UAAI,KAAK,UAAU,SAAS,aAAa,OACzC;AACI,gBAAQ,IAAK,KAAK,UAA4B,QAAQ,YAAY;MACtE;AAEA,eAAS,IAAI;IACjB;EACJ;AACJ;AA5Ca,YAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;EACN,UAAU;AACd;AAXS,YAcK,iBAAqC;;EAE/C,OAAO;AACX;;;AC4BG,IAAM,sBAAN,MAAMC,qBACb;;;;;EAuCI,YAAY,UACZ;AACI,SAAK,YAAY;EACrB;;;;;EAMO,KAAK,SACZ;AACI,cAAU,EAAE,GAAGA,qBAAmB,gBAAgB,GAAG,QAAA;AAErD,SAAK,gBAAgB,QAAQ;EACjC;;;;;EAMA,IAAI,UACJ;AAEI,gBAAY,UAAU,oFAAoF;AAG1G,WAAO,KAAK,UAAU,GAAG;EAC7B;;;;;;EAOA,IAAI,QAAQ,OACZ;AAEI,gBAAY,UAAU,oFAAoF;AAE1G,SAAK,UAAU,GAAG,UAAU;EAChC;;;;;;EAOO,eAAkB,SAAY,MACrC;AAGI,gBAAY,UAAU,iGAAiG;AAEvH,SAAK,UAAU,GAAG,cAAc,SAAS,MAAM,MAAM;EACzD;;;;;;EAOO,gBAAmB,SAAY,MACtC;AAGI,gBAAY,UAAU,kGAAkG;AAExH,SAAK,UAAU,GAAG,cAAc,SAAS,MAAM,OAAO;EAC1D;;;;;;EAOO,cAAc,aACrB;AAEI,gBAAY,UAAU,kFAAkF;AAExG,SAAK,UAAU,GAAG,YAAY,aAAa,YAAY;EAC3D;;;;;EAMO,MACP;AAEI,gBAAY,UAAU,wEAAwE;AAE9F,SAAK,UAAU,GAAG,IAAA;EACtB;;EAGO,UACP;AACI,SAAK,YAAY;EACrB;AACJ;AA5Ia,oBAMK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;EACN,UAAU;AACd;AAdS,oBAqBK,iBAA4C;;EAEtD,oBAAoB;;EAEpB,2BAA2B;;EAE3B,uBAAuB;AAC3B;AA5BG,IAAM,qBAAN;;;ACzBA,IAAM,mBAAN,MAAMC,kBACb;;;;;;EA0CI,IAAW,QAAQ;AAAE,WAAO,KAAK,UAAU;EAAM;;;;;;EAOjD,IAAW,aAAa;AAAE,WAAO,KAAK;EAAa;EACnD,IAAW,WAAW,OACtB;AAEI,gBAAY,UAAU,qEAAqE;AAE3F,SAAK,cAAc;EACvB;;;;;;EAQA,IAAW,UAAU;AAAE,WAAQ,KAAK,UAAU,GAAG,gBAAgB,MAAQ;EAAI;EAC7E,IAAW,QAAQ,OACnB;AAEI,gBAAY,UAAU,qEAAqE;AAE3F,SAAK,UAAU,GAAG,gBAAiB,QAAQ,KAAM;EACrD;;;;;;;EAQA,IAAW,gBAAgB;AAAE,WAAO,KAAK,MAAM,KAAK,UAAU,GAAG,YAAY,IAAI,GAAI;EAAG;EACxF,IAAW,cAAc,QACzB;AAEI,gBAAY,UAAU,qEAAqE;EAE/F;;;;;;EAOA,IAAW,SAAS;AAAE,WAAO,KAAK,UAAU,GAAG;EAAS;EACxD,IAAW,OAAO,OAClB;AAEI,gBAAY,UAAU,qEAAqE;AAE3F,SAAK,UAAU,GAAG,UAAU;EAChC;;EAKA,YAAY,UACZ;AACI,SAAK,YAAY;AACjB,SAAK,cAAc;EACvB;EAEO,KAAK,SACZ;AACI,QAAI,QAAQ,oBAAoBA,kBAAgB,eAAe,iBAC/D;AAAE,WAAK,SAAS,QAAQ;IAAiB;AACzC,QAAI,QAAQ,qBAAqBA,kBAAgB,eAAe,kBAChE;AAAE,WAAK,UAAU,QAAQ;IAAkB;AAC3C,QAAI,QAAQ,2BAA2BA,kBAAgB,eAAe,wBACtE;AAAE,WAAK,gBAAgB,QAAQ;IAAwB;EAC3D;;;;;;EAOO,MACP;AAEI,gBAAY,UAAU,qEAAqE;AAE3F,SAAK,UAAU,GAAG,IAAA;EACtB;EAEO,UACP;AACI,SAAK,YAAY;EACrB;AACJ;AA1Ia,iBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;AATS,iBAeK,iBAAyC;;;;;EAKnD,iBAAiB;;;;;EAKjB,mBAAmB;;;;;EAKnB,kBAAkB,KAAK;;;;;EAKvB,wBAAwB;AAC5B;AApCG,IAAM,kBAAN;;;ACFA,IAAM,gBAAN,MAAMC,eACb;;;;EA8CI,YAAY,aAAkC,CAAA,GAC9C;AAzBA,SAAgB,MAAc,IAAI,cAAc;AAMhD,SAAO,gBAAiC,CAAA;AAQxC,SAAO,UAAU;AACjB,SAAO,SAAS;AAEhB,SAAiB,QAAQ,IAAI,aAAa,CAAC;AAE3C,SAAiB,wBAAiC;AAO9C,iBAAa,EAAE,GAAGA,eAAa,gBAAgB,GAAG,WAAA;AAElD,SAAK,UAAU,WAAW;AAC1B,SAAK,QAAQ,WAAW;AACxB,SAAK,SAAS,WAAW;AAEzB,QAAI,OAAO,WAAW,kBAAkB,UACxC;AACI,WAAK,wBAAwB;AAE7B,eAAS,IAAI,GAAG,IAAI,WAAW,eAAe,KAC9C;AACI,aAAK,cAAc;UAAK,IAAI,cAAc;YACtC,OAAO,WAAW;YAClB,QAAQ,WAAW;YACnB,YAAY,WAAW;YACvB,WAAW,WAAW;UAAA,CACzB;QAAA;MAEL;IACJ,OAEA;AACI,WAAK,gBAAgB,CAAC,GAAG,WAAW,cAAc,IAAI,CAAC,YAAY,QAAQ,MAAM,CAAC;AAElF,YAAM,cAAc,KAAK,aAAa;AAEtC,WAAK,OAAO,YAAY,OAAO,YAAY,QAAQ,YAAY,WAAW;IAC9E;AAGA,SAAK,aAAa,OAAO,GAAG,UAAU,KAAK,gBAAgB,IAAI;AAI/D,QAAI,WAAW,uBAAuB,KAAK,SAC3C;AAEI,UAAI,WAAW,+BAA+B,WACvC,WAAW,+BAA+B,eACjD;AACI,aAAK,sBAAsB,WAAW,oBAAoB;MAC9D,OAEA;AACI,aAAK,0BAAA;MACT;IACJ;EACJ;EAEA,IAAI,OACJ;AACI,UAAM,QAAQ,KAAK;AAEnB,UAAM,CAAC,IAAI,KAAK;AAChB,UAAM,CAAC,IAAI,KAAK;AAEhB,WAAO;EACX;EAEA,IAAI,QACJ;AACI,WAAO,KAAK,aAAa,OAAO;EACpC;EAEA,IAAI,SACJ;AACI,WAAO,KAAK,aAAa,OAAO;EACpC;EACA,IAAI,aACJ;AACI,WAAO,KAAK,aAAa,OAAO;EACpC;EAEA,IAAI,cACJ;AACI,WAAO,KAAK,aAAa,OAAO;EACpC;EAEA,IAAI,aACJ;AACI,WAAO,KAAK,aAAa,OAAO;EACpC;EAEA,IAAI,eACJ;AACI,WAAO,KAAK,cAAc,CAAC;EAC/B;EAEU,eAAeC,SACzB;AACI,SAAK,OAAOA,QAAO,OAAOA,QAAO,QAAQA,QAAO,aAAa,IAAI;EACrE;;;;;;EAOO,4BACP;AACI,QAAI,CAAC,KAAK,qBACV;AACI,WAAK,sBAAsB,IAAI,cAAc;QACzC,OAAO,KAAK;QACZ,QAAQ,KAAK;QACb,YAAY,KAAK;QACjB,QAAQ;QACR,qBAAqB;QACrB,WAAW;QACX,eAAe;;MAAA,CAElB;IACL;EACJ;EAEO,OAAO,OAAe,QAAgB,aAAa,KAAK,YAAY,mBAAmB,OAC9F;AACI,SAAK;AAEL,SAAK,cAAc,QAAQ,CAAC,cAAc,MAC1C;AACI,UAAI,oBAAoB,MAAM,EAAG;AAEjC,mBAAa,OAAO,OAAO,OAAO,QAAQ,UAAU;IACxD,CAAC;AAED,QAAI,KAAK,qBACT;AACI,WAAK,oBAAoB,OAAO,OAAO,OAAO,QAAQ,UAAU;IACpE;EACJ;EAEO,UACP;AACI,SAAK,aAAa,OAAO,IAAI,UAAU,KAAK,gBAAgB,IAAI;AAEhE,QAAI,KAAK,uBACT;AACI,WAAK,cAAc,QAAQ,CAAC,YAC5B;AACI,gBAAQ,QAAA;MACZ,CAAC;IACL;AAEA,QAAI,KAAK,qBACT;AACI,WAAK,oBAAoB,QAAA;AACzB,aAAO,KAAK;IAChB;EACJ;AACJ;AAxMa,cAGK,iBAAsC;;EAEhD,OAAO;;EAEP,QAAQ;;EAER,YAAY;;EAEZ,eAAe;;EAEf,SAAS;;EAET,OAAO;;EAEP,WAAW;;;EAEX,QAAQ;AACZ;AApBG,IAAM,eAAN;;;ACtCP,IAAM,cAAA,oBAAuD,IAAA;AAE7D,uBAAuB,SAAS,WAAW;AAOpC,SAAS,iBAAiB,QAAiB,SAClD;AACI,MAAI,CAAC,YAAY,IAAI,MAAM,GAC3B;AACI,UAAM,UAAU,IAAI,QAAQ;MACxB,QAAQ,IAAI,aAAa;QACrB,UAAU;QACV,GAAG;MAAA,CACN;IAAA,CACJ;AAED,UAAM,YAAY,MAClB;AACI,UAAI,YAAY,IAAI,MAAM,MAAM,SAChC;AACI,oBAAY,OAAO,MAAM;MAC7B;IACJ;AAEA,YAAQ,KAAK,WAAW,SAAS;AACjC,YAAQ,OAAO,KAAK,WAAW,SAAS;AAExC,gBAAY,IAAI,QAAQ,OAAO;EACnC;AAEA,SAAO,YAAY,IAAI,MAAM;AACjC;AAMO,SAAS,uBAAuB,QACvC;AACI,SAAO,YAAY,IAAI,MAAM;AACjC;;;ACmBO,IAAM,cAAN,MAAMC,aACb;;;;;;EA+CI,IAAW,cACX;AACI,WAAO,KAAK,QAAQ,OAAO;EAC/B;EACA,IAAW,YAAY,OACvB;AACI,SAAK,QAAQ,OAAO,cAAc;EACtC;;EAeA,IAAI,aACJ;AACI,WAAO,KAAK,QAAQ,OAAO;EAC/B;EAEA,IAAI,WAAW,OACf;AACI,SAAK,QAAQ,OAAO;MAChB,KAAK,QAAQ,OAAO;MACpB,KAAK,QAAQ,OAAO;MACpB;IAAA;EAER;;;;;EAMO,KAAK,SACZ;AACI,cAAU;MACN,GAAGA,aAAW;MACd,GAAG;IAAA;AAGP,QAAI,QAAQ,MACZ;AAEI,kBAAY,QAAQ,uDAAuD;AAG3E,cAAQ,SAAS,QAAQ;IAC7B;AAEA,SAAK,SAAS,IAAI,UAAU,GAAG,GAAG,QAAQ,OAAO,QAAQ,MAAM;AAC/D,SAAK,SAAS,QAAQ,UAAU,WAAW,IAAA,EAAM,aAAA;AACjD,SAAK,YAAY,CAAC,CAAC,QAAQ;AAC3B,SAAK,UAAU,iBAAiB,KAAK,QAAQ,OAAO;AACpD,SAAK,eAAe,IAAI,aAAa;MACjC,eAAe,CAAC,KAAK,OAAO;MAC5B,OAAO,CAAC,CAAC,QAAQ;MACjB,QAAQ;IAAA,CACX;AAED,SAAK,QAAQ,OAAO,cAAe,QAA4B,kBAAkB;AACjF,SAAK,aAAa,QAAQ;EAC9B;;;;;;;EAQO,OAAO,oBAA4B,qBAA6B,YACvE;AACI,SAAK,QAAQ,OAAO,OAAO,oBAAoB,qBAAqB,UAAU;AAE9E,SAAK,OAAO,QAAQ,KAAK,QAAQ,MAAM;AACvC,SAAK,OAAO,SAAS,KAAK,QAAQ,MAAM;EAC5C;;;;;;;;;EAUO,QAAQ,UAAgD,OAC/D;AACI,UAAM,aAAa,OAAO,YAAY,YAAY,UAAU,CAAC,EAAC,mCAAS;AAEvE,QAAI,cAAc,KAAK,OAAO,YAC9B;AACI,WAAK,OAAO,WAAW,YAAY,KAAK,MAAM;IAClD;AAEA,SAAK,QAAQ,QAAA;EAIjB;AACJ;AA1Ja,YAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;EACN,UAAU;AACd;AAXS,YAcK,iBAAoC;;;;;EAK9C,OAAO;;;;;EAKP,QAAQ;;;;;EAKR,aAAa;;;;;EAKb,WAAW;AACf;AAnCG,IAAM,aAAN;;;AC1CA,IAAM,gBAAgB;EACzB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AAOO,IAAM,oBAAoB;EAC7B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;;;AC9CO,SAAS,oBACZ,IACA,GACA,GACA,OACA,QACA,OAEJ;AACI,QAAM,OAAO,QAAQ,IAAI;AAEzB,KAAG,SAAA;AAEH,KAAG,IAAK,IAAI,QAAQ;AACpB,KAAG,IAAI,QAAQ,IAAI,SAAS;AAE5B,KAAG,KAAK,KAAM,IAAI,GAAG;AACrB,KAAG,KAAK,CAAC,OAAQ,IAAI,GAAG;AAExB,SAAO;AACX;;;ACrBO,SAAS,oBAAoB,cACpC;AACI,QAAM,WAAW,aAAa,aAAa,OAAO;AAElD,SAAS,WAAW,qBAAqB,oBAAoB,qBAAsB,SAAS,KAAK,SAAS,QAAQ;AACtH;;;ACyLO,IAAM,qBAAN,MACP;EA6CI,YAAY,UACZ;AA1CA,SAAO,eAAe,IAAI,UAAA;AAQ1B,SAAgB,WAAW,IAAI,UAAA;AAE/B,SAAO,WAAW;AAElB,SAAO,QAAQ;AAKf,SAAgB,uBAAuB,IAAI,aAAa,sBAAsB;AAE9E,SAAgB,mBAAmB,IAAI,OAAA;AAEvC,SAAgB,oBAA+B,CAAC,GAAG,GAAG,GAAG,CAAC;AAO1D,SAAiB,mCAAA,oBACP,IAAA;AAEV,SAAQ,uBAAsD,uBAAO,OAAO,IAAI;AAMhF,SAAiB,qBAA6C,CAAA;AAM1D,SAAK,YAAY;AACjB,aAAS,GAAG,cAAc,MAAM,wBAAwB,MAAM;EAClE;;EAGO,mBACP;AACI,SAAK,QAAQ,iBAAiB,KAAK,YAAY;EACnD;;;;;;;;;;;;EAaO,YAAY;IACf;IACA;IACA;IACA;IACA;IACA;EAAA,GASJ;;AAEI,SAAK,mBAAmB,SAAS;AAEjC,SAAK;MACD;MACA;MACA;MACA;MACA,YAAY;MACZ,SAAS;IAAA;AAGb,SAAK,aAAa,SAAS,KAAK,QAAQ;AACxC,SAAK,mBAAmB,KAAK;AAC7B,SAAK,oBAAoB,oBAAoB,KAAK,gBAAgB;AAElE,qBAAK,SAAQ,cAAb,4BAAyB,KAAK;EAClC;EAEO,aACP;;AACI,qBAAK,SAAQ,eAAb,4BAA0B,KAAK;EACnC;;;;;;;;;;;;;;;;;;;;;;;;;;EA2BO,KACH,eACA,QAAuB,MACvB,YACA,OACA,WAAW,GACX,QAAQ,GAEZ;AACI,UAAM,eAAe,KAAK,gBAAgB,aAAa;AAEvD,UAAM,YAAY,KAAK,iBAAiB;AAExC,SAAK,eAAe;AACpB,SAAK,gBAAgB;AAErB,UAAM,kBAAkB,KAAK,mBAAmB,YAAY;AAE5D,QAAI,aAAa,eAAe,gBAAgB,SACzC,aAAa,gBAAgB,gBAAgB,QACpD;AACI,WAAK,QAAQ,sBAAsB,YAAY;AAE/C,sBAAgB,QAAQ,aAAa;AACrC,sBAAgB,SAAS,aAAa;IAC1C;AAEA,UAAMC,UAAS,aAAa;AAC5B,UAAM,WAAW,KAAK;AACtB,UAAM,kBAAkBA,QAAO,mBAAmB;AAElD,SAAK,QAAQ,OAAO,OACpB;AACI,eAAS;IACb;AAEA,QAAI,QAAQ,KAAK,SAAS,iBAC1B;AACI,YAAM,IAAI,MAAM,8BAA8B,KAAK,sCAAsC,eAAe,IAAI;IAChH;AAEA,SAAK,WAAW,WAAW;AAC3B,SAAK,QAAQ,QAAQ;AAErB,UAAM,aAAa,KAAK,IAAIA,QAAO,cAAc,UAAU,CAAC;AAC5D,UAAM,cAAc,KAAK,IAAIA,QAAO,eAAe,UAAU,CAAC;AAK9D,QAAI,CAAC,SAAS,yBAAyB,SACvC;AACI,cAAQ,cAAc;IAC1B;AAEA,QAAI,OACJ;AACI,YAAM,aAAaA,QAAO;AAC1B,YAAM,QAAQ,KAAK,KAAK,IAAI,WAAW,GAAG,CAAC;AAG3C,YAAM,QAAU,MAAM,IAAI,aAAc,MAAO;AAC/C,YAAM,QAAU,MAAM,IAAI,aAAc,MAAO;AAC/C,YAAM,QAAU,MAAM,QAAQ,aAAc,MAAO;AACnD,YAAM,QAAU,MAAM,SAAS,aAAc,MAAO;AAIpD,UAAI,IAAI,KAAK,MAAM,QAAQ,KAAK;AAChC,UAAI,IAAI,KAAK,MAAM,QAAQ,KAAK;AAChC,UAAI,IAAI,KAAK,KAAK,QAAQ,KAAK;AAC/B,UAAI,IAAI,KAAK,KAAK,QAAQ,KAAK;AAG/B,UAAI,KAAK,IAAI,KAAK,IAAI,GAAG,CAAC,GAAG,aAAa,CAAC;AAC3C,UAAI,KAAK,IAAI,KAAK,IAAI,GAAG,CAAC,GAAG,cAAc,CAAC;AAC5C,UAAI,KAAK,IAAI,KAAK,IAAI,GAAG,CAAC,GAAG,aAAa,CAAC;AAC3C,UAAI,KAAK,IAAI,KAAK,IAAI,GAAG,CAAC,GAAG,cAAc,CAAC;AAE5C,eAAS,IAAI;AACb,eAAS,IAAI;AACb,eAAS,QAAQ;AACjB,eAAS,SAAS;IACtB,OAEA;AACI,eAAS,IAAI;AACb,eAAS,IAAI;AACb,eAAS,QAAQ;AACjB,eAAS,SAAS;IACtB;AAEA;MACI,KAAK;MACL;MAAG;MACH,SAAS,QAAQA,QAAO;MACxB,SAAS,SAASA,QAAO;MACzB,CAAC,aAAa;IAAA;AAGlB,SAAK,QAAQ,gBAAgB,cAAc,OAAO,YAAY,UAAU,UAAU,KAAK;AAEvF,QAAI,WACJ;AACI,WAAK,qBAAqB,KAAK,YAAY;IAC/C;AAEA,WAAO;EACX;EAEO,MACH,QACA,QAAuB,MAAM,KAC7B,YACA,WAAW,KAAK,UAChB,QAAQ,KAAK,OAEjB;AACI,QAAI,CAAC,MAAO;AAEZ,QAAI,QACJ;AACI,eAAS,KAAK,gBAAgB,MAAM;IACxC;AAEA,SAAK,QAAQ;MACR,UAA2B,KAAK;MACjC;MACA;MACA,KAAK;MACL;MACA;IAAA;EAER;EAEU,gBACV;AACI,SAAK,uBAAuB,uBAAO,OAAO,IAAI;EAClD;;;;;;;;;;;EAYO,KACH,eACA,QAAyB,MAAM,KAC/B,YACA,OACA,WAAW,GACX,QAAQ,GAEZ;AACI,UAAM,eAAe,KAAK,KAAK,eAAe,OAAO,YAAY,OAAO,UAAU,KAAK;AAEvF,SAAK,mBAAmB,KAAK;MACzB;MACA;MACA;MACA;IAAA,CACH;AAED,WAAO;EACX;;EAGO,MACP;AACI,SAAK,mBAAmB,IAAA;AAExB,UAAM,0BAA0B,KAAK,mBAAmB,KAAK,mBAAmB,SAAS,CAAC;AAE1F,SAAK;MACD,wBAAwB;MACxB;MACA;MACA,wBAAwB;MACxB,wBAAwB;MACxB,wBAAwB;IAAA;EAEhC;;;;;;;;EASO,gBAAgB,eACvB;AACI,QAAM,cAA0B,WAChC;AACI,sBAAiB,cAA0B;IAC/C;AAEA,WAAO,KAAK,iCAAiC,IAAI,aAAa,KAC3D,KAAK,kBAAkB,aAAa;EAC3C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyCO,cACH,4BACA,oBACA,WACA,MACA,YAEJ;AAGI,QAAI,UAAU,IAAI,GAClB;AACI,WAAK,SAAS,UAAU;AACxB,iBAAW,KAAK,UAAU;AAC1B,gBAAU,IAAI;IAClB;AAEA,QAAI,UAAU,IAAI,GAClB;AACI,WAAK,UAAU,UAAU;AACzB,iBAAW,KAAK,UAAU;AAC1B,gBAAU,IAAI;IAClB;AAEA,UAAM,EAAE,YAAY,YAAA,IAAgB;AAEpC,SAAK,QAAQ,KAAK,IAAI,KAAK,OAAO,aAAa,UAAU,CAAC;AAC1D,SAAK,SAAS,KAAK,IAAI,KAAK,QAAQ,cAAc,UAAU,CAAC;AAE7D,WAAO,KAAK,QAAQ;MAChB;MACA;MACA;MACA;MACA;IAAA;EAER;;;;;EAMO,qBACP;AACI,QAAI,CAAC,KAAK,aAAa,SACvB;AACI,WAAK,aAAa,UAAU;AAE5B,WAAK,QAAQ,gBAAgB,KAAK,cAAc,OAAO,MAAM,KAAK,UAAU,GAAG,KAAK,KAAK;IAC7F;EACJ;;EAGO,UACP;AACK,SAAK,YAAqB;AAE3B,SAAK,iCAAiC,QAAQ,CAAC,cAAc,QAC7D;AACI,UAAI,iBAAiB,KACrB;AACI,qBAAa,QAAA;MACjB;IACJ,CAAC;AAED,SAAK,iCAAiC,MAAA;AAEtC,SAAK,uBAAuB,uBAAO,OAAO,IAAI;EAClD;EAEQ,kBAAkB,eAC1B;AACI,QAAI,eAA6B;AAEjC,QAAI,aAAa,KAAK,aAAa,GACnC;AACI,sBAAgB,iBAAiB,aAAwB,EAAE;IAC/D;AAEA,QAAI,yBAAyB,cAC7B;AACI,qBAAe;IACnB,WACS,yBAAyB,eAClC;AACI,qBAAe,IAAI,aAAa;QAC5B,eAAe,CAAC,aAAa;MAAA,CAChC;AAED,UAAI,cAAc,kBAAkB,cACpC;AACI,qBAAa,SAAS;MAC1B;AAGA,oBAAc,KAAK,WAAW,MAC9B;AACI,qBAAa,QAAA;AAEb,aAAK,iCAAiC,OAAO,aAAa;AAE1D,cAAM,kBAAkB,KAAK,qBAAqB,aAAa,GAAG;AAElE,YAAI,iBACJ;AACI,eAAK,qBAAqB,aAAa,GAAG,IAAI;AAC9C,eAAK,QAAQ,uBAAuB,eAAe;QACvD;MACJ,CAAC;IACL;AAEA,SAAK,iCAAiC,IAAI,eAAe,YAAY;AAErE,WAAO;EACX;EAEO,mBAAmB,cAC1B;AACI,WAAO,KAAK,qBAAqB,aAAa,GAAG,MAC7C,KAAK,qBAAqB,aAAa,GAAG,IAAI,KAAK,QAAQ,oBAAoB,YAAY;EACnG;EAEO,aACP;AACI,SAAK,eAAe;AACpB,SAAK,gBAAgB;EACzB;AACJ;",
  "names": ["CLEAR", "_AbstractRenderer", "_BatcherPipe", "_BackgroundSystem", "_ExtractSystem", "tempBounds", "cleanHash", "_GCSystem", "uid", "_RenderableGCSystem", "_TextureGCSystem", "_RenderTarget", "source", "_ViewSystem", "source"]
}
