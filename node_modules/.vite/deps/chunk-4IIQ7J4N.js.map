{
  "version": 3,
  "sources": ["../../parse-svg-path/index.js", "../../pixi.js/src/scene/graphics/shared/const.ts", "../../pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts", "../../pixi.js/src/scene/graphics/shared/fill/FillGradient.ts", "../../pixi.js/src/scene/graphics/shared/fill/FillPattern.ts", "../../pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts", "../../pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts", "../../pixi.js/src/scene/graphics/shared/BatchableGraphics.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildPixelLine.ts", "../../pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts", "../../pixi.js/src/scene/graphics/shared/utils/generateTextureFillMatrix.ts", "../../pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts", "../../pixi.js/src/scene/graphics/shared/svg/parseSVGPath.ts", "../../pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts", "../../pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts", "../../pixi.js/src/scene/graphics/shared/path/roundShape.ts", "../../pixi.js/src/scene/graphics/shared/path/ShapePath.ts", "../../pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts", "../../pixi.js/src/scene/graphics/shared/svg/parseSVGFloatAttribute.ts", "../../pixi.js/src/scene/graphics/shared/svg/parseSVGDefinitions.ts", "../../pixi.js/src/scene/graphics/shared/svg/utils/extractSvgUrlId.ts", "../../pixi.js/src/scene/graphics/shared/svg/parseSVGStyle.ts", "../../pixi.js/src/scene/graphics/shared/svg/utils/fillOperations.ts", "../../pixi.js/src/scene/graphics/shared/svg/utils/pathOperations.ts", "../../pixi.js/src/scene/graphics/shared/svg/SVGParser.ts", "../../pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts", "../../pixi.js/src/scene/graphics/shared/GraphicsContext.ts"],
  "sourcesContent": ["\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n", "/**\n * The line cap styles for strokes.\n *\n * It can be:\n * - `butt`: The ends of the stroke are squared off at the endpoints.\n * - `round`: The ends of the stroke are rounded.\n * @category scene\n * @standard\n */\nexport type LineCap = 'butt' | 'round' | 'square';\n/**\n * The line join styles for strokes.\n *\n * It can be:\n * - `round`: The corners of the stroke are rounded.\n * - `bevel`: The corners of the stroke are squared off.\n * - `miter`: The corners of the stroke are extended to meet at a point.\n * @category scene\n * @standard\n */\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\n/** @internal */\nexport const closePointEps = 1e-4;\n/** @internal */\nexport const curveEps = 0.0001;\n", "/**\n * @param points\n * @internal\n */\nexport function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n", "import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { type WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { definedProps } from '../../../container/utils/definedProps';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { CanvasAndContext } from '../../../../rendering/renderers/shared/texture/CanvasPool';\nimport type { TextureSpace } from '../FillTypes';\n\n/**\n * Defines the type of gradient to create.\n *\n * It can be:\n * - 'linear': A linear gradient that transitions colors along a straight line.\n * - 'radial': A radial gradient that transitions colors in a circular pattern from an inner circle to an outer circle.\n * @category scene\n * @standard\n */\nexport type GradientType = 'linear' | 'radial';\n\n/**\n * Represents the style options for a linear gradient fill.\n * @category scene\n * @standard\n */\nexport interface BaseGradientOptions\n{\n    /** The type of gradient */\n    type?: GradientType;\n    /** Array of colors stops to use in the gradient */\n    colorStops?: { offset: number, color: ColorSource }[];\n    /** Whether coordinates are 'global' or 'local' */\n    textureSpace?: TextureSpace;\n    /**\n     * The size of the texture to use for the gradient - this is for advanced usage.\n     * The texture size does not need to match the size of the object being drawn.\n     * Due to GPU interpolation, gradient textures can be relatively small!\n     * Consider using a larger texture size if your gradient has a lot of very tight color steps\n     */\n    textureSize?: number;\n    /**\n     * The wrap mode of the gradient.\n     * This can be 'clamp-to-edge' or 'repeat'.\n     * @default 'clamp-to-edge'\n     */\n    wrapMode?: WRAP_MODE\n}\n\n/**\n * Options specific to linear gradients.\n * A linear gradient creates a smooth transition between colors along a straight line defined by start and end points.\n * @category scene\n * @standard\n */\nexport interface LinearGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'linear' for linear gradients. */\n    type?: 'linear';\n\n    /**\n     * The start point of the gradient.\n     * This point defines where the gradient begins.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    start?: PointData;\n\n    /**\n     * The end point of the gradient.\n     * This point defines where the gradient ends.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    end?: PointData;\n}\n\n/**\n * Options specific to radial gradients.\n * A radial gradient creates a smooth transition between colors that radiates outward in a circular pattern.\n * The gradient is defined by inner and outer circles, each with their own radius.\n * @category scene\n * @standard\n */\nexport interface RadialGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'radial' for radial gradients. */\n    type?: 'radial';\n    /** The center point of the inner circle where the gradient begins. In local coordinates by default (0-1). */\n    center?: PointData;\n    /** The radius of the inner circle where the gradient begins. */\n    innerRadius?: number;\n    /** The center point of the outer circle where the gradient ends. In local coordinates by default (0-1). */\n    outerCenter?: PointData;\n    /** The radius of the outer circle where the gradient ends. */\n    outerRadius?: number;\n    /**\n     * The y scale of the gradient, use this to make the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    scale?: number;\n    /**\n     * The rotation of the gradient in radians, useful for making the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    rotation?: number;\n}\n\n/**\n * Options for creating a gradient fill.\n * @category scene\n * @standard\n */\nexport type GradientOptions = LinearGradientOptions | RadialGradientOptions;\n\n/**\n * If no color stops are provided, we use a default gradient of white to black - this is to avoid a blank gradient if a dev\n * forgets to set them.\n */\nconst emptyColorStops: { offset: number, color: string }[] = [{ offset: 0, color: 'white' }, { offset: 1, color: 'black' }];\n\n/**\n * Class representing a gradient fill that can be used to fill shapes and text.\n * Supports both linear and radial gradients with multiple color stops.\n *\n * For linear gradients, color stops define colors and positions (0 to 1) along a line from start point (x0,y0)\n * to end point (x1,y1).\n *\n * For radial gradients, color stops define colors between two circles - an inner circle centered at (x0,y0) with radius r0,\n * and an outer circle centered at (x1,y1) with radius r1.\n * @example\n * ```ts\n * // Create a vertical linear gradient from red to blue\n * const linearGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },  // Start at top\n *     end: { x: 0, y: 1 },    // End at bottom\n *     colorStops: [\n *         { offset: 0, color: 'red' },   // Red at start\n *         { offset: 1, color: 'blue' }   // Blue at end\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a radial gradient from yellow center to green edge\n * const radialGradient = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.5, y: 0.5 },\n *     innerRadius: 0,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'yellow' }, // Center color\n *         { offset: 1, color: 'green' }   // Edge color\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a rainbow linear gradient in global coordinates\n * const globalGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 0 },\n *     colorStops: [\n *         { offset: 0, color: 0xff0000 },    // Red\n *         { offset: 0.33, color: 0x00ff00 }, // Green\n *         { offset: 0.66, color: 0x0000ff }, // Blue\n *         { offset: 1, color: 0xff00ff }     // Purple\n *     ],\n *     textureSpace: 'global'  // Use world coordinates\n * });\n *\n * // Create an offset radial gradient\n * const offsetRadial = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.3, y: 0.3 },\n *     innerRadius: 0.1,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'white' },\n *         { offset: 1, color: 'black' }\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n * ```\n *\n * Internally this creates a  texture of the gradient then applies a\n * transform to it to give it the correct size and angle.\n *\n * This means that it's important to destroy a gradient when it is no longer needed\n * to avoid memory leaks.\n *\n * If you want to animate a gradient then it's best to modify and update an existing one\n * rather than creating a whole new one each time. That or use a custom shader.\n * @category scene\n * @standard\n */\nexport class FillGradient implements CanvasGradient\n{\n    /** Default options for creating a gradient fill */\n    public static readonly defaultLinearOptions: LinearGradientOptions = {\n        start: { x: 0, y: 0 },\n        end: { x: 0, y: 1 },\n        colorStops: [],\n        textureSpace: 'local',\n        type: 'linear',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /** Default options for creating a radial gradient fill */\n    public static readonly defaultRadialOptions: RadialGradientOptions = {\n        center: { x: 0.5, y: 0.5 },\n        innerRadius: 0,\n        outerRadius: 0.5,\n        colorStops: [],\n        scale: 1,\n        textureSpace: 'local',\n        type: 'radial',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /**\n     * Unique identifier for this gradient instance\n     * @internal\n     */\n    public readonly uid: number = uid('fillGradient');\n    /**\n     * Internal tick counter to track changes in the gradient.\n     * This is used to invalidate the gradient when the texture changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** Type of gradient - currently only supports 'linear' */\n    public readonly type: GradientType = 'linear';\n\n    /** Internal texture used to render the gradient */\n    public texture: Texture;\n    /** Transform matrix for positioning the gradient */\n    public transform: Matrix;\n    /** Array of color stops defining the gradient */\n    public colorStops: Array<{ offset: number, color: string }> = [];\n\n    /** Whether gradient coordinates are in local or global space */\n    public textureSpace: TextureSpace;\n    private readonly _textureSize: number;\n\n    /** The start point of the linear gradient */\n    public start: PointData;\n    /** The end point of the linear gradient */\n    public end: PointData;\n    /** The wrap mode of the gradient texture */\n    private readonly _wrapMode: WRAP_MODE;\n\n    /** The center point of the inner circle of the radial gradient */\n    public center: PointData;\n    /** The center point of the outer circle of the radial gradient */\n    public outerCenter: PointData;\n    /** The radius of the inner circle of the radial gradient */\n    public innerRadius: number;\n    /** The radius of the outer circle of the radial gradient */\n    public outerRadius: number;\n    /** The scale of the radial gradient */\n    public scale: number;\n    /** The rotation of the radial gradient */\n    public rotation: number;\n\n    /**\n     * Creates a new gradient fill. The constructor behavior changes based on the gradient type.\n     * @param {GradientOptions} options - The options for the gradient\n     * @see {@link LinearGradientOptions}\n     * @see {@link RadialGradientOptions}\n     */\n    constructor(options: GradientOptions);\n    /**\n     * Deprecated: Use the options object instead.\n     * @deprecated since 8.5.2\n     * @ignore\n     */\n    constructor(\n        x0?: number,\n        y0?: number,\n        x1?: number,\n        y1?: number,\n        textureSpace?: TextureSpace,\n        textureSize?: number\n    );\n    constructor(...args: [GradientOptions] | [number?, number?, number?, number?, TextureSpace?, number?])\n    {\n        let options = ensureGradientOptions(args);\n\n        const defaults = options.type === 'radial' ? FillGradient.defaultRadialOptions : FillGradient.defaultLinearOptions;\n\n        options = { ...defaults, ...definedProps(options) };\n\n        this._textureSize = options.textureSize;\n        this._wrapMode = options.wrapMode;\n\n        if (options.type === 'radial')\n        {\n            this.center = options.center;\n            this.outerCenter = options.outerCenter ?? this.center;\n            this.innerRadius = options.innerRadius;\n            this.outerRadius = options.outerRadius;\n            this.scale = options.scale;\n            this.rotation = options.rotation;\n        }\n        else\n        {\n            this.start = options.start;\n            this.end = options.end;\n        }\n\n        this.textureSpace = options.textureSpace;\n\n        this.type = options.type;\n        options.colorStops.forEach((stop) =>\n        {\n            this.addColorStop(stop.offset, stop.color);\n        });\n    }\n\n    /**\n     * Adds a color stop to the gradient\n     * @param offset - Position of the stop (0-1)\n     * @param color - Color of the stop\n     * @returns This gradient instance for chaining\n     */\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n\n        return this;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildLinearGradient(): void\n    {\n        if (this.texture) return;\n\n        let { x: x0, y: y0 } = this.start;\n        let { x: x1, y: y1 } = this.end;\n\n        let dx = x1 - x0;\n        let dy = y1 - y0;\n\n        // Determine flip based on original dx/dy and swap coordinates if necessary\n        const flip = dx < 0 || dy < 0;\n\n        if (this._wrapMode === 'clamp-to-edge')\n        {\n            if (dx < 0)\n            {\n                const temp = x0;\n\n                x0 = x1;\n                x1 = temp;\n                dx *= -1;\n            }\n            if (dy < 0)\n            {\n                const temp = y0;\n\n                y0 = y1;\n                y1 = temp;\n                dy *= -1;\n            }\n        }\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n\n        const { canvas, context } = getCanvas(defaultSize, 1);\n\n        const gradient = !flip\n            ? context.createLinearGradient(0, 0, this._textureSize, 0)\n            : context.createLinearGradient(this._textureSize, 0, 0, 0);\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, defaultSize, 1);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n        const angle = Math.atan2(dy, dx);\n\n        // little offset to stop the uvs from flowing over the edge..\n        // this matrix is inverted when used in the graphics\n        // add a tiny off set to prevent uv bleeding..\n        const m = new Matrix();\n\n        m.scale((dist / defaultSize), 1);\n        m.rotate(angle);\n        m.translate(x0, y0);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n        this.transform = m;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildGradient(): void\n    {\n        if (!this.texture) this._tick++;\n        if (this.type === 'linear')\n        {\n            this.buildLinearGradient();\n        }\n        else\n        {\n            this.buildRadialGradient();\n        }\n    }\n\n    /**\n     * Builds the internal texture and transform for the radial gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildRadialGradient(): void\n    {\n        if (this.texture) return;\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n        const { canvas, context } = getCanvas(defaultSize, defaultSize);\n\n        const { x: x0, y: y0 } = this.center;\n        const { x: x1, y: y1 } = this.outerCenter;\n\n        const r0 = this.innerRadius;\n        const r1 = this.outerRadius;\n\n        const ox = x1 - r1;\n        const oy = y1 - r1;\n\n        const scale = defaultSize / (r1 * 2);\n\n        const cx = (x0 - ox) * scale;\n        const cy = (y0 - oy) * scale;\n\n        const gradient = context.createRadialGradient(\n            cx,\n            cy,\n            r0 * scale,\n            (x1 - ox) * scale,\n            (y1 - oy) * scale,\n            r1 * scale\n        );\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = colorStops[colorStops.length - 1].color;\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        context.fillStyle = gradient;\n\n        // First translate to center\n        context.translate(cx, cy);\n\n        // Then apply rotation\n        context.rotate(this.rotation);\n\n        // Then scale2\n        context.scale(1, this.scale);\n\n        // Finally translate back, taking scale into account\n        context.translate(-cx, -cy);\n\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        const m = new Matrix();\n\n        // this matrix is inverted when used in the graphics\n        m.scale(1 / scale, 1 / scale);\n        m.translate(ox, oy);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n\n        this.transform = m;\n    }\n\n    /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture?.destroy(true);\n        this.texture = null;\n        this.transform = null;\n        this.colorStops = [];\n        this.start = null;\n        this.end = null;\n        this.center = null;\n        this.outerCenter = null;\n    }\n\n    /**\n     * Returns a unique key for this gradient instance.\n     * This key is used for caching and texture management.\n     * @returns {string} Unique key for the gradient\n     */\n    public get styleKey(): string\n    {\n        return `fill-gradient-${this.uid}-${this._tick}`;\n    }\n}\n\nfunction addColorStops(gradient: CanvasGradient, colorStops: { offset: number, color: string }[]): void\n{\n    for (let i = 0; i < colorStops.length; i++)\n    {\n        const stop = colorStops[i];\n\n        gradient.addColorStop(stop.offset, stop.color);\n    }\n}\n\nfunction getCanvas(width: number, height: number): CanvasAndContext\n{\n    const canvas = DOMAdapter.get().createCanvas(width, height);\n    const context = canvas.getContext('2d');\n\n    return { canvas, context };\n}\n\n/**\n * Helper function to ensure consistent handling of gradient options.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureGradientOptions({\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 100 },\n *     textureSpace: 'local'\n * });\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureGradientOptions([0, 0, 100, 100, 'local']);\n * @param args - Arguments passed to gradient constructor\n * @returns Normalized gradient options object\n * @internal\n */\nfunction ensureGradientOptions(\n    args: any[],\n): GradientOptions\n{\n    let options = (args[0] ?? {}) as GradientOptions;\n\n    // @deprecated\n    if (typeof options === 'number' || args[1])\n    {\n        // #if _DEBUG\n        deprecation('8.5.2', `use options object instead`);\n        // #endif\n\n        options = {\n            type: 'linear',\n            start: { x: args[0], y: args[1] },\n            end: { x: args[2], y: args[3] },\n            textureSpace: args[4] as 'global' | 'local',\n            textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize\n        };\n    }\n\n    return options;\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\n/**\n * Defines the repetition modes for fill patterns.\n *\n * - `repeat`: The pattern repeats in both directions.\n * - `repeat-x`: The pattern repeats horizontally only.\n * - `repeat-y`: The pattern repeats vertically only.\n * - `no-repeat`: The pattern does not repeat.\n * @category scene\n * @standard\n */\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\n/**\n * A class that represents a fill pattern for use in Text and Graphics fills.\n * It allows for textures to be used as patterns, with optional repetition modes.\n * @category scene\n * @standard\n * @example\n * const txt = await Assets.load('https://pixijs.com/assets/bg_scene_rotate.jpg');\n * const pat = new FillPattern(txt, 'repeat');\n *\n * const textPattern = new Text({\n *     text: 'PixiJS',\n *     style: {\n *         fontSize: 36,\n *         fill: 0xffffff,\n *         stroke: { fill: pat, width: 10 },\n *     },\n * });\n *\n * textPattern.y = (textGradient.height);\n */\nexport class FillPattern implements CanvasPattern\n{\n    /**\n     * unique id for this fill pattern\n     * @internal\n     */\n    public readonly uid: number = uid('fillPattern');\n    /**\n     * Internal tick counter to track changes in the pattern.\n     * This is used to invalidate the pattern when the texture or transform changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** @internal */\n    public _texture: Texture;\n    /** The transform matrix applied to the pattern */\n    public transform = new Matrix();\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    /**\n     * Sets the transform for the pattern\n     * @param transform - The transform matrix to apply to the pattern.\n     * If not provided, the pattern will use the default transform.\n     */\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._tick++;\n    }\n\n    /** Internal texture used to render the gradient */\n    public get texture()\n    {\n        return this._texture;\n    }\n    public set texture(value: Texture)\n    {\n        if (this._texture === value) return;\n\n        this._texture = value;\n        this._tick++;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `fill-pattern-${this.uid}-${this._tick}`;\n    }\n\n    /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture.destroy(true);\n        this.texture = null;\n    }\n}\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @internal\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n/**\n * @param uvs\n * @param uvsOffset\n * @param uvsStride\n * @param size\n * @internal\n */\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @category rendering\n * @internal\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset ||= 0;\n    stride ||= 2;\n    size ||= (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\nconst identityMatrix = new Matrix();\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements DefaultBatchableMeshElement\n{\n    public readonly packAsQuad = false;\n    public batcherName = 'default';\n\n    public texture: Texture;\n\n    public topology: Topology = 'triangle-list';\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public attributeOffset: number;\n    public attributeSize: number;\n    public baseColor: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get uvs()\n    {\n        return this.geometryData.uvs;\n    }\n\n    get positions()\n    {\n        return this.geometryData.vertices;\n    }\n\n    get indices()\n    {\n        return this.geometryData.indices;\n    }\n\n    get blendMode()\n    {\n        if (this.renderable && this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    get color()\n    {\n        const rgb = this.baseColor;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n        const renderable = this.renderable;\n\n        if (renderable)\n        {\n            return multiplyHexColors(bgr, renderable.groupColor)\n            + ((this.alpha * renderable.groupAlpha * 255) << 24);\n        }\n\n        return bgr + ((this.alpha * 255) << 24);\n    }\n\n    get transform()\n    {\n        return this.renderable?.groupTransform || identityMatrix;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n\n        gpuBuffer.topology = this.topology;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n        this.renderable = null;\n        this.topology = 'triangle-list';\n    }\n\n    public destroy()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.geometryData = null;\n        this._batcher = null;\n        this._batch = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/** @internal */\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @internal\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[]): boolean\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            rx = ry = circle.radius;\n            if (rx <= 0)\n            {\n                return false;\n            }\n            x = circle.x;\n            y = circle.y;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            if (rx <= 0 || ry <= 0)\n            { // skip zero ellipse\n                return false;\n            }\n            x = ellipse.x;\n            y = ellipse.y;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (dx < 0 || dy < 0)\n        {\n            return false;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return false;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return true;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return true;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\n/** @internal */\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\n/** @internal */\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n", "import { closePointEps } from '../const';\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildPixelLine(\n    points: number[],\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n\n    const fx = points[0];\n    const fy = points[1];\n\n    const lx = points[points.length - 2];\n\n    const ly = points[points.length - 1];\n\n    const closePath = closed || (Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps);\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    const indexStart = verts.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        verts.push(points[(i * 2)]);\n        verts.push(points[(i * 2) + 1]);\n    }\n\n    for (let i = 0; i < length - 1; i++)\n    {\n        indices.push(indexStart + i, indexStart + i + 1);\n    }\n\n    if (closePath)\n    {\n        indices.push(indexStart + length - 1, indexStart);\n    }\n}\n\n", "import { earcut } from '../../../../utils/utils';\n\n/**\n * @param points\n * @param holes\n * @param vertices\n * @param verticesStride\n * @param verticesOffset\n * @param indices\n * @param indicesOffset\n * @internal\n */\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): boolean\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): boolean\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width > 0 && height > 0))\n        {\n            return false;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): boolean\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { FillGradient } from '../fill/FillGradient';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n * @internal\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        if ((style as StrokeStyle).width)\n        {\n            bounds.pad((style as StrokeStyle).width);\n        }\n\n        const { x: tx, y: ty } = bounds;\n        const sx = 1 / bounds.width;\n        const sy = 1 / bounds.height;\n\n        const mTx = -tx * sx;\n        const mTy = -ty * sy;\n\n        const a1 = textureMatrix.a;\n        const b1 = textureMatrix.b;\n        const c1 = textureMatrix.c;\n        const d1 = textureMatrix.d;\n\n        textureMatrix.a *= sx;\n        textureMatrix.b *= sx;\n        textureMatrix.c *= sy;\n        textureMatrix.d *= sy;\n\n        textureMatrix.tx = (mTx * a1) + (mTy * c1) + textureMatrix.tx;\n        textureMatrix.ty = (mTx * b1) + (mTy * d1) + textureMatrix.ty;\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / (style.texture.source.width), 1 / (style.texture.source.height));\n    }\n\n    const sourceStyle = style.texture.source.style;\n\n    // we don't want to set the address mode if the fill is a gradient as this handles its own address mode\n    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === 'clamp-to-edge')\n    {\n        sourceStyle.addressMode = 'repeat';\n        sourceStyle.update();\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n", "import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { generateTextureMatrix as generateTextureFillMatrix } from './generateTextureFillMatrix';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { ShapePath, ShapePrimitiveWithHoles } from '../path/ShapePath';\n\n/**\n * A record of shape builders, keyed by shape type.\n * @category scene\n * @advanced\n */\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\n\n/**\n * @param context\n * @param gpuContext\n * @internal\n */\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n            }\n\n            if (hole)\n            {\n                // add the holes to the last shape primitive\n                shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n            }\n\n            addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    if (!build.build(rect, points))\n    {\n        return;\n    }\n\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const texture = data.image;\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) =>\n    {\n        const points: number[] = [];\n        const build = shapeBuilders[shape.type];\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        if (!build.build(shape, points))\n        {\n            return;\n        }\n\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        let topology: Topology = 'triangle-list';\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (holes)\n            {\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(holes);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = generateTextureFillMatrix(tempTextureMatrix, style, shape, matrix);\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(holePrimitives: ShapePrimitiveWithHoles[])\n{\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        if (holeBuilder.build(holePrimitive, holePoints))\n        {\n            holeArrays.push(holePoints);\n        }\n    }\n\n    return holeArrays;\n}\n", "import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n/**\n * Parses an SVG path data string and builds a GraphicsPath object from the commands.\n * This function handles all standard SVG path commands including moves, lines, curves and arcs.\n * It maintains state for the current position and subpaths to properly handle relative commands\n * and path closures.\n *\n * Supported SVG commands:\n * - M/m: Move to absolute/relative\n * - L/l: Line to absolute/relative\n * - H/h: Horizontal line absolute/relative\n * - V/v: Vertical line absolute/relative\n * - C/c: Cubic bezier curve absolute/relative\n * - S/s: Smooth cubic bezier curve absolute/relative\n * - Q/q: Quadratic bezier curve absolute/relative\n * - T/t: Smooth quadratic bezier curve absolute/relative\n * - A/a: Arc absolute/relative\n * - Z/z: Close path\n * @param svgPath - The SVG path data string to parse (e.g. \"M0,0 L100,100\")\n * @param path - The GraphicsPath object to build the path into\n * @returns The input path object with the SVG commands applied\n * @internal\n */\nexport function parseSVGPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    // Parse the SVG path string into an array of commands\n    const commands = parse(svgPath);\n\n    // Track subpaths for proper path closure handling\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    // Track current position for relative commands\n    let lastX = 0;\n    let lastY = 0;\n\n    // Process each command in sequence\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0]; // The command letter\n        const data = command; // The command parameters, 1-based indexed\n\n        switch (type)\n        {\n            case 'M': // Move To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm': // Move To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H': // Horizontal Line To (absolute)\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h': // Horizontal Line To (relative)\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V': // Vertical Line To (absolute)\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v': // Vertical Line To (relative)\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L': // Line To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l': // Line To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C': // Cubic Bezier Curve (absolute)\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2], // First control point\n                    data[3], data[4], // Second control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'c': // Cubic Bezier Curve (relative)\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2], // First control point\n                    lastX + data[3], lastY + data[4], // Second control point\n                    lastX + data[5], lastY + data[6] // End point\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S': // Smooth Cubic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 's': // Smooth Cubic Bezier Curve (relative)\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4], // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q': // Quadratic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'q': // Quadratic Bezier Curve (relative)\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4] // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T': // Smooth Quadratic Bezier Curve (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 't': // Smooth Quadratic Bezier Curve (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 'A': // Arc (absolute)\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'a': // Arc (relative)\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'Z': // Close Path\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    // Return to the start of the current subpath\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        // Track subpath starts for path closure\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { type BatcherOptions } from '../../../rendering/batcher/shared/Batcher';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsContext implements GPUData\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n\n    public reset()\n    {\n        if (this.batches)\n        {\n            this.batches.forEach((batch) =>\n            {\n                BigPool.return(batch);\n            });\n        }\n        if (this.graphicsData)\n        {\n            BigPool.return(this.graphicsData);\n        }\n\n        this.isBatchable = false;\n        this.context = null;\n\n        this.batches.length = 0;\n        this.geometryData.indices.length = 0;\n        this.geometryData.vertices.length = 0;\n        this.geometryData.uvs.length = 0;\n\n        this.graphicsData = null;\n    }\n\n    public destroy()\n    {\n        this.reset();\n        this.batches = null;\n        this.geometryData = null;\n    }\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: DefaultBatcher;\n    public instructions = new InstructionSet();\n\n    public init(options: BatcherOptions)\n    {\n        const maxTextures = options.maxTextures;\n\n        this.batcher ? this.batcher._updateMaxTextures(maxTextures) : this.batcher = new DefaultBatcher({ maxTextures });\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // #if _DEBUG\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n        // #endif\n\n        return this.batcher.geometry;\n    }\n\n    public destroy()\n    {\n        this.batcher.destroy();\n        this.instructions.destroy();\n\n        this.batcher = null;\n        this.instructions = null;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @category rendering\n * @advanced\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @category rendering\n * @advanced\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    private readonly _renderer: Renderer;\n    private readonly _managedContexts: GCManagedHash<GraphicsContext>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedContexts = new GCManagedHash({ renderer, type: 'resource', name: 'graphicsContext' });\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    /**\n     * Returns the render data for a given GraphicsContext.\n     * @param context - The GraphicsContext to get the render data for.\n     * @internal\n     */\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return context._gpuData[this._renderer.uid].graphicsData || this._initContextRenderData(context);\n    }\n\n    /**\n     * Updates the GPU context for a given GraphicsContext.\n     * If the context is dirty, it will rebuild the batches and geometry data.\n     * @param context - The GraphicsContext to update.\n     * @returns The updated GpuGraphicsContext.\n     * @internal\n     */\n    public updateGpuContext(context: GraphicsContext)\n    {\n        const hasContext = !!context._gpuData[this._renderer.uid];\n        const gpuContext: GpuGraphicsContext = context._gpuData[this._renderer.uid] || this._initContext(context);\n\n        if (context.dirty || !hasContext)\n        {\n            if (hasContext)\n            {\n                gpuContext.reset();\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n            else\n            {\n                gpuContext.isBatchable = true;\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    /**\n     * Returns the GpuGraphicsContext for a given GraphicsContext.\n     * If it does not exist, it will initialize a new one.\n     * @param context - The GraphicsContext to get the GpuGraphicsContext for.\n     * @returns The GpuGraphicsContext for the given GraphicsContext.\n     * @internal\n     */\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return context._gpuData[this._renderer.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData, {\n            maxTextures: this._renderer.limits.maxBatchableTextures,\n        });\n\n        const gpuContext = context._gpuData[this._renderer.uid];\n        const { batches, geometryData } = gpuContext;\n\n        gpuContext.graphicsData = graphicsData;\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                batch.textures.textures,\n                batch.textures.count,\n                this._renderer.limits.maxBatchableTextures\n            );\n        }\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        context._gpuData[this._renderer.uid] = gpuContext;\n\n        this._managedContexts.add(context);\n\n        return gpuContext;\n    }\n\n    public destroy()\n    {\n        this._managedContexts.destroy();\n        (this._renderer as null) = null;\n    }\n}\n", "// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param cp2x\n * @param cp2y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n", "// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n", "/**\n * @param points\n * @param x\n * @param y\n * @param radius\n * @param start\n * @param end\n * @param clockwise\n * @param steps\n * @internal\n */\nexport function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps ||= Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n", "import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n * @internal\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n", "import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\n/**\n * @param points\n * @param px\n * @param py\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param xAxisRotation\n * @param largeArcFlag\n * @param sweepFlag\n * @internal\n */\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n", "import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\n/**\n * Data structure for points with optional radius.\n * @category scene\n * @standard\n */\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n", "// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * A type representing a shape primitive with optional transformation and holes.\n * @category scene\n * @advanced\n */\nexport type ShapePrimitiveWithHoles = {\n    shape: ShapePrimitive,\n    transform?: Matrix,\n    holes?: ShapePrimitiveWithHoles[]\n};\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @category scene\n * @advanced\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: ShapePrimitiveWithHoles[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n    public readonly signed: boolean;\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n        this.signed = graphicsPath2D.checkForHoles;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        // Only clone if we need to transform\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        const shapePrimitives = this.shapePrimitives;\n        const start = shapePrimitives.length;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        // This section processes holes in polygons by checking if any polygon is contained within another.\n        // If a polygon is found to be inside another polygon (mainShape), it's treated as a hole.\n        // The hole polygon is removed from the main shapePrimitives array and added to the holes array\n        // of the containing polygon. This allows for proper rendering of shapes with holes.\n        if (path.checkForHoles && shapePrimitives.length - start > 1)\n        {\n            let mainShape = null;\n\n            // Process in place instead of creating a removal array\n            for (let i = start; i < shapePrimitives.length; i++)\n            {\n                const shapePrimitive = shapePrimitives[i];\n\n                if (shapePrimitive.shape.type === 'polygon')\n                {\n                    const polygon = shapePrimitive.shape as Polygon;\n                    const mainPolygon = mainShape?.shape as Polygon;\n\n                    if (mainPolygon && mainPolygon.containsPolygon(polygon))\n                    {\n                        // Initialize holes array only when needed\n                        mainShape.holes ||= [];\n                        mainShape.holes.push(shapePrimitive);\n\n                        // Remove the hole by moving elements left\n                        shapePrimitives.copyWithin(i, i + 1);\n                        shapePrimitives.length--;\n                        i--;\n                    }\n                    else\n                    {\n                        mainShape = shapePrimitive;\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { parseSVGPath } from '../svg/parseSVGPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\n/**\n * Represents a single drawing instruction in a `GraphicsPath`.\n * Each instruction consists of an action type and associated data.\n * @category scene\n * @advanced\n */\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n * @category scene\n * @advanced\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Controls whether shapes in this path should be checked for holes using the non-zero fill rule.\n     * When true, any closed shape that is fully contained within another shape will become\n     * a hole in that shape during filling operations.\n     *\n     * This follows SVG's non-zero fill rule where:\n     * 1. Shapes are analyzed to find containment relationships\n     * 2. If Shape B is fully contained within Shape A, Shape B becomes a hole in Shape A\n     * 3. Multiple nested holes are supported\n     *\n     * Mainly used internally by the SVG parser to correctly handle holes in complex paths.\n     * When false, all shapes are filled independently without checking for holes.\n     */\n    public checkForHoles: boolean;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     * @param signed\n     */\n    constructor(instructions?: string | PathInstruction[], signed = false)\n    {\n        this.checkForHoles = signed;\n\n        if (typeof instructions === 'string')\n        {\n            parseSVGPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param matrix - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius ||= radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        newGraphicsPath2D.checkForHoles = this.checkForHoles;\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n", "/**\n * Parses a float value from an SVG element's attribute.\n * This is commonly used for parsing numeric attributes like coordinates, dimensions,\n * and other measurements from SVG elements.\n * @param svg - The SVG element to get the attribute from\n * @param id - The name of the attribute to parse (e.g. 'x', 'y', 'width', etc)\n * @param defaultValue - The value to return if the attribute doesn't exist or can't be parsed\n * @returns The parsed float value, or the default value if parsing fails\n * @example\n * // For SVG: <rect x=\"10.5\" width=\"20\"/>\n * parseSVGFloatAttribute(rectElement, 'x', 0) // Returns 10.5\n * parseSVGFloatAttribute(rectElement, 'y', 0) // Returns 0 since y is not specified\n * @internal\n */\nexport function parseSVGFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n", "import { Color } from '../../../../color/Color';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../fill/FillGradient';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\n\nimport type { Session } from './SVGParser';\n\n/**\n * Parses SVG gradient definitions and stores them in the session for later use.\n * Currently supports linear gradients and has placeholder support for radial gradients.\n * @param svg - The root SVG element to parse definitions from\n * @param session - The parsing session to store definitions in\n * @internal\n */\nexport function parseSVGDefinitions(svg: SVGElement, session: Session): void\n{\n    // Find all <defs> elements in the SVG\n    const definitions = svg.querySelectorAll('defs');\n\n    // Process each <defs> element\n    for (let i = 0; i < definitions.length; i++)\n    {\n        const definition = definitions[i];\n\n        // Process each child element in the <defs>\n        for (let j = 0; j < definition.children.length; j++)\n        {\n            const child = definition.children[j];\n\n            // Handle different types of gradient definitions\n            switch (child.nodeName.toLowerCase())\n            {\n                case 'lineargradient':\n                    // Store the parsed linear gradient in the session defs using the gradient's ID\n                    session.defs[child.id] = parseLinearGradient(child as SVGElement);\n                    break;\n                case 'radialgradient':\n                    session.defs[child.id] = parseRadialGradient(child as SVGElement);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n\n/**\n * Parses an SVG linear gradient element into a FillGradient.\n * @param child - The SVG linear gradient element to parse\n * @returns A FillGradient configured based on the SVG element\n */\nfunction parseLinearGradient(child: SVGElement): FillGradient\n{\n    // Parse the gradient vector coordinates (defaults: horizontal line from 0 to 1)\n    const x0 = parseSVGFloatAttribute(child, 'x1', 0);\n    const y0 = parseSVGFloatAttribute(child, 'y1', 0);\n    const x1 = parseSVGFloatAttribute(child, 'x2', 1);\n    const y1 = parseSVGFloatAttribute(child, 'y2', 0);\n\n    // Get the gradient coordinate system\n    const gradientUnit = child.getAttribute('gradientUnits') || 'objectBoundingBox';\n\n    // Create gradient with coordinates and space mapping\n    const gradient = new FillGradient(\n        x0,\n        y0,\n        x1,\n        y1,\n        gradientUnit === 'objectBoundingBox' ? 'local' : 'global'\n    );\n\n    // Process each gradient stop\n    for (let k = 0; k < child.children.length; k++)\n    {\n        const stop = child.children[k] as SVGElement;\n\n        // Get stop position (0-1) and color\n        const offset = parseSVGFloatAttribute(stop, 'offset', 0);\n        const color = Color.shared.setValue(stop.getAttribute('stop-color')).toNumber();\n\n        gradient.addColorStop(offset, color);\n    }\n\n    return gradient;\n}\n\n/**\n * Placeholder function for parsing SVG radial gradients.\n * Currently returns a simple horizontal linear gradient and logs a warning.\n * @param _child - The SVG radial gradient element (currently unused)\n * @returns A default linear gradient\n */\nfunction parseRadialGradient(_child: SVGElement): FillGradient\n{\n    // #if _DEBUG\n    warn('[SVG Parser] Radial gradients are not yet supported');\n    // #endif\n\n    return new FillGradient(0, 0, 1, 0);\n}\n", "/**\n * Extracts the ID from an SVG url() reference.\n *\n * This function handles all valid SVG url() formats including:\n * - url(#id)\n * - url('#id')\n * - url(\"#id\")\n * - url( #id )\n * - url( '#id' )\n * - url( \"#id\" )\n *\n * The regex pattern matches:\n * - url followed by optional whitespace\n * - opening parenthesis followed by optional whitespace\n * - optional single or double quotes with optional whitespace\n * - # followed by the ID (any chars except quotes, whitespace, or closing paren)\n * - optional single or double quotes with optional whitespace\n * - closing parenthesis\n * @param url - The SVG url() string to parse\n * @returns The extracted ID string, or empty string if no valid ID found\n * @internal\n */\nexport function extractSvgUrlId(url: string): string\n{\n    // Handle all valid SVG url() formats\n    const match = url.match(/url\\s*\\(\\s*['\"]?\\s*#([^'\"\\s)]+)\\s*['\"]?\\s*\\)/i);\n\n    return match ? match[1] : '';\n}\n", "import { Color } from '../../../../color/Color';\nimport { extractSvgUrlId } from './utils/extractSvgUrlId';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type { Session } from './SVGParser';\n\n/**\n * A map of SVG style attributes and their default values.\n * Each attribute has a type and default value used for SVG parsing.\n * - 'paint' type can be a color or gradient\n * - 'number' type is a numeric value\n * - 'string' type is a text value\n * @category scene\n * @advanced\n */\nexport const styleAttributes = {\n    // Fill properties\n    fill: { type: 'paint', default: 0 }, // Fill color/gradient\n    'fill-opacity': { type: 'number', default: 1 }, // Fill transparency\n\n    // Stroke properties\n    stroke: { type: 'paint', default: 0 }, // Stroke color/gradient\n    'stroke-width': { type: 'number', default: 1 }, // Width of stroke\n    'stroke-opacity': { type: 'number', default: 1 }, // Stroke transparency\n    'stroke-linecap': { type: 'string', default: 'butt' }, // End cap style: butt, round, square\n    'stroke-linejoin': { type: 'string', default: 'miter' }, // Join style: miter, round, bevel\n    'stroke-miterlimit': { type: 'number', default: 10 }, // Limit on miter join sharpness\n    'stroke-dasharray': { type: 'string', default: 'none' }, // Dash pattern\n    'stroke-dashoffset': { type: 'number', default: 0 }, // Offset for dash pattern\n\n    // Global properties\n    opacity: { type: 'number', default: 1 }, // Overall opacity\n};\n\n/**\n * Represents the result of parsing SVG style attributes\n * @internal\n */\nexport type StyleResult = {\n    /** The stroke style properties */\n    strokeStyle: StrokeStyle;\n    /** The fill style properties */\n    fillStyle: FillStyle;\n    /** Whether fill should be applied */\n    useFill: boolean;\n    /** Whether stroke should be applied */\n    useStroke: boolean;\n};\n\n/**\n * Parses SVG style attributes and inline styles to determine fill and stroke properties.\n * Handles both direct attributes and CSS-style declarations in the style attribute.\n * @param svg - The SVG element to parse styles from\n * @param session - The current SVG parsing session containing definitions\n * @returns An object containing the parsed fill and stroke styles\n * @internal\n */\nexport function parseSVGStyle(svg: SVGElement, session: Session): StyleResult\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    const result: StyleResult = {\n        strokeStyle,\n        fillStyle,\n        useFill: false,\n        useStroke: false,\n    };\n\n    // First parse direct style attributes\n    for (const key in styleAttributes)\n    {\n        const attribute = svg.getAttribute(key);\n\n        if (attribute)\n        {\n            parseAttribute(session, result, key, attribute.trim());\n        }\n    }\n\n    // Then parse inline styles which override direct attributes\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i].trim();\n\n            const [key, value] = stylePart.split(':');\n\n            if (styleAttributes[key as keyof typeof styleAttributes])\n            {\n                parseAttribute(session, result, key, value.trim());\n            }\n        }\n    }\n\n    return {\n        strokeStyle: result.useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: result.useFill ? (fillStyle as ConvertedFillStyle) : null,\n        useFill: result.useFill,\n        useStroke: result.useStroke,\n    };\n}\n\n/**\n * Parses a single SVG style attribute and updates the style result accordingly.\n * Handles color values, gradients, opacities and other style properties.\n * @param session - The current SVG parsing session containing definitions\n * @param result - The style result object to update\n * @param id - The attribute name/id to parse\n * @param value - The attribute value to parse\n */\nfunction parseAttribute(\n    session: Session,\n    result: StyleResult,\n    id: string,\n    value: string\n): void\n{\n    switch (id)\n    {\n        case 'stroke':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.strokeStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.strokeStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useStroke = true;\n            }\n\n            break;\n        case 'stroke-width':\n            result.strokeStyle.width = Number(value);\n            break;\n        case 'fill':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.fillStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.fillStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useFill = true;\n            }\n            break;\n        case 'fill-opacity':\n            result.fillStyle.alpha = Number(value);\n            break;\n        case 'stroke-opacity':\n            result.strokeStyle.alpha = Number(value);\n            break;\n        case 'opacity':\n            // Global opacity affects both fill and stroke\n            result.fillStyle.alpha = Number(value);\n            result.strokeStyle.alpha = Number(value);\n            break;\n    }\n}\n", "import type {\n    FillInstruction,\n    GraphicsContext,\n} from '../../GraphicsContext';\n\n/**\n * Determines if subpaths represent nested shapes or multiple holes pattern.\n * @param subpathsWithArea - Array of subpaths with their calculated areas\n * @returns True if nested pattern, false if multiple holes pattern\n * @internal\n */\nexport function checkForNestedPattern(subpathsWithArea: Array<{path: string, area: number}>): boolean\n{\n    if (subpathsWithArea.length <= 2)\n    {\n        return true;\n    }\n\n    const areas = subpathsWithArea.map((s) => s.area).sort((a, b) => b - a);\n\n    const [largestArea, secondArea] = areas;\n    const smallestArea = areas[areas.length - 1];\n\n    const largestToSecondRatio = largestArea / secondArea;\n    const secondToSmallestRatio = secondArea / smallestArea;\n\n    // If the largest shape is significantly bigger than the second (3x+)\n    // AND the smaller shapes are similar in size (2x or less difference),\n    // it suggests multiple holes pattern rather than nested shapes\n    if (largestToSecondRatio > 3 && secondToSmallestRatio < 2)\n    {\n        return false; // Multiple holes\n    }\n\n    return true; // Default to nested\n}\n\n/**\n * Gets fill instruction data from a graphics context.\n * @param context - The graphics context\n * @param index - Index of the fill instruction (default: 0)\n * @returns The fill instruction data\n * @throws Error if instruction at index is not a fill instruction\n * @internal\n */\nexport function getFillInstructionData(context: GraphicsContext, index: number = 0)\n{\n    const instruction = context.instructions[index];\n\n    if (!instruction || instruction.action !== 'fill')\n    {\n        throw new Error(`Expected fill instruction at index ${index}, got ${instruction?.action || 'undefined'}`);\n    }\n\n    return (instruction as FillInstruction).data;\n}\n", "import { GraphicsPath } from '../../path/GraphicsPath';\n\n/**\n * Extracts individual subpaths from SVG path data by splitting on Move commands.\n * @param pathData - The SVG path data string\n * @returns Array of subpath strings\n * @internal\n */\nexport function extractSubpaths(pathData: string): string[]\n{\n    // Split on Move commands (M or m) to get individual subpaths\n    const parts = pathData.split(/(?=[Mm])/);\n    const subpaths = parts.filter((part) => part.trim().length > 0);\n\n    return subpaths;\n}\n\n/**\n * Calculates the area of a path using bounding box estimation.\n * @param pathData - The SVG path data string\n * @returns The estimated area of the path\n * @internal\n */\nexport function calculatePathArea(pathData: string): number\n{\n    const coords = pathData.match(/[-+]?[0-9]*\\.?[0-9]+/g);\n\n    if (!coords || coords.length < 4) return 0;\n\n    const numbers = coords.map(Number);\n    const xs = [];\n    const ys = [];\n\n    for (let i = 0; i < numbers.length; i += 2)\n    {\n        if (i + 1 < numbers.length)\n        {\n            xs.push(numbers[i]);\n            ys.push(numbers[i + 1]);\n        }\n    }\n\n    if (xs.length === 0 || ys.length === 0) return 0;\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    const area = (maxX - minX) * (maxY - minY);\n\n    return area;\n}\n\n/**\n * Parses SVG path data and appends instructions to a GraphicsPath.\n * @param pathData - The SVG path data string\n * @param graphicsPath - The GraphicsPath to append instructions to\n * @internal\n */\nexport function appendSVGPath(pathData: string, graphicsPath: GraphicsPath): void\n{\n    const tempPath = new GraphicsPath(pathData, false);\n\n    for (const instruction of tempPath.instructions)\n    {\n        graphicsPath.instructions.push(instruction);\n    }\n}\n", "import { warn } from '../../../../utils/logging/warn';\nimport { GraphicsPath } from '../path/GraphicsPath';\nimport { parseSVGDefinitions } from './parseSVGDefinitions';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\nimport { parseSVGStyle } from './parseSVGStyle';\nimport { checkForNestedPattern } from './utils/fillOperations';\nimport { appendSVGPath, calculatePathArea, extractSubpaths } from './utils/pathOperations';\n\nimport type { FillGradient } from '../fill/FillGradient';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\n/**\n * Represents a session for SVG parsing. Contains the current state and resources needed during parsing.\n * @internal\n */\nexport interface Session\n{\n    /** The graphics context to render to */\n    context: GraphicsContext;\n    /** The current path being constructed */\n    path: GraphicsPath;\n    /** Map of definitions by id */\n    defs: Record<string, FillGradient>;\n}\n\n/**\n * Parses an SVG element or string and renders it to a graphics context.\n * Handles both SVG strings and SVG DOM elements as input.\n * @param svg - The SVG content to parse, either as a string or element\n * @param graphicsContext - Optional graphics context to render to\n * @returns The graphics context with the SVG rendered into it\n * @internal\n */\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    // Convert string input to SVG element\n    if (typeof svg === 'string')\n    {\n        // eslint-disable-next-line no-restricted-globals\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    // Initialize parsing session\n    const session = {\n        context: graphicsContext,\n        defs: {},\n        path: new GraphicsPath(),\n    };\n\n    // Parse definitions (gradients, etc) first\n    parseSVGDefinitions(svg, session);\n\n    // Process all child elements except defs\n    const children = svg.children;\n\n    const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i] as SVGElement;\n\n        if (child.nodeName.toLowerCase() === 'defs') continue;\n        renderChildren(child, session, fillStyle, strokeStyle);\n    }\n\n    return graphicsContext;\n}\n\n/**\n * Recursively renders SVG elements and their children.\n * Handles styling inheritance and different SVG shape types.\n * @param svg - The SVG element to render\n * @param session - The current parsing session\n * @param fillStyle - The inherited fill style\n * @param strokeStyle - The inherited stroke style\n */\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    // Parse element's style and merge with inherited styles\n    const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    const noStyle = !fillStyle && !strokeStyle;\n\n    // Default to black fill if no styles specified\n    if (noStyle)\n    {\n        fillStyle = { color: 0 };\n    }\n\n    // Variables for shape attributes\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    // Handle different SVG element types\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n        {\n            d = svg.getAttribute('d') as string;\n\n            const fillRule = svg.getAttribute('fill-rule') as string;\n\n            const subpaths = extractSubpaths(d);\n            const hasExplicitEvenodd = fillRule === 'evenodd';\n            const hasMultipleSubpaths = subpaths.length > 1;\n\n            const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;\n\n            if (shouldProcessHoles)\n            {\n                const subpathsWithArea = subpaths.map((subpath) => ({\n                    path: subpath,\n                    area: calculatePathArea(subpath)\n                }));\n\n                subpathsWithArea.sort((a, b) => b.area - a.area);\n\n                // For complex cases, prefer multiple holes approach\n                const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);\n\n                if (useMultipleHolesApproach)\n                {\n                    // Multiple holes approach: first (largest) is fill, rest are holes\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isMainShape = i === 0;\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isMainShape)\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                        else\n                        {\n                            session.context.cut();\n                        }\n                    }\n                }\n                else\n                {\n                    // Nested holes approach: alternate between fill and cut\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isHole = i % 2 === 1; // Odd indices are holes\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isHole)\n                        {\n                            session.context.cut();\n                        }\n                        else\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                const useEvenoddForGraphicsPath = fillRule ? (fillRule === 'evenodd') : true;\n\n                graphicsPath = new GraphicsPath(d, useEvenoddForGraphicsPath);\n                session.context.path(graphicsPath);\n                if (fillStyle) session.context.fill(fillStyle);\n                if (strokeStyle) session.context.stroke(strokeStyle);\n            }\n            break;\n        }\n\n        case 'circle':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            r = parseSVGFloatAttribute(svg, 'r', 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'rect':\n            x = parseSVGFloatAttribute(svg, 'x', 0);\n            y = parseSVGFloatAttribute(svg, 'y', 0);\n            width = parseSVGFloatAttribute(svg, 'width', 0);\n            height = parseSVGFloatAttribute(svg, 'height', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'ellipse':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'line':\n            x1 = parseSVGFloatAttribute(svg, 'x1', 0);\n            y1 = parseSVGFloatAttribute(svg, 'y1', 0);\n            x2 = parseSVGFloatAttribute(svg, 'x2', 0);\n            y2 = parseSVGFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/-?\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/-?\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        // Group elements - just process children\n        case 'g':\n        case 'svg':\n            break;\n\n        default: {\n            // Log unsupported elements\n            warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    if (noStyle)\n    {\n        fillStyle = null;\n    }\n\n    // Recursively process child elements\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\nfunction isTexture(value: unknown): value is Texture\n{\n    return value instanceof Texture;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a Texture\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new Texture(0xff0000))\n */\nfunction handleTexture(fill: FillStyle, value: Texture, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    fill.texture = value;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    fill.textureSpace = value.textureSpace;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isTexture(value))\n    {\n        return handleTexture(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        pixelLine,\n        ...fill,\n    };\n}\n", "/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { type GCable, type GCData } from '../../../rendering/renderers/shared/GCSystem';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { type GpuGraphicsContext } from './GraphicsContextSystem';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\n/**\n * The mode for batching graphics instructions.\n *\n * It can be:\n * - 'auto': Automatically determines whether to batch based on the number of instructions.\n * - 'batch': Forces batching of all instructions.\n * - 'no-batch': Disables batching, processing each instruction individually.\n * @category scene\n * @advanced\n */\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\n/** @internal */\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\n/** @internal */\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @category scene\n * @standard\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n    unload: GraphicsContext\n}> implements GCable\n{\n    /** @internal */\n    public _gpuData: Record<number | string, GpuGraphicsContext> = Object.create(null);\n    /** @internal */\n    public _gcData?: GCData;\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    public autoGarbageCollect = true;\n    /** @internal */\n    public _gcLastUsed = -1;\n\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n        /** If the stroke is a pixel line. */\n        pixelLine: false,\n    };\n\n    /**\n     * unique id for this graphics context\n     * @internal\n     */\n    public readonly uid: number = uid('graphicsContext');\n    /**\n     * Indicates whether content is updated and have to be re-rendered.\n     * @internal\n     */\n    public dirty = true;\n    /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n    public batchMode: BatchMode = 'auto';\n    /** @internal */\n    public instructions: GraphicsInstructions[] = [];\n    /**\n     * Custom shader to apply to the graphics when rendering.\n     * @advanced\n     */\n    public customShader?: Shader;\n\n    /** Whether the graphics context has been destroyed. */\n    public destroyed = false;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture.\n     * If only a texture is provided, it uses the texture's width and height for drawing.\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: (tint || tint === 0) ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction?.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction?.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        // Every time the content is updated - we must invalidate bounds, regardless rendering `dirty` state.\n        // Bounds can be read multiple times per frame.\n        this._boundsDirty = true;\n\n        // Visual updates happen only once per frame.\n        // There is no need to dispatch an `update` in if it was already dispatched this frame.\n        if (this.dirty) return;\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const alignment = data.style.alignment;\n\n                const outerPadding = (data.style.width * (1 - alignment));\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - outerPadding,\n                    _bounds.minY - outerPadding,\n                    _bounds.maxX + outerPadding,\n                    _bounds.maxY + outerPadding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    const strokeStyle = (style as ConvertedStrokeStyle);\n\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /** Unloads the GPU data from the graphics context. */\n    public unload(): void\n    {\n        this.emit('unload', this);\n        for (const key in this._gpuData)\n        {\n            this._gpuData[key]?.destroy();\n        }\n        this._gpuData = Object.create(null);\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * context.destroy();\n     * context.destroy(true);\n     * context.destroy({ texture: true, textureSource: true });\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.unload();\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.fill && 'uid' in this._fillStyle.fill\n                    ? this._fillStyle.fill.destroy()\n                    : this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.fill && 'uid' in this._strokeStyle.fill\n                    ? this._strokeStyle.fill.destroy()\n                    : this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA,WAAO,UAAUA;AAOjB,QAAI,SAAS,EAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC;AAOxE,QAAI,UAAU;AAWd,aAASA,OAAM,MAAM;AACpB,UAAI,OAAO,CAAC;AACZ,WAAK,QAAQ,SAAS,SAAS,GAAG,SAAS,MAAK;AAC/C,YAAI,OAAO,QAAQ,YAAY;AAC/B,eAAO,YAAY,IAAI;AAGvB,YAAI,QAAQ,OAAO,KAAK,SAAS,GAAG;AACnC,eAAK,KAAK,CAAC,OAAO,EAAE,OAAO,KAAK,OAAO,GAAG,CAAC,CAAC,CAAC;AAC7C,iBAAO;AACP,oBAAU,WAAW,MAAM,MAAM;AAAA,QAClC;AAEA,eAAO,MAAM;AACZ,cAAI,KAAK,UAAU,OAAO,IAAI,GAAG;AAChC,iBAAK,QAAQ,OAAO;AACpB,mBAAO,KAAK,KAAK,IAAI;AAAA,UACtB;AACA,cAAI,KAAK,SAAS,OAAO,IAAI,EAAG,OAAM,IAAI,MAAM,qBAAqB;AACrE,eAAK,KAAK,CAAC,OAAO,EAAE,OAAO,KAAK,OAAO,GAAG,OAAO,IAAI,CAAC,CAAC,CAAC;AAAA,QACzD;AAAA,MACD,CAAC;AACD,aAAO;AAAA,IACR;AAEA,QAAI,SAAS;AAEb,aAAS,YAAY,MAAM;AAC1B,UAAI,UAAU,KAAK,MAAM,MAAM;AAC/B,aAAO,UAAU,QAAQ,IAAI,MAAM,IAAI,CAAC;AAAA,IACzC;AAAA;AAAA;;;ACjCO,IAAM,gBAAgB;AAEtB,IAAM,WAAW;;;ACrBjB,SAAS,uBAAuB,QACvC;AACI,QAAM,IAAI,OAAO;AAEjB,MAAI,IAAI,GACR;AACI,WAAO;EACX;AAEA,MAAI,OAAO;AAEX,WAAS,IAAI,GAAG,KAAK,OAAO,IAAI,CAAC,GAAG,KAAK,OAAO,IAAI,CAAC,GAAG,IAAI,GAAG,KAAK,GACpE;AACI,UAAM,KAAK,OAAO,CAAC;AACnB,UAAM,KAAK,OAAO,IAAI,CAAC;AAEvB,aAAS,KAAK,OAAO,KAAK;AAE1B,SAAK;AACL,SAAK;EACT;AAEA,MAAI,OAAO,GACX;AACI,WAAO;EACX;AAEA,SAAO;AACX;;;ACVA,SAAS,OACL,GACA,GACA,IACA,IACA,aACA,aACA,WACA,OAEJ;AACI,QAAM,KAAK,IAAK,KAAK;AACrB,QAAM,KAAK,IAAK,KAAK;AACrB,QAAM,KAAK,IAAK,KAAK;AACrB,QAAM,KAAK,IAAK,KAAK;AAGrB,MAAI;AAAK,MACL;AAEJ,MAAI,WACJ;AACI,UAAM;AACN,UAAM,CAAC;EACX,OAEA;AACI,UAAM,CAAC;AACP,UAAM;EACV;AAGA,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AAGjB,QAAM,KAAK,KAAK,GAAG;AACnB,QAAM,KAAK,KAAK,GAAG;AAEnB,SAAO;AACX;AAkBA,SAAS,MACL,IACA,IACA,IACA,IACA,IACA,IACA,OACA,WAEJ;AACI,QAAM,SAAS,KAAK;AACpB,QAAM,SAAS,KAAK;AAEpB,MAAI,SAAS,KAAK,MAAM,QAAQ,MAAM;AACtC,MAAI,SAAS,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAExC,MAAI,aAAa,SAAS,QAC1B;AACI,cAAU,KAAK,KAAK;EACxB,WACS,CAAC,aAAa,SAAS,QAChC;AACI,cAAU,KAAK,KAAK;EACxB;AAEA,MAAI,aAAa;AACjB,QAAM,YAAY,SAAS;AAC3B,QAAM,eAAe,KAAK,IAAI,SAAS;AAEvC,QAAM,SAAS,KAAK,KAAM,SAAS,SAAW,SAAS,MAAO;AAC9D,QAAM,YAAa,KAAK,eAAe,KAAK,KAAK,MAAM,IAAI,KAAK,MAAO,KAAK;AAC5E,QAAM,WAAW,YAAY;AAE7B,gBAAc;AAEd,MAAI,WACJ;AACI,UAAM,KAAK,IAAI,EAAE;AACjB,UAAM,KAAK,IAAI,EAAE;AAEjB,aAAS,IAAI,GAAG,QAAQ,YAAY,IAAI,UAAU,KAAK,SAAS,UAChE;AACI,YAAM,KAAK,IAAI,EAAE;AACjB,YAAM;QAAK,KAAO,KAAK,IAAI,KAAK,IAAI;QAChC,KAAO,KAAK,IAAI,KAAK,IAAI;MAAA;IACjC;AAEA,UAAM,KAAK,IAAI,EAAE;AACjB,UAAM,KAAK,IAAI,EAAE;EACrB,OAEA;AACI,UAAM,KAAK,IAAI,EAAE;AACjB,UAAM,KAAK,IAAI,EAAE;AAEjB,aAAS,IAAI,GAAG,QAAQ,YAAY,IAAI,UAAU,KAAK,SAAS,UAChE;AACI,YAAM;QAAK,KAAO,KAAK,IAAI,KAAK,IAAI;QAChC,KAAO,KAAK,IAAI,KAAK,IAAI;MAAA;AAC7B,YAAM,KAAK,IAAI,EAAE;IACrB;AAEA,UAAM,KAAK,IAAI,EAAE;AACjB,UAAM,KAAK,IAAI,EAAE;EACrB;AAEA,SAAO,WAAW;AACtB;AAYO,SAAS,UACZ,QACA,WACA,eACA,QACA,UACA,SAEJ;AAGI,QAAM,MAAM;AAEZ,MAAI,OAAO,WAAW,GACtB;AACI;EACJ;AAEA,QAAM,QAAQ;AAEd,MAAI,YAAY,MAAM;AAEtB,MAAI,UAAU,cAAc,KAC5B;AAEI,QAAI,cAAc,uBAAuB,MAAM;AAE/C,QAAI,cAAc,gBAAe;AAEjC,iBAAc,YAAY,OAAO,cAAe;EACpD;AAGA,QAAM,aAAa,IAAI,MAAM,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AACjD,QAAM,YAAY,IAAI,MAAM,OAAO,OAAO,SAAS,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,CAAC;AAChF,QAAM,cAAc;AACpB,QAAM,aAAa,KAAK,IAAI,WAAW,IAAI,UAAU,CAAC,IAAI,OACnD,KAAK,IAAI,WAAW,IAAI,UAAU,CAAC,IAAI;AAG9C,MAAI,aACJ;AAEI,aAAS,OAAO,MAAA;AAEhB,QAAI,YACJ;AACI,aAAO,IAAA;AACP,aAAO,IAAA;AACP,gBAAU,IAAI,OAAO,OAAO,SAAS,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,CAAC;IACtE;AAEA,UAAM,aAAa,WAAW,IAAI,UAAU,KAAK;AACjD,UAAM,aAAa,UAAU,IAAI,WAAW,KAAK;AAEjD,WAAO,QAAQ,WAAW,SAAS;AACnC,WAAO,KAAK,WAAW,SAAS;EACpC;AAEA,QAAM,QAAQ;AAEd,QAAM,SAAS,OAAO,SAAS;AAC/B,MAAI,aAAa,OAAO;AACxB,QAAM,aAAa,MAAM,SAAS;AAGlC,QAAM,QAAQ,MAAM,QAAQ;AAC5B,QAAM,eAAe,QAAQ;AAC7B,QAAM,oBAAoB,MAAM,aAAa,MAAM;AAGnD,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK;AACT,MAAI,KAAK;AAGT,MAAI,QAAQ,EAAE,KAAK;AACnB,MAAI,QAAQ,KAAK;AACjB,MAAI,SAAS;AACb,MAAI,SAAS;AAEb,MAAI,OAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAEtD,WAAS;AACT,WAAS;AACT,WAAS;AACT,WAAS;AAET,QAAM,QAAQ;AACd,QAAM,eAAe,IAAI,SAAS;AAClC,QAAM,cAAc,QAAQ;AAE5B,MAAI,CAAC,aACL;AACI,QAAI,MAAM,QAAQ,SAClB;AACI,oBAAc;QACV,KAAM,SAAS,cAAc,eAAe;QAC5C,KAAM,SAAS,cAAc,eAAe;QAC5C,KAAM,QAAQ;QACd,KAAM,QAAQ;QACd,KAAM,QAAQ;QACd,KAAM,QAAQ;QACd;QACA;MAAA,IACA;IACR,WACS,MAAM,QAAQ,UACvB;AACI,oBAAc,OAAO,IAAI,IAAI,OAAO,OAAO,aAAa,aAAa,MAAM,KAAK;IACpF;EACJ;AAGA,QAAM;IACF,KAAM,QAAQ;IACd,KAAM,QAAQ;EAAA;AAClB,QAAM;IACF,KAAM,QAAQ;IACd,KAAM,QAAQ;EAAA;AAElB,WAAS,IAAI,GAAG,IAAI,SAAS,GAAG,EAAE,GAClC;AACI,SAAK,QAAQ,IAAI,KAAK,CAAC;AACvB,SAAK,QAAS,IAAI,KAAK,IAAK,CAAC;AAE7B,SAAK,OAAO,IAAI,CAAC;AACjB,SAAK,OAAQ,IAAI,IAAK,CAAC;AAEvB,SAAK,QAAQ,IAAI,KAAK,CAAC;AACvB,SAAK,QAAS,IAAI,KAAK,IAAK,CAAC;AAE7B,YAAQ,EAAE,KAAK;AACf,YAAQ,KAAK;AAEb,WAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAClD,aAAS;AACT,aAAS;AACT,aAAS;AACT,aAAS;AAET,aAAS,EAAE,KAAK;AAChB,aAAS,KAAK;AAEd,WAAO,KAAK,KAAM,SAAS,SAAW,SAAS,MAAO;AACtD,cAAU;AACV,cAAU;AACV,cAAU;AACV,cAAU;AAGV,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AAGjB,UAAM,MAAO,MAAM,MAAQ,MAAM;AAEjC,UAAM,QAAS,MAAM,MAAQ,MAAM;AACnC,UAAM,YAAa,QAAQ;AAI3B,QAAI,KAAK,IAAI,KAAK,IAAI,OAAQ,KAAK,IAAI,GAAG,GAC1C;AACI,YAAM;QACF,KAAM,QAAQ;QACd,KAAM,QAAQ;MAAA;AAClB,YAAM;QACF,KAAM,QAAQ;QACd,KAAM,QAAQ;MAAA;AAGlB,UAAI,OAAO,GACX;AACI,YAAI,MAAM,SAAS,SACnB;AACI,wBAAc;YACV;YAAI;YACJ,KAAM,QAAQ;YAAc,KAAM,QAAQ;YAC1C,KAAM,SAAS;YAAc,KAAM,SAAS;YAC5C;YAAO;UAAA,IAAS;QACxB,OAEA;AACI,wBAAc;QAClB;AAEA,cAAM;UACF,KAAM,SAAS;UACf,KAAM,SAAS;QAAA;AACnB,cAAM;UACF,KAAM,SAAS;UACf,KAAM,SAAS;QAAA;MACvB;AAEA;IACJ;AAGA,UAAM,MAAO,CAAC,QAAQ,OAAO,CAAC,QAAQ,OAAS,CAAC,QAAQ,OAAO,CAAC,QAAQ;AACxE,UAAM,MAAO,CAAC,SAAS,OAAO,CAAC,SAAS,OAAS,CAAC,SAAS,OAAO,CAAC,SAAS;AAC5E,UAAM,MAAO,MAAM,KAAO,MAAM,MAAO;AACvC,UAAM,MAAO,MAAM,KAAO,MAAM,MAAO;AACvC,UAAM,SAAU,KAAK,OAAO,KAAK,OAAS,KAAK,OAAO,KAAK;AAG3D,UAAM,MAAM,MAAO,KAAK,MAAM;AAC9B,UAAM,MAAM,MAAO,KAAK,MAAM;AAE9B,UAAM,MAAM,MAAO,KAAK,MAAM;AAC9B,UAAM,MAAM,MAAO,KAAK,MAAM;AAG9B,UAAM,yBAAyB,KAAK,IAAK,MAAM,MAAQ,MAAM,KAAO,MAAM,MAAQ,MAAM,GAAI;AAC5F,UAAM,eAAe,YAAY,cAAc;AAC/C,UAAM,0BAA0B,yBAA0B,eAAe,eAAe;AACxF,UAAM,gBAAgB,SAAS;AAE/B,QAAI,eACJ;AACI,UAAI,MAAM,SAAS,WAAW,QAAQ,eAAe,mBACrD;AACI,YAAI,WACJ;AACI,gBAAM,KAAK,KAAK,GAAG;AACnB,gBAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,gBAAM,KAAK,KAAK,GAAG;AACnB,gBAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;QACvE,OAEA;AACI,gBAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,gBAAM,KAAK,KAAK,GAAG;AACnB,gBAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,gBAAM,KAAK,KAAK,GAAG;QACvB;AAEA,sBAAc;MAClB,WACS,MAAM,SAAS,SACxB;AACI,YAAI,WACJ;AACI,gBAAM,KAAK,KAAK,GAAG;AACnB,gBAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAEjE,wBAAc;YACV;YAAI;YACJ,KAAM,QAAQ;YAAc,KAAM,QAAQ;YAC1C,KAAM,SAAS;YAAc,KAAM,SAAS;YAC5C;YAAO;UAAA,IACP;AAEJ,gBAAM,KAAK,KAAK,GAAG;AACnB,gBAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;QACvE,OAEA;AACI,gBAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,gBAAM,KAAK,KAAK,GAAG;AAEnB,wBAAc;YACV;YAAI;YACJ,KAAM,QAAQ;YAAc,KAAM,QAAQ;YAC1C,KAAM,SAAS;YAAc,KAAM,SAAS;YAC5C;YAAO;UAAA,IACP;AAEJ,gBAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,gBAAM,KAAK,KAAK,GAAG;QACvB;MACJ,OAEA;AACI,cAAM,KAAK,KAAK,GAAG;AACnB,cAAM,KAAK,KAAK,GAAG;MACvB;IACJ,OAEA;AACI,YAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,YAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,UAAI,MAAM,SAAS,SACnB;AACI,YAAI,WACJ;AACI,wBAAc;YACV;YAAI;YACJ,KAAM,QAAQ;YAAc,KAAM,QAAQ;YAC1C,KAAM,SAAS;YAAc,KAAM,SAAS;YAC5C;YAAO;UAAA,IACP;QACR,OAEA;AACI,wBAAc;YACV;YAAI;YACJ,KAAM,QAAQ;YAAc,KAAM,QAAQ;YAC1C,KAAM,SAAS;YAAc,KAAM,SAAS;YAC5C;YAAO;UAAA,IACP;QACR;MACJ,WACS,MAAM,SAAS,WAAW,QAAQ,gBAAgB,mBAC3D;AACI,YAAI,WACJ;AACI,gBAAM,KAAK,KAAK,GAAG;AACnB,gBAAM,KAAK,KAAK,GAAG;QACvB,OAEA;AACI,gBAAM,KAAK,KAAK,GAAG;AACnB,gBAAM,KAAK,KAAK,GAAG;QACvB;AACA,sBAAc;MAClB;AACA,YAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,YAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,oBAAc;IAClB;EACJ;AAEA,OAAK,QAAQ,SAAS,KAAK,CAAC;AAC5B,OAAK,QAAS,SAAS,KAAK,IAAK,CAAC;AAElC,OAAK,QAAQ,SAAS,KAAK,CAAC;AAC5B,OAAK,QAAS,SAAS,KAAK,IAAK,CAAC;AAElC,UAAQ,EAAE,KAAK;AACf,UAAQ,KAAK;AAEb,SAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAClD,WAAS;AACT,WAAS;AACT,WAAS;AACT,WAAS;AAET,QAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,QAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAEjE,MAAI,CAAC,aACL;AACI,QAAI,MAAM,QAAQ,SAClB;AACI,oBAAc;QACV,KAAM,SAAS,cAAc,eAAe;QAC5C,KAAM,SAAS,cAAc,eAAe;QAC5C,KAAM,QAAQ;QACd,KAAM,QAAQ;QACd,KAAM,QAAQ;QACd,KAAM,QAAQ;QACd;QACA;MAAA,IACA;IACR,WACS,MAAM,QAAQ,UACvB;AACI,oBAAc,OAAO,IAAI,IAAI,OAAO,OAAO,aAAa,aAAa,OAAO,KAAK;IACrF;EACJ;AAGA,QAAM,OAAO,WAAW;AAGxB,WAAS,IAAI,YAAY,IAAI,aAAa,aAAa,GAAG,EAAE,GAC5D;AACI,SAAK,MAAO,IAAI,CAAE;AAClB,SAAK,MAAO,IAAI,IAAK,CAAC;AAEtB,SAAK,OAAO,IAAI,KAAK,CAAC;AACtB,SAAK,OAAQ,IAAI,KAAK,IAAK,CAAC;AAE5B,SAAK,OAAO,IAAI,KAAK,CAAC;AACtB,SAAK,OAAQ,IAAI,KAAK,IAAK,CAAC;AAG5B,QAAI,KAAK,IAAK,MAAM,KAAK,MAAQ,MAAM,KAAK,MAAQ,MAAM,KAAK,GAAI,IAAI,MACvE;AACI;IACJ;AAEA,YAAQ,KAAK,GAAG,IAAI,GAAG,IAAI,CAAC;EAChC;AACJ;;;AC5aA,IAAM,kBAAuD,CAAC,EAAE,QAAQ,GAAG,OAAO,QAAA,GAAW,EAAE,QAAQ,GAAG,OAAO,QAAA,CAAS;AAkFnH,IAAM,gBAAN,MAAMC,eACb;EA0FI,eAAe,MACf;AA9DA,SAAgB,MAAc,IAAI,cAAc;AAMhD,SAAO,QAAgB;AAEvB,SAAgB,OAAqB;AAOrC,SAAO,aAAuD,CAAA;AAgD1D,QAAI,UAAU,sBAAsB,IAAI;AAExC,UAAM,WAAW,QAAQ,SAAS,WAAWA,eAAa,uBAAuBA,eAAa;AAE9F,cAAU,EAAE,GAAG,UAAU,GAAG,aAAa,OAAO,EAAA;AAEhD,SAAK,eAAe,QAAQ;AAC5B,SAAK,YAAY,QAAQ;AAEzB,QAAI,QAAQ,SAAS,UACrB;AACI,WAAK,SAAS,QAAQ;AACtB,WAAK,cAAc,QAAQ,eAAe,KAAK;AAC/C,WAAK,cAAc,QAAQ;AAC3B,WAAK,cAAc,QAAQ;AAC3B,WAAK,QAAQ,QAAQ;AACrB,WAAK,WAAW,QAAQ;IAC5B,OAEA;AACI,WAAK,QAAQ,QAAQ;AACrB,WAAK,MAAM,QAAQ;IACvB;AAEA,SAAK,eAAe,QAAQ;AAE5B,SAAK,OAAO,QAAQ;AACpB,YAAQ,WAAW,QAAQ,CAAC,SAC5B;AACI,WAAK,aAAa,KAAK,QAAQ,KAAK,KAAK;IAC7C,CAAC;EACL;;;;;;;EAQO,aAAa,QAAgB,OACpC;AACI,SAAK,WAAW,KAAK,EAAE,QAAQ,OAAO,MAAM,OAAO,SAAS,KAAK,EAAE,OAAA,EAAO,CAAG;AAE7E,WAAO;EACX;;;;;;EAOO,sBACP;AACI,QAAI,KAAK,QAAS;AAElB,QAAI,EAAE,GAAG,IAAI,GAAG,GAAA,IAAO,KAAK;AAC5B,QAAI,EAAE,GAAG,IAAI,GAAG,GAAA,IAAO,KAAK;AAE5B,QAAI,KAAK,KAAK;AACd,QAAI,KAAK,KAAK;AAGd,UAAM,OAAO,KAAK,KAAK,KAAK;AAE5B,QAAI,KAAK,cAAc,iBACvB;AACI,UAAI,KAAK,GACT;AACI,cAAM,OAAO;AAEb,aAAK;AACL,aAAK;AACL,cAAM;MACV;AACA,UAAI,KAAK,GACT;AACI,cAAM,OAAO;AAEb,aAAK;AACL,aAAK;AACL,cAAM;MACV;IACJ;AAEA,UAAM,aAAa,KAAK,WAAW,SAAS,KAAK,aAAa;AAE9D,UAAM,cAAc,KAAK;AAEzB,UAAM,EAAE,QAAQ,QAAA,IAAY,UAAU,aAAa,CAAC;AAEpD,UAAM,WAAW,CAAC,OACZ,QAAQ,qBAAqB,GAAG,GAAG,KAAK,cAAc,CAAC,IACvD,QAAQ,qBAAqB,KAAK,cAAc,GAAG,GAAG,CAAC;AAE7D,kBAAc,UAAU,UAAU;AAElC,YAAQ,YAAY;AACpB,YAAQ,SAAS,GAAG,GAAG,aAAa,CAAC;AAErC,SAAK,UAAU,IAAI,QAAQ;MACvB,QAAQ,IAAI,YAAY;QACpB,UAAU;QACV,aAAa,KAAK;MAAA,CACrB;IAAA,CACJ;AAID,UAAM,OAAO,KAAK,KAAM,KAAK,KAAO,KAAK,EAAG;AAC5C,UAAM,QAAQ,KAAK,MAAM,IAAI,EAAE;AAK/B,UAAM,IAAI,IAAI,OAAA;AAEd,MAAE,MAAO,OAAO,aAAc,CAAC;AAC/B,MAAE,OAAO,KAAK;AACd,MAAE,UAAU,IAAI,EAAE;AAElB,QAAI,KAAK,iBAAiB,SAC1B;AACI,QAAE,MAAM,aAAa,WAAW;IACpC;AACA,SAAK,YAAY;EACrB;;;;;;EAOO,gBACP;AACI,QAAI,CAAC,KAAK,QAAS,MAAK;AACxB,QAAI,KAAK,SAAS,UAClB;AACI,WAAK,oBAAA;IACT,OAEA;AACI,WAAK,oBAAA;IACT;EACJ;;;;;;EAOO,sBACP;AACI,QAAI,KAAK,QAAS;AAElB,UAAM,aAAa,KAAK,WAAW,SAAS,KAAK,aAAa;AAE9D,UAAM,cAAc,KAAK;AACzB,UAAM,EAAE,QAAQ,QAAA,IAAY,UAAU,aAAa,WAAW;AAE9D,UAAM,EAAE,GAAG,IAAI,GAAG,GAAA,IAAO,KAAK;AAC9B,UAAM,EAAE,GAAG,IAAI,GAAG,GAAA,IAAO,KAAK;AAE9B,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK,KAAK;AAEhB,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK,KAAK;AAEhB,UAAM,QAAQ,eAAe,KAAK;AAElC,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AAEvB,UAAM,WAAW,QAAQ;MACrB;MACA;MACA,KAAK;OACJ,KAAK,MAAM;OACX,KAAK,MAAM;MACZ,KAAK;IAAA;AAGT,kBAAc,UAAU,UAAU;AAElC,YAAQ,YAAY,WAAW,WAAW,SAAS,CAAC,EAAE;AACtD,YAAQ,SAAS,GAAG,GAAG,aAAa,WAAW;AAE/C,YAAQ,YAAY;AAGpB,YAAQ,UAAU,IAAI,EAAE;AAGxB,YAAQ,OAAO,KAAK,QAAQ;AAG5B,YAAQ,MAAM,GAAG,KAAK,KAAK;AAG3B,YAAQ,UAAU,CAAC,IAAI,CAAC,EAAE;AAE1B,YAAQ,SAAS,GAAG,GAAG,aAAa,WAAW;AAE/C,SAAK,UAAU,IAAI,QAAQ;MACvB,QAAQ,IAAI,YAAY;QACpB,UAAU;QACV,aAAa,KAAK;MAAA,CACrB;IAAA,CACJ;AAED,UAAM,IAAI,IAAI,OAAA;AAGd,MAAE,MAAM,IAAI,OAAO,IAAI,KAAK;AAC5B,MAAE,UAAU,IAAI,EAAE;AAElB,QAAI,KAAK,iBAAiB,SAC1B;AACI,QAAE,MAAM,aAAa,WAAW;IACpC;AAEA,SAAK,YAAY;EACrB;;EAGO,UACP;;AACI,eAAK,YAAL,mBAAc,QAAQ;AACtB,SAAK,UAAU;AACf,SAAK,YAAY;AACjB,SAAK,aAAa,CAAA;AAClB,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,SAAS;AACd,SAAK,cAAc;EACvB;;;;;;EAOA,IAAW,WACX;AACI,WAAO,iBAAiB,KAAK,GAAG,IAAI,KAAK,KAAK;EAClD;AACJ;AAnVa,cAGc,uBAA8C;EACjE,OAAO,EAAE,GAAG,GAAG,GAAG,EAAA;EAClB,KAAK,EAAE,GAAG,GAAG,GAAG,EAAA;EAChB,YAAY,CAAA;EACZ,cAAc;EACd,MAAM;EACN,aAAa;EACb,UAAU;AACd;AAXS,cAcc,uBAA8C;EACjE,QAAQ,EAAE,GAAG,KAAK,GAAG,IAAA;EACrB,aAAa;EACb,aAAa;EACb,YAAY,CAAA;EACZ,OAAO;EACP,cAAc;EACd,MAAM;EACN,aAAa;EACb,UAAU;AACd;AAxBG,IAAM,eAAN;AAqVP,SAAS,cAAc,UAA0B,YACjD;AACI,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KACvC;AACI,UAAM,OAAO,WAAW,CAAC;AAEzB,aAAS,aAAa,KAAK,QAAQ,KAAK,KAAK;EACjD;AACJ;AAEA,SAAS,UAAU,OAAe,QAClC;AACI,QAAM,SAAS,WAAW,IAAA,EAAM,aAAa,OAAO,MAAM;AAC1D,QAAM,UAAU,OAAO,WAAW,IAAI;AAEtC,SAAO,EAAE,QAAQ,QAAA;AACrB;AAmBA,SAAS,sBACL,MAEJ;AACI,MAAI,UAAW,KAAK,CAAC,KAAK,CAAA;AAG1B,MAAI,OAAO,YAAY,YAAY,KAAK,CAAC,GACzC;AAEI,gBAAY,SAAS,4BAA4B;AAGjD,cAAU;MACN,MAAM;MACN,OAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,EAAA;MAC9B,KAAK,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,EAAA;MAC5B,cAAc,KAAK,CAAC;MACpB,aAAa,KAAK,CAAC,KAAK,aAAa,qBAAqB;IAAA;EAElE;AAEA,SAAO;AACX;;;AC3kBA,IAAM,gBAAgB;EAClB,QAAQ;IACJ,cAAc;IACd,cAAc;EAAA;EAElB,YAAY;IACR,cAAc;IACd,cAAc;EAAA;EAElB,YAAY;IACR,cAAc;IACd,cAAc;EAAA;EAElB,aAAa;IACT,cAAc;IACd,cAAc;EAAA;AAEtB;AAsBO,IAAM,cAAN,MACP;EAiBI,YAAY,SAAkB,YAC9B;AAbA,SAAgB,MAAc,IAAI,aAAa;AAM/C,SAAO,QAAgB;AAIvB,SAAO,YAAY,IAAI,OAAA;AAInB,SAAK,UAAU;AAEf,SAAK,UAAU;MACX,IAAI,QAAQ,MAAM;MAClB,IAAI,QAAQ,MAAM;IAAA;AAGtB,QAAI,YACJ;AACI,cAAQ,OAAO,MAAM,eAAe,cAAc,UAAU,EAAE;AAC9D,cAAQ,OAAO,MAAM,eAAe,cAAc,UAAU,EAAE;IAClE;EACJ;;;;;;EAOO,aAAa,WACpB;AACI,UAAM,UAAU,KAAK;AAErB,SAAK,UAAU,SAAS,SAAS;AACjC,SAAK,UAAU,OAAA;AAEf,SAAK,UAAU;MACX,IAAI,QAAQ,MAAM;MAClB,IAAI,QAAQ,MAAM;IAAA;AAGtB,SAAK;EACT;;EAGA,IAAW,UACX;AACI,WAAO,KAAK;EAChB;EACA,IAAW,QAAQ,OACnB;AACI,QAAI,KAAK,aAAa,MAAO;AAE7B,SAAK,WAAW;AAChB,SAAK;EACT;;;;;;EAOA,IAAW,WACX;AACI,WAAO,gBAAgB,KAAK,GAAG,IAAI,KAAK,KAAK;EACjD;;EAGO,UACP;AACI,SAAK,QAAQ,QAAQ,IAAI;AACzB,SAAK,UAAU;EACnB;AACJ;;;AC7HO,SAAS,SACZ,UACA,gBACA,gBAEA,KACA,WACA,WAEA,MACA,SAAiB,MAErB;AACI,MAAI,QAAQ;AAEZ,oBAAkB;AAClB,eAAa;AAEb,QAAM,IAAI,OAAO;AACjB,QAAM,IAAI,OAAO;AACjB,QAAM,IAAI,OAAO;AACjB,QAAM,IAAI,OAAO;AACjB,QAAM,KAAK,OAAO;AAClB,QAAM,KAAK,OAAO;AAElB,SAAO,QAAQ,MACf;AACI,UAAM,IAAI,SAAS,cAAc;AACjC,UAAM,IAAI,SAAS,iBAAiB,CAAC;AAErC,QAAI,SAAS,IAAK,IAAI,IAAM,IAAI,IAAK;AACrC,QAAI,YAAY,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAEzC,iBAAa;AAEb,sBAAkB;AAElB;EACJ;AACJ;AAQO,SAAS,eACZ,KACA,WACA,WACA,MAEJ;AACI,MAAI,QAAQ;AAEZ,eAAa;AAEb,SAAO,QAAQ,MACf;AACI,QAAI,SAAS,IAAI;AACjB,QAAI,YAAY,CAAC,IAAI;AAErB,iBAAa;AAEb;EACJ;AACJ;;;ACtEO,SAAS,kBAAkB,UAAoB,GAAW,QAAiB,QAAiB,MACnG;AACI,QAAM,IAAI,EAAE;AACZ,QAAM,IAAI,EAAE;AACZ,QAAM,IAAI,EAAE;AACZ,QAAM,IAAI,EAAE;AACZ,QAAM,KAAK,EAAE;AACb,QAAM,KAAK,EAAE;AAEb,aAAA,SAAW;AACX,aAAA,SAAW;AACX,WAAA,OAAU,SAAS,SAAS,SAAU;AAEtC,MAAI,QAAQ,SAAS;AAErB,WAAS,IAAI,GAAG,IAAI,MAAM,KAC1B;AACI,UAAM,IAAI,SAAS,KAAK;AACxB,UAAM,IAAI,SAAS,QAAQ,CAAC;AAE5B,aAAS,KAAK,IAAK,IAAI,IAAM,IAAI,IAAK;AACtC,aAAS,QAAQ,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAE1C,aAAS;EACb;AACJ;;;AC5BA,IAAM,iBAAiB,IAAI,OAAA;AAMpB,IAAM,oBAAN,MACP;EADO,cAAA;AAEH,SAAgB,aAAa;AAC7B,SAAO,cAAc;AAIrB,SAAO,WAAqB;AAQ5B,SAAO,iBAAiB;AACxB,SAAO,cAAqB;AAK5B,SAAO,WAAoB;AAC3B,SAAO,SAAgB;EAAA;EAIvB,IAAI,MACJ;AACI,WAAO,KAAK,aAAa;EAC7B;EAEA,IAAI,YACJ;AACI,WAAO,KAAK,aAAa;EAC7B;EAEA,IAAI,UACJ;AACI,WAAO,KAAK,aAAa;EAC7B;EAEA,IAAI,YACJ;AACI,QAAI,KAAK,cAAc,KAAK,gBAC5B;AACI,aAAO,KAAK,WAAW;IAC3B;AAEA,WAAO;EACX;EAEA,IAAI,QACJ;AACI,UAAM,MAAM,KAAK;AACjB,UAAM,MAAO,OAAO,KAAO,MAAM,SAAY,MAAM,QAAS;AAC5D,UAAM,aAAa,KAAK;AAExB,QAAI,YACJ;AACI,aAAO,kBAAkB,KAAK,WAAW,UAAU,KAC/C,KAAK,QAAQ,WAAW,aAAa,OAAQ;IACrD;AAEA,WAAO,OAAQ,KAAK,QAAQ,OAAQ;EACxC;EAEA,IAAI,YACJ;;AACI,aAAO,UAAK,eAAL,mBAAiB,mBAAkB;EAC9C;EAEO,OAAO,WACd;AACI,cAAU,cAAc,KAAK;AAC7B,cAAU,YAAY,KAAK;AAE3B,cAAU,kBAAkB,KAAK;AACjC,cAAU,gBAAgB,KAAK;AAE/B,cAAU,YAAY,KAAK;AAC3B,cAAU,QAAQ,KAAK;AAEvB,cAAU,UAAU,KAAK;AACzB,cAAU,eAAe,KAAK;AAE9B,cAAU,WAAW,KAAK;EAC9B;EAEO,QACP;AACI,SAAK,iBAAiB;AACtB,SAAK,aAAa;AAClB,SAAK,WAAW;EACpB;EAEO,UACP;AACI,SAAK,aAAa;AAClB,SAAK,UAAU;AACf,SAAK,eAAe;AACpB,SAAK,WAAW;AAChB,SAAK,SAAS;EAClB;AACJ;;;ACtGO,IAAM,cAA+C;EACxD,WAAW;IACP,MAAM,cAAc;IACpB,MAAM;EAAA;EAGV,MAAM,OAAqB,QAC3B;AACI,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,QAAI;AACJ,QAAI;AAEJ,QAAI,MAAM,SAAS,UACnB;AACI,YAAM,SAAS;AAEf,WAAK,KAAK,OAAO;AACjB,UAAI,MAAM,GACV;AACI,eAAO;MACX;AACA,UAAI,OAAO;AACX,UAAI,OAAO;AACX,WAAK,KAAK;IACd,WAES,MAAM,SAAS,WACxB;AACI,YAAM,UAAU;AAEhB,WAAK,QAAQ;AACb,WAAK,QAAQ;AACb,UAAI,MAAM,KAAK,MAAM,GACrB;AACI,eAAO;MACX;AACA,UAAI,QAAQ;AACZ,UAAI,QAAQ;AACZ,WAAK,KAAK;IACd,OAEA;AACI,YAAM,cAAc;AACpB,YAAM,YAAY,YAAY,QAAQ;AACtC,YAAM,aAAa,YAAY,SAAS;AAExC,UAAI,YAAY,IAAI;AACpB,UAAI,YAAY,IAAI;AACpB,WAAK,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,YAAY,QAAQ,KAAK,IAAI,WAAW,UAAU,CAAC,CAAC;AACnF,WAAK,YAAY;AACjB,WAAK,aAAa;IACtB;AAEA,QAAI,KAAK,KAAK,KAAK,GACnB;AACI,aAAO;IACX;AAGA,UAAM,IAAI,KAAK,KAAK,MAAM,KAAK,KAAK,KAAK,EAAE,CAAC;AAC5C,UAAM,IAAK,IAAI,KAAM,KAAK,IAAI,MAAM,KAAK,IAAI;AAE7C,QAAI,MAAM,GACV;AACI,aAAO;IACX;AAEA,QAAI,MAAM,GACV;AACI,aAAO,CAAC,IAAI,OAAO,CAAC,IAAI,IAAI;AAC5B,aAAO,CAAC,IAAI,OAAO,CAAC,IAAI,IAAI;AAC5B,aAAO,CAAC,IAAI,OAAO,CAAC,IAAI,IAAI;AAC5B,aAAO,CAAC,IAAI,OAAO,CAAC,IAAI,IAAI;AAE5B,aAAO;IACX;AAEA,QAAI,KAAK;AACT,QAAI,KAAM,IAAI,KAAM,KAAK,IAAI,KAAK;AAClC,QAAI,KAAK;AACT,QAAI,KAAK;AAET,QAAI,KAAK,KAAK;AACd,QAAI,KAAK;AACT,QAAI,KAAK,IAAI;AACb,QAAI,KAAK,IAAI;AACb,QAAI,KAAK,IAAI;AAEb,WAAO,IAAI,IAAI;AACf,WAAO,IAAI,IAAI;AACf,WAAO,EAAE,EAAE,IAAI;AACf,WAAO,EAAE,EAAE,IAAI;AAEf,QAAI,IACJ;AACI,YAAMC,MAAK,IAAI;AAEf,aAAO,IAAI,IAAI;AACf,aAAO,IAAI,IAAIA;AACf,aAAO,EAAE,EAAE,IAAIA;AACf,aAAO,EAAE,EAAE,IAAI;IACnB;AAEA,aAAS,IAAI,GAAG,IAAI,GAAG,KACvB;AACI,YAAM,IAAI,KAAK,KAAK,KAAK,IAAI;AAC7B,YAAMC,MAAK,KAAM,KAAK,IAAI,CAAC,IAAI;AAC/B,YAAMC,MAAK,KAAM,KAAK,IAAI,CAAC,IAAI;AAC/B,YAAMC,MAAK,IAAIF;AACf,YAAMG,MAAK,IAAIH;AACf,YAAMI,MAAK,IAAIH;AACf,YAAMF,MAAK,IAAIE;AAEf,aAAO,IAAI,IAAIC;AACf,aAAO,IAAI,IAAIE;AACf,aAAO,EAAE,EAAE,IAAIA;AACf,aAAO,EAAE,EAAE,IAAID;AACf,aAAO,IAAI,IAAIA;AACf,aAAO,IAAI,IAAIJ;AACf,aAAO,EAAE,EAAE,IAAIA;AACf,aAAO,EAAE,EAAE,IAAIG;IACnB;AAEA,SAAK;AACL,SAAK,KAAK;AACV,SAAK,IAAI;AACT,SAAK,IAAI;AACT,SAAK,IAAI;AACT,UAAM,KAAK,IAAI;AAEf,WAAO,IAAI,IAAI;AACf,WAAO,IAAI,IAAI;AACf,WAAO,EAAE,EAAE,IAAI;AACf,WAAO,EAAE,EAAE,IAAI;AAEf,QAAI,IACJ;AACI,aAAO,IAAI,IAAI;AACf,aAAO,IAAI,IAAI;AACf,aAAO,EAAE,EAAE,IAAI;AACf,aAAO,EAAE,EAAE,IAAI;IACnB;AAEA,WAAO;EACX;EAEA,YAAY,QAAQ,UAAU,gBAAgB,gBAAgB,SAAS,eACvE;AACI,QAAI,OAAO,WAAW,GACtB;AACI;IACJ;AAGA,QAAI,UAAU;AAAG,QACb,UAAU;AAEd,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GACxC;AACI,iBAAW,OAAO,CAAC;AACnB,iBAAW,OAAO,IAAI,CAAC;IAC3B;AACA,eAAY,OAAO,SAAS;AAC5B,eAAY,OAAO,SAAS;AAG5B,QAAI,QAAQ;AAEZ,aAAS,QAAQ,cAAc,IAAI;AACnC,aAAU,QAAQ,iBAAkB,CAAC,IAAI;AACzC,UAAM,cAAc;AAGpB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GACxC;AACI,eAAS,QAAQ,cAAc,IAAI,OAAO,CAAC;AAC3C,eAAU,QAAQ,iBAAkB,CAAC,IAAI,OAAO,IAAI,CAAC;AAErD,UAAI,IAAI,GACR;AACI,gBAAQ,eAAe,IAAI;AAC3B,gBAAQ,eAAe,IAAI;AAC3B,gBAAQ,eAAe,IAAI,QAAQ;MACvC;AACA;IACJ;AAGA,YAAQ,eAAe,IAAI,cAAc;AACzC,YAAQ,eAAe,IAAI;AAC3B,YAAQ,eAAe,IAAI,QAAQ;EACvC;AAEJ;AAGO,IAAM,eAAe,EAAE,GAAG,aAAa,WAAW,EAAE,GAAG,YAAY,WAAW,MAAM,UAAA,EAAU;AAE9F,IAAM,wBAAwB,EAAE,GAAG,aAAa,WAAW,EAAE,GAAG,YAAY,WAAW,MAAM,mBAAA,EAAmB;;;AChNhH,SAAS,eACZ,QACA,QACA,UACA,SAEJ;AACI,QAAM,MAAM;AAEZ,MAAI,OAAO,WAAW,GACtB;AACI;EACJ;AAIA,QAAM,KAAK,OAAO,CAAC;AACnB,QAAM,KAAK,OAAO,CAAC;AAEnB,QAAM,KAAK,OAAO,OAAO,SAAS,CAAC;AAEnC,QAAM,KAAK,OAAO,OAAO,SAAS,CAAC;AAEnC,QAAM,YAAY,UAAW,KAAK,IAAI,KAAK,EAAE,IAAI,OAAO,KAAK,IAAI,KAAK,EAAE,IAAI;AAE5E,QAAM,QAAQ;AAEd,QAAM,SAAS,OAAO,SAAS;AAC/B,QAAM,aAAa,MAAM,SAAS;AAElC,WAAS,IAAI,GAAG,IAAI,QAAQ,KAC5B;AACI,UAAM,KAAK,OAAQ,IAAI,CAAE,CAAC;AAC1B,UAAM,KAAK,OAAQ,IAAI,IAAK,CAAC,CAAC;EAClC;AAEA,WAAS,IAAI,GAAG,IAAI,SAAS,GAAG,KAChC;AACI,YAAQ,KAAK,aAAa,GAAG,aAAa,IAAI,CAAC;EACnD;AAEA,MAAI,WACJ;AACI,YAAQ,KAAK,aAAa,SAAS,GAAG,UAAU;EACpD;AACJ;;;AC3CO,SAAS,qBACZ,QACA,OACA,UACA,gBACA,gBAEA,SACA,eAEJ;AACI,QAAM,YAAY,OAAO,QAAQ,OAAO,CAAC;AAEzC,MAAI,CAAC,WACL;AACI;EACJ;AAEA,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAC3C;AACI,YAAQ,eAAe,IAAK,UAAU,CAAC,IAAI;AAC3C,YAAQ,eAAe,IAAK,UAAU,IAAI,CAAC,IAAI;AAC/C,YAAQ,eAAe,IAAK,UAAU,IAAI,CAAC,IAAI;EACnD;AAEA,MAAI,QAAQ,iBAAiB;AAE7B,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GACxC;AACI,aAAS,KAAK,IAAI,OAAO,CAAC;AAC1B,aAAS,QAAQ,CAAC,IAAI,OAAO,IAAI,CAAC;AAElC,aAAS;EACb;AACJ;;;ACxCA,IAAM,aAAuB,CAAA;AAStB,IAAM,eAA2C;EACpD,WAAW;IACP,MAAM,cAAc;IACpB,MAAM;EAAA;EAGV,MAAM,OAAgB,QACtB;AACI,aAAS,IAAI,GAAG,IAAI,MAAM,OAAO,QAAQ,KACzC;AACI,aAAO,CAAC,IAAI,MAAM,OAAO,CAAC;IAC9B;AAEA,WAAO;EACX;EAEA,YACI,QAEA,UACA,gBACA,gBAEA,SACA,eAEJ;AACI,yBAAqB,QAAQ,YAAY,UAAU,gBAAgB,gBAAgB,SAAS,aAAa;EAC7G;AAEJ;;;ACjCO,IAAM,iBAA+C;EACxD,WAAW;IACP,MAAM,cAAc;IACpB,MAAM;EAAA;EAGV,MAAM,OAAkB,QACxB;AACI,UAAM,WAAW;AACjB,UAAM,IAAI,SAAS;AACnB,UAAM,IAAI,SAAS;AACnB,UAAM,QAAQ,SAAS;AACvB,UAAM,SAAS,SAAS;AAExB,QAAI,EAAE,QAAQ,KAAK,SAAS,IAC5B;AACI,aAAO;IACX;AAEA,WAAO,CAAC,IAAI;AACZ,WAAO,CAAC,IAAI;AACZ,WAAO,CAAC,IAAI,IAAI;AAChB,WAAO,CAAC,IAAI;AACZ,WAAO,CAAC,IAAI,IAAI;AAChB,WAAO,CAAC,IAAI,IAAI;AAChB,WAAO,CAAC,IAAI;AACZ,WAAO,CAAC,IAAI,IAAI;AAEhB,WAAO;EACX;EAEA,YACI,QAEA,UACA,gBACA,gBAEA,SACA,eAEJ;AACI,QAAI,QAAQ;AAEZ,sBAAkB;AAElB,aAAS,iBAAiB,KAAK,IAAI,OAAO,CAAC;AAC3C,aAAS,iBAAiB,QAAQ,CAAC,IAAI,OAAO,CAAC;AAE/C,aAAS;AAET,aAAS,iBAAiB,KAAK,IAAI,OAAO,CAAC;AAC3C,aAAS,iBAAiB,QAAQ,CAAC,IAAI,OAAO,CAAC;AAE/C,aAAS;AAET,aAAS,iBAAiB,KAAK,IAAI,OAAO,CAAC;AAC3C,aAAS,iBAAiB,QAAQ,CAAC,IAAI,OAAO,CAAC;AAE/C,aAAS;AAET,aAAS,iBAAiB,KAAK,IAAI,OAAO,CAAC;AAC3C,aAAS,iBAAiB,QAAQ,CAAC,IAAI,OAAO,CAAC;AAE/C,aAAS;AAET,UAAM,gBAAgB,iBAAiB;AAGvC,YAAQ,eAAe,IAAI;AAC3B,YAAQ,eAAe,IAAI,gBAAgB;AAC3C,YAAQ,eAAe,IAAI,gBAAgB;AAG3C,YAAQ,eAAe,IAAI,gBAAgB;AAC3C,YAAQ,eAAe,IAAI,gBAAgB;AAC3C,YAAQ,eAAe,IAAI,gBAAgB;EAC/C;AACJ;;;AC9EO,IAAM,gBAA6C;EACtD,WAAW;IACP,MAAM,cAAc;IACpB,MAAM;EAAA;EAGV,MAAM,OAAiB,QACvB;AACI,WAAO,CAAC,IAAI,MAAM;AAClB,WAAO,CAAC,IAAI,MAAM;AAClB,WAAO,CAAC,IAAI,MAAM;AAClB,WAAO,CAAC,IAAI,MAAM;AAClB,WAAO,CAAC,IAAI,MAAM;AAClB,WAAO,CAAC,IAAI,MAAM;AAElB,WAAO;EACX;EAEA,YACI,QAEA,UACA,gBACA,gBAEA,SACA,eAEJ;AACI,QAAI,QAAQ;AAEZ,sBAAkB;AAElB,aAAS,iBAAiB,KAAK,IAAI,OAAO,CAAC;AAC3C,aAAS,iBAAiB,QAAQ,CAAC,IAAI,OAAO,CAAC;AAE/C,aAAS;AAET,aAAS,iBAAiB,KAAK,IAAI,OAAO,CAAC;AAC3C,aAAS,iBAAiB,QAAQ,CAAC,IAAI,OAAO,CAAC;AAE/C,aAAS;AAET,aAAS,iBAAiB,KAAK,IAAI,OAAO,CAAC;AAC3C,aAAS,iBAAiB,QAAQ,CAAC,IAAI,OAAO,CAAC;AAE/C,UAAM,gBAAgB,iBAAiB;AAGvC,YAAQ,eAAe,IAAI;AAC3B,YAAQ,eAAe,IAAI,gBAAgB;AAC3C,YAAQ,eAAe,IAAI,gBAAgB;EAC/C;AACJ;;;ACtDA,IAAM,oBAAoB,IAAI,OAAA;AAM9B,IAAM,WAAW,IAAI,UAAA;AAqBd,SAAS,sBAAsBG,MAAa,OAAgC,OAAuB,QAC1G;AAEI,QAAM,gBAAgB,MAAM,SACtBA,KAAI,SAAS,MAAM,MAAM,EAAE,OAAA,IAC3BA,KAAI,SAAA;AAEV,MAAI,MAAM,iBAAiB,SAC3B;AAEI,UAAM,SAAS,MAAM,UAAU,QAAQ;AAEvC,QAAK,MAAsB,OAC3B;AACI,aAAO,IAAK,MAAsB,KAAK;IAC3C;AAEA,UAAM,EAAE,GAAG,IAAI,GAAG,GAAA,IAAO;AACzB,UAAM,KAAK,IAAI,OAAO;AACtB,UAAM,KAAK,IAAI,OAAO;AAEtB,UAAM,MAAM,CAAC,KAAK;AAClB,UAAM,MAAM,CAAC,KAAK;AAElB,UAAM,KAAK,cAAc;AACzB,UAAM,KAAK,cAAc;AACzB,UAAM,KAAK,cAAc;AACzB,UAAM,KAAK,cAAc;AAEzB,kBAAc,KAAK;AACnB,kBAAc,KAAK;AACnB,kBAAc,KAAK;AACnB,kBAAc,KAAK;AAEnB,kBAAc,KAAM,MAAM,KAAO,MAAM,KAAM,cAAc;AAC3D,kBAAc,KAAM,MAAM,KAAO,MAAM,KAAM,cAAc;EAC/D,OAEA;AAEI,kBAAc,UAAU,MAAM,QAAQ,MAAM,GAAG,MAAM,QAAQ,MAAM,CAAC;AACpE,kBAAc,MAAM,IAAK,MAAM,QAAQ,OAAO,OAAQ,IAAK,MAAM,QAAQ,OAAO,MAAO;EAC3F;AAEA,QAAM,cAAc,MAAM,QAAQ,OAAO;AAGzC,MAAI,EAAE,MAAM,gBAAgB,iBAAiB,YAAY,gBAAgB,iBACzE;AACI,gBAAY,cAAc;AAC1B,gBAAY,OAAA;EAChB;AAGA,MAAI,QACJ;AACI,kBAAc,OAAO,kBAAkB,SAAS,MAAM,EAAE,OAAA,CAAQ;EACpE;AAEA,SAAO;AACX;;;ACpEO,IAAM,gBAAmD,CAAA;AAEhE,WAAW,YAAY,cAAc,cAAc,aAAa;AAChE,WAAW,IAAI,gBAAgB,cAAc,eAAe,aAAa,cAAc,qBAAqB;AAE5G,IAAMC,YAAW,IAAI,UAAA;AACrB,IAAMC,qBAAoB,IAAI,OAAA;AAOvB,SAAS,oBAAoB,SAA0B,YAC9D;AACI,QAAM,EAAE,cAAc,QAAA,IAAY;AAGlC,UAAQ,SAAS;AACjB,eAAa,QAAQ,SAAS;AAC9B,eAAa,SAAS,SAAS;AAC/B,eAAa,IAAI,SAAS;AAE1B,WAAS,IAAI,GAAG,IAAI,QAAQ,aAAa,QAAQ,KACjD;AACI,UAAM,cAAc,QAAQ,aAAa,CAAC;AAE1C,QAAI,YAAY,WAAW,WAC3B;AAEI,+BAAyB,YAAY,MAAM,SAAS,YAAY;IACpE,WACS,YAAY,WAAW,UAAU,YAAY,WAAW,UACjE;AACI,YAAM,WAAW,YAAY,WAAW;AAGxC,YAAM,YAAY,YAAY,KAAK,KAAK;AAExC,YAAM,QAAQ,YAAY,KAAK;AAE/B,YAAM,OAAO,YAAY,KAAK;AAE9B,UAAI,YAAY,MAChB;AACI,mCAA2B,KAAK,WAAW,OAAO,MAAM,SAAS,YAAY;MACjF;AAEA,UAAI,MACJ;AAEI,kBAAU,gBAAgB,UAAU,gBAAgB,SAAS,CAAC,EAAE,QAAQ,KAAK,UAAU;MAC3F;AAEA,iCAA2B,WAAW,OAAO,UAAU,SAAS,YAAY;IAChF;EACJ;AACJ;AAEA,SAAS,yBACL,MACA,SACA,cAMJ;AACI,QAAM,SAAmB,CAAA;AAEzB,QAAM,QAAQ,cAAc;AAE5B,QAAM,OAAOD;AAEb,OAAK,IAAI,KAAK;AACd,OAAK,IAAI,KAAK;AACd,OAAK,QAAQ,KAAK;AAClB,OAAK,SAAS,KAAK;AAEnB,QAAM,SAAS,KAAK;AAGpB,MAAI,CAAC,MAAM,MAAM,MAAM,MAAM,GAC7B;AACI;EACJ;AAEA,QAAM,EAAE,UAAU,KAAK,QAAA,IAAY;AAEnC,QAAM,cAAc,QAAQ;AAC5B,QAAM,aAAa,SAAS,SAAS;AAErC,MAAI,QACJ;AACI,sBAAkB,QAAQ,MAAM;EACpC;AAEA,QAAM,YAAY,QAAQ,UAAU,GAAG,YAAY,SAAS,WAAW;AAEvE,QAAM,UAAU,KAAK;AACrB,QAAM,aAAa,QAAQ;AAE3B,MAAI;IACA,WAAW;IAAI,WAAW;IAC1B,WAAW;IAAI,WAAW;IAC1B,WAAW;IAAI,WAAW;IAC1B,WAAW;IAAI,WAAW;EAAA;AAG9B,QAAM,gBAAgB,QAAQ,IAAI,iBAAiB;AAEnD,gBAAc,cAAc;AAC5B,gBAAc,YAAY,QAAQ,SAAS;AAE3C,gBAAc,kBAAkB;AAChC,gBAAc,gBAAiB,SAAS,SAAS,IAAK;AAEtD,gBAAc,YAAY,KAAK;AAC/B,gBAAc,QAAQ,KAAK;AAE3B,gBAAc,UAAU;AACxB,gBAAc,eAAe;AAE7B,UAAQ,KAAK,aAAa;AAC9B;AAEA,SAAS,2BACL,WACA,OACA,UACA,SACA,cAMJ;AACI,QAAM,EAAE,UAAU,KAAK,QAAA,IAAY;AAEnC,YAAU,gBAAgB,QAAQ,CAAC,EAAE,OAAO,WAAW,QAAQ,MAAA,MAC/D;AACI,UAAM,SAAmB,CAAA;AACzB,UAAM,QAAQ,cAAc,MAAM,IAAI;AAMtC,QAAI,CAAC,MAAM,MAAM,OAAO,MAAM,GAC9B;AACI;IACJ;AAEA,UAAM,cAAc,QAAQ;AAC5B,UAAM,aAAa,SAAS,SAAS;AACrC,QAAI,WAAqB;AAEzB,QAAI,QACJ;AACI,wBAAkB,QAAQ,MAAM;IACpC;AAEA,QAAI,CAAC,UACL;AACI,UAAI,OACJ;AACI,cAAM,cAAwB,CAAA;AAE9B,cAAM,cAAc,OAAO,MAAA;AAE3B,cAAM,aAAa,cAAc,KAAK;AAEtC,mBAAW,QAAQ,CAAC,eACpB;AACI,sBAAY,KAAK,YAAY,SAAS,CAAC;AACvC,sBAAY,KAAK,GAAG,UAAU;QAClC,CAAC;AAED,6BAAqB,aAAa,aAAa,UAAU,GAAG,YAAY,SAAS,WAAW;MAChG,OAEA;AACI,cAAM,YAAY,QAAQ,UAAU,GAAG,YAAY,SAAS,WAAW;MAC3E;IACJ,OAEA;AACI,YAAM,QAAS,MAAkB,aAAa;AAC9C,YAAM,YAAY;AAElB,UAAI,CAAC,UAAU,WACf;AACI,kBAAU,QAAQ,WAAW,OAAO,OAAO,UAAU,OAAO;MAChE,OAEA;AACI,uBAAe,QAAQ,OAAO,UAAU,OAAO;AAC/C,mBAAW;MACf;IACJ;AAEA,UAAM,YAAY,IAAI,SAAS;AAE/B,UAAM,UAAU,MAAM;AAEtB,QAAI,YAAY,QAAQ,OACxB;AACI,YAAM,gBAAgBE,sBAA0BD,oBAAmB,OAAO,OAAO,MAAM;AAEvF,eAAS,UAAU,GAAG,YAAY,KAAK,WAAW,GAAI,SAAS,SAAS,IAAK,YAAY,aAAa;IAC1G,OAEA;AACI,qBAAe,KAAK,WAAW,GAAI,SAAS,SAAS,IAAK,UAAU;IACxE;AAEA,UAAM,gBAAgB,QAAQ,IAAI,iBAAiB;AAEnD,kBAAc,cAAc;AAC5B,kBAAc,YAAY,QAAQ,SAAS;AAE3C,kBAAc,kBAAkB;AAChC,kBAAc,gBAAiB,SAAS,SAAS,IAAK;AAEtD,kBAAc,YAAY,MAAM;AAChC,kBAAc,QAAQ,MAAM;AAE5B,kBAAc,UAAU;AACxB,kBAAc,eAAe;AAC7B,kBAAc,WAAW;AAEzB,YAAQ,KAAK,aAAa;EAC9B,CAAC;AACL;AAEA,SAAS,cAAc,gBACvB;AACI,QAAM,aAAa,CAAA;AAEnB,WAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAC3C;AACI,UAAM,gBAAgB,eAAe,CAAC,EAAE;AAGxC,UAAM,aAAuB,CAAA;AAE7B,UAAM,cAAc,cAAc,cAAc,IAAI;AAEpD,QAAI,YAAY,MAAM,eAAe,UAAU,GAC/C;AACI,iBAAW,KAAK,UAAU;IAC9B;EACJ;AAEA,SAAO;AACX;;;;AC9PO,SAAS,aAAa,SAAiB,MAC9C;AAEI,QAAM,eAAW,sBAAAE,SAAM,OAAO;AAG9B,QAAM,WAAsB,CAAA;AAC5B,MAAI,iBAAiC;AAGrC,MAAI,QAAQ;AACZ,MAAI,QAAQ;AAGZ,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KACrC;AACI,UAAM,UAAU,SAAS,CAAC;AAC1B,UAAM,OAAO,QAAQ,CAAC;AACtB,UAAM,OAAO;AAEb,YAAQ,MAAA;MAEJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,iBAAS,KAAK,CAAC;AACf,iBAAS,KAAK,CAAC;AAEf,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AAEd,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,iBAAS,KAAK,CAAC;AAEf,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AAEd,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,iBAAS,KAAK,CAAC;AAEf,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,iBAAS,KAAK,CAAC;AACf,iBAAS,KAAK,CAAC;AAEf,aAAK,OAAO,OAAO,KAAK;AACxB;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK;UACD,KAAK,CAAC;UAAG,KAAK,CAAC;;UACf,KAAK,CAAC;UAAG,KAAK,CAAC;;UACf;UAAO;;QAAA;AAEX;MACJ,KAAK;AACD,aAAK;UACD,QAAQ,KAAK,CAAC;UAAG,QAAQ,KAAK,CAAC;;UAC/B,QAAQ,KAAK,CAAC;UAAG,QAAQ,KAAK,CAAC;;UAC/B,QAAQ,KAAK,CAAC;UAAG,QAAQ,KAAK,CAAC;;QAAA;AAGnC,iBAAS,KAAK,CAAC;AACf,iBAAS,KAAK,CAAC;AACf;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK;UACD,KAAK,CAAC;UAAG,KAAK,CAAC;;UACf;UAAO;;QAAA;AAEX;MACJ,KAAK;AACD,aAAK;UACD,QAAQ,KAAK,CAAC;UAAG,QAAQ,KAAK,CAAC;;UAC/B,QAAQ,KAAK,CAAC;UAAG,QAAQ,KAAK,CAAC;;QAAA;AAGnC,iBAAS,KAAK,CAAC;AACf,iBAAS,KAAK,CAAC;AACf;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK;UACD,KAAK,CAAC;UAAG,KAAK,CAAC;;UACf;UAAO;;QAAA;AAEX;MACJ,KAAK;AACD,aAAK;UACD,QAAQ,KAAK,CAAC;UAAG,QAAQ,KAAK,CAAC;;UAC/B,QAAQ,KAAK,CAAC;UAAG,QAAQ,KAAK,CAAC;;QAAA;AAGnC,iBAAS,KAAK,CAAC;AACf,iBAAS,KAAK,CAAC;AACf;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK;UACD;UAAO;;QAAA;AAEX;MACJ,KAAK;AACD,iBAAS,KAAK,CAAC;AACf,iBAAS,KAAK,CAAC;AAEf,aAAK;UACD;UAAO;;QAAA;AAEX;MACJ,KAAK;AACD,gBAAQ,KAAK,CAAC;AACd,gBAAQ,KAAK,CAAC;AAEd,aAAK;UACD,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN;UAAO;;QAAA;AAEX;MACJ,KAAK;AACD,iBAAS,KAAK,CAAC;AACf,iBAAS,KAAK,CAAC;AAEf,aAAK;UACD,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN,KAAK,CAAC;;UACN;UAAO;;QAAA;AAEX;MACJ,KAAK;MACL,KAAK;AACD,aAAK,UAAA;AACL,YAAI,SAAS,SAAS,GACtB;AAEI,2BAAiB,SAAS,IAAA;AAC1B,cAAI,gBACJ;AACI,oBAAQ,eAAe;AACvB,oBAAQ,eAAe;UAC3B,OAEA;AACI,oBAAQ;AACR,oBAAQ;UACZ;QACJ;AACA,yBAAiB;AACjB;MACJ;AAEI,aAAK,6BAA6B,IAAI,EAAE;IAAA;AAKhD,QAAI,SAAS,OAAO,SAAS,KAC7B;AACI,UAAI,mBAAmB,MACvB;AACI,yBAAiB,EAAE,QAAQ,OAAO,QAAQ,MAAA;AAC1C,iBAAS,KAAK,cAAc;MAChC;IACJ;EACJ;AAEA,SAAO;AACX;;;AC/MO,IAAM,qBAAN,MACP;EADO,cAAA;AAKH,SAAO,UAA+B,CAAA;AACtC,SAAO,eAA6B;MAChC,UAAU,CAAA;MACV,KAAK,CAAA;MACL,SAAS,CAAA;IAAC;EACd;EAGO,QACP;AACI,QAAI,KAAK,SACT;AACI,WAAK,QAAQ,QAAQ,CAAC,UACtB;AACI,gBAAQ,OAAO,KAAK;MACxB,CAAC;IACL;AACA,QAAI,KAAK,cACT;AACI,cAAQ,OAAO,KAAK,YAAY;IACpC;AAEA,SAAK,cAAc;AACnB,SAAK,UAAU;AAEf,SAAK,QAAQ,SAAS;AACtB,SAAK,aAAa,QAAQ,SAAS;AACnC,SAAK,aAAa,SAAS,SAAS;AACpC,SAAK,aAAa,IAAI,SAAS;AAE/B,SAAK,eAAe;EACxB;EAEO,UACP;AACI,SAAK,MAAA;AACL,SAAK,UAAU;AACf,SAAK,eAAe;EACxB;AACJ;AAOO,IAAM,4BAAN,MACP;EADO,cAAA;AAGH,SAAO,eAAe,IAAI,eAAA;EAAe;EAElC,KAAK,SACZ;AACI,UAAM,cAAc,QAAQ;AAE5B,SAAK,UAAU,KAAK,QAAQ,mBAAmB,WAAW,IAAI,KAAK,UAAU,IAAI,eAAe,EAAE,YAAA,CAAa;AAC/G,SAAK,aAAa,MAAA;EACtB;;;;;;EAOA,IAAI,WACJ;AAEI,gBAAY,QAAQ,wFAAwF;AAG5G,WAAO,KAAK,QAAQ;EACxB;EAEO,UACP;AACI,SAAK,QAAQ,QAAA;AACb,SAAK,aAAa,QAAA;AAElB,SAAK,UAAU;AACf,SAAK,eAAe;EACxB;AACJ;AAkBO,IAAM,yBAAN,MAAMC,wBACb;EAsBI,YAAY,UACZ;AACI,SAAK,YAAY;AACjB,SAAK,mBAAmB,IAAI,cAAc,EAAE,UAAU,MAAM,YAAY,MAAM,kBAAA,CAAmB;EACrG;;;;;EAMO,KAAK,SACZ;AACI,IAAAA,wBAAsB,eAAe,oBAAmB,mCAAS,qBAC1DA,wBAAsB,eAAe;EAChD;;;;;;EAOO,qBAAqB,SAC5B;AACI,WAAO,QAAQ,SAAS,KAAK,UAAU,GAAG,EAAE,gBAAgB,KAAK,uBAAuB,OAAO;EACnG;;;;;;;;EASO,iBAAiB,SACxB;AACI,UAAM,aAAa,CAAC,CAAC,QAAQ,SAAS,KAAK,UAAU,GAAG;AACxD,UAAM,aAAiC,QAAQ,SAAS,KAAK,UAAU,GAAG,KAAK,KAAK,aAAa,OAAO;AAExG,QAAI,QAAQ,SAAS,CAAC,YACtB;AACI,UAAI,YACJ;AACI,mBAAW,MAAA;MACf;AAEA,0BAAoB,SAAS,UAAU;AAEvC,YAAM,YAAY,QAAQ;AAE1B,UAAI,QAAQ,gBAAgB,cAAc,YAC1C;AACI,mBAAW,cAAc;MAC7B,WACS,cAAc,QACvB;AACI,mBAAW,cAAe,WAAW,aAAa,SAAS,SAAS;MACxE,OAEA;AACI,mBAAW,cAAc;MAC7B;AAEA,cAAQ,QAAQ;IACpB;AAEA,WAAO;EACX;;;;;;;;EASO,cAAc,SACrB;AACI,WAAO,QAAQ,SAAS,KAAK,UAAU,GAAG,KAAK,KAAK,aAAa,OAAO;EAC5E;EAEQ,uBAAuB,SAC/B;AACI,UAAM,eAA0C,QAAQ,IAAI,2BAA2B;MACnF,aAAa,KAAK,UAAU,OAAO;IAAA,CACtC;AAED,UAAM,aAAa,QAAQ,SAAS,KAAK,UAAU,GAAG;AACtD,UAAM,EAAE,SAAS,aAAA,IAAiB;AAElC,eAAW,eAAe;AAE1B,UAAM,aAAa,aAAa,SAAS;AACzC,UAAM,YAAY,aAAa,QAAQ;AAEvC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KACpC;AACI,cAAQ,CAAC,EAAE,iBAAiB;IAChC;AAEA,UAAM,UAAU,aAAa;AAG7B,YAAQ,sBAAsB,UAAU;AACxC,YAAQ,kBAAkB,SAAS;AAEnC,YAAQ,MAAA;AAER,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KACpC;AACI,YAAM,QAAQ,QAAQ,CAAC;AAEvB,cAAQ,IAAI,KAAK;IACrB;AAEA,YAAQ,OAAO,aAAa,YAAY;AAExC,UAAM,WAAW,QAAQ;AAKzB,aAAS,YAAY,gBAAgB,QAAQ,aAAa,QAAQ,WAAW,IAAI;AACjF,aAAS,QAAQ,CAAC,EAAE,gBAAgB,QAAQ,gBAAgB,aAAa,QAAQ,eAAe,IAAI;AAEpG,UAAM,cAAc,QAAQ;AAE5B,aAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KACxC;AACI,YAAM,QAAQ,YAAY,CAAC;AAE3B,YAAM,YAAY;QACd,MAAM,SAAS;QACf,MAAM,SAAS;QACf,KAAK,UAAU,OAAO;MAAA;IAE9B;AAEA,WAAO;EACX;EAEQ,aAAa,SACrB;AACI,UAAM,aAAa,IAAI,mBAAA;AAEvB,eAAW,UAAU;AAErB,YAAQ,SAAS,KAAK,UAAU,GAAG,IAAI;AAEvC,SAAK,iBAAiB,IAAI,OAAO;AAEjC,WAAO;EACX;EAEO,UACP;AACI,SAAK,iBAAiB,QAAA;AACrB,SAAK,YAAqB;EAC/B;AACJ;AArLa,uBAGK,YAAY;EACtB,MAAM;IACF,cAAc;IACd,cAAc;EAAA;EAElB,MAAM;AACV;AATS,uBAYc,iBAA+C;;;;;EAKlE,kBAAkB;AACtB;AAlBG,IAAM,wBAAN;;;AC/HP,IAAM,kBAAkB;AACxB,IAAM,cAAc;AACpB,IAAM,wBAAwB;AAE9B,IAAM,6BAA6B;AACnC,IAAM,kBAAkB;AACxB,IAAM,aAAa;AAeZ,SAAS,oBACZ,QACA,IAAY,IACZ,MAAc,MACd,MAAc,MACd,IAAY,IACZ,YAEJ;AAEI,QAAM,QAAQ;AACd,QAAM,YAAY,KAAK;IACnB;;IACA,KAAK,IAAI,GAAG,cAAc,sBAAsB,eAAe,gBAAgB;EAAA;AAEnF,MAAI,qBAAqB,wBAAwB,aAAa;AAE9D,uBAAqB;AACrB,QAAM,IAAI,IAAI,MAAM,MAAM,MAAM,MAAM,IAAI,IAAI,QAAQ,iBAAiB;AAEvE,SAAO;AACX;AAKA,SAAS,MACL,IAAY,IACZ,MAAc,MACd,MAAc,MACd,IAAY,IACZ,QACA,mBAEJ;AAGI,YAAU,IAAI,IAAI,MAAM,MAAM,MAAM,MAAM,IAAI,IAAI,QAAQ,mBAAmB,CAAC;AAC9E,SAAO,KAAK,IAAI,EAAE;AACtB;AAGA,SAAS,UACL,IAAY,IACZ,IAAY,IACZ,IAAY,IACZ,IAAY,IACZ,QACA,mBACA,OACJ;AACI,MAAI,QAAQ,iBACZ;AAAE;EAAQ;AAEV,QAAM,KAAK,KAAK;AAIhB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,QAAQ,MAAM,OAAO;AAC3B,QAAM,QAAQ,MAAM,OAAO;AAC3B,QAAM,QAAQ,MAAM,OAAO;AAC3B,QAAM,QAAQ,MAAM,OAAO;AAC3B,QAAM,SAAS,OAAO,QAAQ;AAC9B,QAAM,SAAS,OAAO,QAAQ;AAE9B,MAAI,QAAQ,GACZ;AAGI,QAAI,KAAK,KAAK;AACd,QAAI,KAAK,KAAK;AAEd,UAAM,KAAK,KAAK,KAAM,KAAK,MAAM,MAAQ,KAAK,MAAM,EAAG;AACvD,UAAM,KAAK,KAAK,KAAM,KAAK,MAAM,MAAQ,KAAK,MAAM,EAAG;AAEvD,QAAI;AAAK,QAAI;AAEb,QAAI,KAAK,eAAe,KAAK,aAC7B;AAGI,WAAK,KAAK,OAAO,KAAK,OAAO,qBAAsB,KAAK,KAAO,KAAK,KACpE;AAII,YAAI,kBAAkB,4BACtB;AACI,iBAAO,KAAK,OAAO,KAAK;AAExB;QACJ;AAIA,cAAM,MAAM,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAEvC,cAAM,KAAK,IAAI,MAAM,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,CAAC;AACjD,cAAM,KAAK,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,IAAI,GAAG;AACjD,YAAI,OAAO,GAAI,OAAO,IAAI,KAAM;AAChC,YAAI,OAAO,GAAI,OAAO,IAAI,KAAM;AAEhC,YAAI,MAAM,MAAM,iBAChB;AAGI,iBAAO,KAAK,OAAO,KAAK;AAExB;QACJ;AAEA,YAAI,eAAe,GACnB;AACI,cAAI,MAAM,YACV;AACI,mBAAO,KAAK,IAAI,EAAE;AAElB;UACJ;AAEA,cAAI,MAAM,YACV;AACI,mBAAO,KAAK,IAAI,EAAE;AAElB;UACJ;QACJ;MACJ;IACJ,WACS,KAAK,aACd;AAGI,UAAI,KAAK,MAAM,qBAAsB,KAAK,KAAO,KAAK,KACtD;AACI,YAAI,kBAAkB,4BACtB;AACI,iBAAO,KAAK,OAAO,KAAK;AAExB;QACJ;AAIA,cAAM,KAAK,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,CAAC;AAC1E,YAAI,OAAO,GAAI,OAAO,IAAI,KAAM;AAEhC,YAAI,MAAM,iBACV;AACI,iBAAO,KAAK,IAAI,EAAE;AAClB,iBAAO,KAAK,IAAI,EAAE;AAElB;QACJ;AAEA,YAAI,eAAe,GACnB;AACI,cAAI,MAAM,YACV;AACI,mBAAO,KAAK,IAAI,EAAE;AAElB;UACJ;QACJ;MACJ;IACJ,WACS,KAAK,aACd;AAGI,UAAI,KAAK,MAAM,qBAAsB,KAAK,KAAO,KAAK,KACtD;AACI,YAAI,kBAAkB,4BACtB;AACI,iBAAO,KAAK,OAAO,KAAK;AAExB;QACJ;AAIA,cAAM,KAAK,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,CAAC;AAC1E,YAAI,OAAO,GAAI,OAAO,IAAI,KAAM;AAEhC,YAAI,MAAM,iBACV;AACI,iBAAO,KAAK,IAAI,EAAE;AAClB,iBAAO,KAAK,IAAI,EAAE;AAElB;QACJ;AAEA,YAAI,eAAe,GACnB;AACI,cAAI,MAAM,YACV;AACI,mBAAO,KAAK,IAAI,EAAE;AAElB;UACJ;QACJ;MACJ;IACJ,OAEA;AAGI,WAAK,SAAU,KAAK,MAAM;AAC1B,WAAK,SAAU,KAAK,MAAM;AAC1B,UAAK,KAAK,KAAO,KAAK,MAAO,mBAC7B;AACI,eAAO,KAAK,OAAO,KAAK;AAExB;MACJ;IACJ;EACJ;AAIA,YAAU,IAAI,IAAI,KAAK,KAAK,MAAM,MAAM,OAAO,OAAO,QAAQ,mBAAmB,QAAQ,CAAC;AAC1F,YAAU,OAAO,OAAO,MAAM,MAAM,KAAK,KAAK,IAAI,IAAI,QAAQ,mBAAmB,QAAQ,CAAC;AAC9F;;;ACzPA,IAAMC,mBAAkB;AACxB,IAAMC,eAAc;AACpB,IAAMC,yBAAwB;AAE9B,IAAMC,8BAA6B;AACnC,IAAMC,mBAAkB;AAajB,SAAS,uBACZ,QACA,IAAY,IACZ,MAAc,MACd,IAAY,IACZ,YAEJ;AACI,QAAM,QAAQ;AACd,QAAM,YAAY,KAAK;IACnB;;IACA,KAAK,IAAI,GAAG,cAAc,sBAAsB,eAAe,gBAAgB;EAAA;AAEnF,MAAI,qBAAqBF,yBAAwB,aAAa;AAE9D,uBAAqB;AACrB,EAAAG,OAAM,IAAI,IAAI,MAAM,MAAM,IAAI,IAAI,QAAQ,iBAAiB;AAE3D,SAAO;AACX;AAKA,SAASA,OACL,IAAY,IACZ,MAAc,MACd,IAAY,IACZ,QACA,mBAEJ;AACI,EAAAC,WAAU,QAAQ,IAAI,IAAI,MAAM,MAAM,IAAI,IAAI,mBAAmB,CAAC;AAElE,SAAO,KAAK,IAAI,EAAE;AACtB;AAEA,SAASA,WACL,QACA,IAAY,IACZ,IAAY,IACZ,IAAY,IACZ,mBACA,OAEJ;AACI,MAAI,QAAQN,kBACZ;AAAE;EAAQ;AAEV,QAAM,KAAK,KAAK;AAIhB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,OAAO,KAAK,MAAM;AACxB,QAAM,QAAQ,MAAM,OAAO;AAC3B,QAAM,QAAQ,MAAM,OAAO;AAE3B,MAAI,KAAK,KAAK;AACd,MAAI,KAAK,KAAK;AACd,QAAM,IAAI,KAAK,KAAO,KAAK,MAAM,MAAQ,KAAK,MAAM,EAAI;AAExD,MAAI,IAAIC,cACR;AAGI,QAAI,IAAI,KAAK,qBAAsB,KAAK,KAAO,KAAK,KACpD;AAII,UAAIG,mBAAkBD,6BACtB;AACI,eAAO,KAAK,MAAM,IAAI;AAEtB;MACJ;AAIA,UAAI,KAAK,KAAK,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,CAAC;AAE7E,UAAI,MAAM,GAAI,MAAM,IAAI,KAAM;AAE9B,UAAI,KAAKC,kBACT;AAGI,eAAO,KAAK,MAAM,IAAI;AAEtB;MACJ;IACJ;EACJ,OAEA;AAGI,SAAK,QAAS,KAAK,MAAM;AACzB,SAAK,QAAS,KAAK,MAAM;AACzB,QAAK,KAAK,KAAO,KAAK,MAAO,mBAC7B;AACI,aAAO,KAAK,MAAM,IAAI;AAEtB;IACJ;EACJ;AAIA,EAAAE,WAAU,QAAQ,IAAI,IAAI,KAAK,KAAK,MAAM,MAAM,mBAAmB,QAAQ,CAAC;AAC5E,EAAAA,WAAU,QAAQ,MAAM,MAAM,KAAK,KAAK,IAAI,IAAI,mBAAmB,QAAQ,CAAC;AAChF;;;AC9HO,SAAS,SACZ,QACA,GAAW,GACX,QACA,OACA,KACA,WACA,OAEJ;AAGI,MAAI,OAAO,KAAK,IAAI,QAAQ,GAAG;AAE/B,MAAI,CAAC,aAAa,QAAQ,KAC1B;AACI,WAAQ,IAAI,KAAK,KAAM;EAC3B,WACS,aAAa,MAAM,OAC5B;AACI,WAAQ,IAAI,KAAK,KAAM;EAC3B;AAIA,YAAA,QAAU,KAAK,IAAI,GAAG,KAAK,MAAM,IAAI,KAAK,IAAI,QAAQ,IAAI,CAAC,KAAK,OAAQ,KAAK,GAAI,CAAC;AAGlF,UAAQ,KAAK,IAAI,OAAO,CAAC;AAEzB,MAAI,IAAI,OAAQ;AAChB,MAAI,IAAI;AAGR,OAAK,YAAY,KAAK;AAEtB,WAAS,IAAI,GAAG,IAAI,QAAQ,GAAG,KAC/B;AACI,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,UAAM,KAAK,KAAK,IAAI,CAAC;AAErB,UAAM,KAAK,IAAK,KAAK;AACrB,UAAM,KAAK,IAAK,KAAK;AAErB,WAAO,KAAK,IAAI,EAAE;AAElB,SAAK;EACT;AACJ;;;AC7CO,SAAS,WACZ,QACA,IAAY,IACZ,IAAY,IACZ,QAEJ;AACI,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AACtC,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AAEtC,QAAM,KAAK,QAAQ;AACnB,QAAM,KAAK,QAAQ;AACnB,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK,IAAK,KAAK,KAAO,KAAK,EAAG;AAEzC,MAAI,KAAK,QAAU,WAAW,GAC9B;AACI,QAAI,OAAO,OAAO,SAAS,CAAC,MAAM,MAAM,OAAO,OAAO,SAAS,CAAC,MAAM,IACtE;AACI,aAAO,KAAK,IAAI,EAAE;IACtB;AAEA;EACJ;AAEA,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAK,SAAS,KAAK,KAAK,EAAE,IAAI;AACpC,QAAM,KAAK,SAAS,KAAK,KAAK,EAAE,IAAI;AACpC,QAAM,KAAK,KAAK,KAAK;AACrB,QAAM,KAAK,KAAK,KAAK;AACrB,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,aAAa,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAC9C,QAAM,WAAW,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAE5C;IAAS;IACJ,KAAK;IACL,KAAK;IACN;IACA;IACA;IACA,KAAK,KAAK,KAAK;EAAA;AAEvB;;;AC9DA,IAAM,MAAM,KAAK,KAAK;AAEtB,IAAM,MAAM;EACR,SAAS;EACT,SAAS;EACT,MAAM;EACN,MAAM;AACV;AAEA,IAAM,eAAe,CACjB,EAAE,GAAG,EAAA,GACL,IAAY,IACZ,QAAgB,QAChB,SAAiB,SACjBC,SAEJ;AACI,OAAK;AACL,OAAK;AAEL,QAAM,KAAM,SAAS,IAAM,SAAS;AACpC,QAAM,KAAM,SAAS,IAAM,SAAS;AAEpCA,OAAI,IAAI,KAAK;AACbA,OAAI,IAAI,KAAK;AAEb,SAAOA;AACX;AAEA,SAAS,cAAc,MAAc,MACrC;AAII,QAAM,KAAK,SAAS,sBAAsB,kBAAkB,IAAI,IAAI,KAAK,IAAI,OAAO,CAAC;AAErF,QAAM,IAAI,SAAS,qBAAqB,iBAAiB;AAEzD,QAAM,KAAK,KAAK,IAAI,IAAI;AACxB,QAAM,KAAK,KAAK,IAAI,IAAI;AACxB,QAAM,KAAK,KAAK,IAAI,OAAO,IAAI;AAC/B,QAAM,KAAK,KAAK,IAAI,OAAO,IAAI;AAE/B,SAAO;IACH;MACI,GAAG,KAAM,KAAK;MACd,GAAG,KAAM,KAAK;IAAA;IAElB;MACI,GAAG,KAAM,KAAK;MACd,GAAG,KAAM,KAAK;IAAA;IAElB;MACI,GAAG;MACH,GAAG;IAAA;EACP;AAER;AAEA,IAAM,cAAc,CAAC,IAAY,IAAY,IAAY,OACzD;AACI,QAAM,OAAS,KAAK,KAAO,KAAK,KAAM,IAAK,KAAK;AAEhD,MAAI,MAAO,KAAK,KAAO,KAAK;AAE5B,MAAI,MAAM,GACV;AACI,UAAM;EACV;AAEA,MAAI,MAAM,IACV;AACI,UAAM;EACV;AAEA,SAAO,OAAO,KAAK,KAAK,GAAG;AAC/B;AAEA,IAAM,eAAe,CACjB,IACA,IACA,IACA,IACA,IACA,IACA,cACA,WACA,QACA,QACA,KACA,KACAA,SAQJ;AACI,QAAM,OAAO,KAAK,IAAI,IAAI,CAAC;AAC3B,QAAM,OAAO,KAAK,IAAI,IAAI,CAAC;AAC3B,QAAM,QAAQ,KAAK,IAAI,KAAK,CAAC;AAC7B,QAAM,QAAQ,KAAK,IAAI,KAAK,CAAC;AAE7B,MAAI,WAAY,OAAO,OAAS,OAAO,QAAU,OAAO;AAExD,MAAI,WAAW,GACf;AACI,eAAW;EACf;AAEA,cAAa,OAAO,QAAU,OAAO;AACrC,aAAW,KAAK,KAAK,QAAQ,KAAK,iBAAiB,YAAY,KAAK;AAEpE,QAAM,WAAW,WAAW,KAAK,KAAK;AACtC,QAAM,WAAW,WAAW,CAAC,KAAK,KAAK;AAEvC,QAAM,UAAW,SAAS,WAAa,SAAS,YAAc,KAAK,MAAM;AACzE,QAAM,UAAW,SAAS,WAAa,SAAS,YAAc,KAAK,MAAM;AAEzE,QAAM,OAAO,MAAM,YAAY;AAC/B,QAAM,OAAO,MAAM,YAAY;AAC/B,QAAM,OAAO,CAAC,MAAM,YAAY;AAChC,QAAM,OAAO,CAAC,MAAM,YAAY;AAEhC,QAAM,OAAO,YAAY,GAAG,GAAG,KAAK,GAAG;AACvC,MAAI,OAAO,YAAY,KAAK,KAAK,KAAK,GAAG;AAEzC,MAAI,cAAc,KAAK,OAAO,GAC9B;AACI,YAAQ;EACZ;AAEA,MAAI,cAAc,KAAK,OAAO,GAC9B;AACI,YAAQ;EACZ;AAEAA,OAAI,UAAU;AACdA,OAAI,UAAU;AACdA,OAAI,OAAO;AACXA,OAAI,OAAO;AACf;AAeO,SAAS,cACZ,QACA,IACA,IACA,IACA,IACA,IACA,IACA,gBAAgB,GAChB,eAAe,GACf,YAAY,GAEhB;AACI,MAAI,OAAO,KAAK,OAAO,GACvB;AACI;EACJ;AAEA,QAAM,SAAS,KAAK,IAAI,gBAAgB,MAAM,GAAG;AACjD,QAAM,SAAS,KAAK,IAAI,gBAAgB,MAAM,GAAG;AAEjD,QAAM,MAAO,UAAU,KAAK,MAAM,IAAM,UAAU,KAAK,MAAM;AAC7D,QAAM,MAAO,CAAC,UAAU,KAAK,MAAM,IAAM,UAAU,KAAK,MAAM;AAE9D,MAAI,QAAQ,KAAK,QAAQ,GACzB;AACI;EACJ;AAEA,OAAK,KAAK,IAAI,EAAE;AAChB,OAAK,KAAK,IAAI,EAAE;AAEhB,QAAM,SAAU,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,IAAM,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC;AAExF,MAAI,SAAS,GACb;AACI,UAAM,KAAK,KAAK,MAAM;AACtB,UAAM,KAAK,KAAK,MAAM;EAC1B;AAEA;IACI;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EAAA;AAGJ,MAAI,EAAE,MAAM,KAAA,IAAS;AACrB,QAAM,EAAE,SAAS,QAAA,IAAY;AAM7B,MAAI,QAAQ,KAAK,IAAI,IAAI,KAAK,MAAM;AAEpC,MAAI,KAAK,IAAI,IAAM,KAAK,IAAI,MAC5B;AACI,YAAQ;EACZ;AAEA,QAAM,WAAW,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG,CAAC;AAE7C,UAAQ;AAER,MAAI,QAAQ,OAAO,OAAO,SAAS,CAAC;AACpC,MAAI,QAAQ,OAAO,OAAO,SAAS,CAAC;AAEpC,QAAM,gBAAgB,EAAE,GAAG,GAAG,GAAG,EAAA;AAEjC,WAAS,IAAI,GAAG,IAAI,UAAU,KAC9B;AACI,UAAM,QAAQ,cAAc,MAAM,IAAI;AAEtC,UAAM,EAAE,GAAG,IAAI,GAAG,GAAA,IAAO,aAAa,MAAM,CAAC,GAAG,IAAI,IAAI,QAAQ,QAAQ,SAAS,SAAS,aAAa;AACvG,UAAM,EAAE,GAAG,IAAI,GAAG,GAAA,IAAO,aAAa,MAAM,CAAC,GAAG,IAAI,IAAI,QAAQ,QAAQ,SAAS,SAAS,aAAa;AACvG,UAAM,EAAE,GAAG,EAAA,IAAM,aAAa,MAAM,CAAC,GAAG,IAAI,IAAI,QAAQ,QAAQ,SAAS,SAAS,aAAa;AAE/F;MACI;MACA;MAAO;MACP;MAAI;MAAI;MAAI;MAAI;MAAG;IAAA;AAGvB,YAAQ;AACR,YAAQ;AAER,YAAQ;EACZ;AACJ;;;ACvPO,SAAS,gBACZ,GACA,QACA,QAEJ;AACI,QAAM,UAAU,CAAC,GAAc,OAC/B;AACI,UAAM,IAAI,GAAG,IAAI,EAAE;AACnB,UAAM,IAAI,GAAG,IAAI,EAAE;AACnB,UAAM,MAAM,KAAK,KAAM,IAAI,IAAM,IAAI,CAAE;AACvC,UAAM,KAAK,IAAI;AACf,UAAM,KAAK,IAAI;AAEf,WAAO,EAAE,KAAK,IAAI,GAAA;EACtB;AAEA,QAAM,cAAc,CAAC,GAAW,MAChC;AACI,QAAI,MAAM,GACV;AACI,QAAE,OAAO,EAAE,GAAG,EAAE,CAAC;IACrB,OAEA;AACI,QAAE,OAAO,EAAE,GAAG,EAAE,CAAC;IACrB;EACJ;AAEA,MAAI,KAAK,OAAO,OAAO,SAAS,CAAC;AAEjC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AACI,UAAM,KAAK,OAAO,IAAI,OAAO,MAAM;AACnC,UAAM,UAAU,GAAG,UAAU;AAE7B,QAAI,WAAW,GACf;AACI,kBAAY,GAAG,EAAE;AACjB,WAAK;AACL;IACJ;AAEA,UAAM,KAAK,QAAQ,IAAI,KAAK,OAAO,MAAM;AACzC,UAAM,KAAK,QAAQ,IAAI,EAAE;AACzB,UAAM,KAAK,QAAQ,IAAI,EAAE;AAEzB,QAAI,GAAG,MAAM,QAAQ,GAAG,MAAM,MAC9B;AACI,kBAAY,GAAG,EAAE;AACjB,WAAK;AACL;IACJ;AAEA,QAAI,QAAQ,KAAK,KAAM,GAAG,KAAK,GAAG,KAAO,GAAG,KAAK,GAAG,EAAG;AACvD,QAAI,eAAe;AACnB,QAAI,gBAAgB;AAEpB,QAAK,GAAG,KAAK,GAAG,KAAO,GAAG,KAAK,CAAC,GAAG,KAAM,GACzC;AACI,UAAI,QAAQ,GACZ;AACI,gBAAQ,KAAK,KAAK;MACtB,OAEA;AACI,gBAAQ,KAAK,KAAK;AAClB,uBAAe;AACf,wBAAgB;MACpB;IACJ,WACS,QAAQ,GACjB;AACI,qBAAe;AACf,sBAAgB;IACpB;AAEA,UAAM,YAAY,QAAQ;AAE1B,QAAI;AACJ,QAAI,SAAS,KAAK;MACb,KAAK,IAAI,SAAS,IAAI,UAAW,KAAK,IAAI,SAAS;IAAA;AAGxD,QAAI,SAAS,KAAK,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,CAAC,GAC5C;AACI,eAAS,KAAK,IAAI,GAAG,MAAM,GAAG,GAAG,MAAM,CAAC;AACxC,gBAAU,KAAK,IAAK,SAAS,KAAK,IAAI,SAAS,IAAK,KAAK,IAAI,SAAS,CAAC;IAC3E,OAEA;AACI,gBAAU;IACd;AAEA,UAAM,KAAK,GAAG,IAAK,GAAG,KAAK,SAAW,CAAC,GAAG,KAAK,UAAU;AACzD,UAAM,KAAK,GAAG,IAAK,GAAG,KAAK,SAAW,GAAG,KAAK,UAAU;AACxD,UAAM,aAAa,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,IAAM,KAAK,KAAK,IAAK;AAC/D,UAAM,WAAW,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,IAAM,KAAK,KAAK,IAAK;AAE7D,QAAI,MAAM,GACV;AACI,QAAE;QACE,KAAM,KAAK,IAAI,UAAU,IAAI;QAC7B,KAAM,KAAK,IAAI,UAAU,IAAI;MAAA;IAErC;AAEA,MAAE,IAAI,IAAI,IAAI,SAAS,YAAY,UAAU,aAAa;AAE1D,SAAK;EACT;AACJ;AAiBO,SAAS,2BACZ,GACA,QACA,QACA,YAEJ;AACI,QAAM,WAAW,CAAC,IAAe,OAC7B,KAAK,MAAO,GAAG,IAAI,GAAG,MAAM,KAAO,GAAG,IAAI,GAAG,MAAM,CAAE;AAEzD,QAAM,YAAY,CAAC,IAAe,IAAe,OAAe;IAC5D,GAAG,GAAG,KAAM,GAAG,IAAI,GAAG,KAAK;IAC3B,GAAG,GAAG,KAAM,GAAG,IAAI,GAAG,KAAK;EAAA;AAG/B,QAAM,YAAY,OAAO;AAEzB,WAAS,IAAI,GAAG,IAAI,WAAW,KAC/B;AACI,UAAM,YAAY,QAAQ,IAAI,KAAK,SAAS;AAC5C,UAAM,UAAU,UAAU,UAAU;AAEpC,QAAI,WAAW,GACf;AACI,UAAI,MAAM,GACV;AACI,UAAE,OAAO,UAAU,GAAG,UAAU,CAAC;MACrC,OAEA;AACI,UAAE,OAAO,UAAU,GAAG,UAAU,CAAC;MACrC;AAEA;IACJ;AAEA,UAAM,YAAY,OAAO,CAAC;AAC1B,UAAM,YAAY,QAAQ,IAAI,KAAK,SAAS;AAE5C,UAAM,iBAAiB,SAAS,WAAW,SAAS;AACpD,QAAI;AAEJ,QAAI,iBAAiB,MACrB;AACI,cAAQ;IACZ,OAEA;AACI,YAAM,qBAAqB,KAAK,IAAI,iBAAiB,GAAG,OAAO;AAE/D,cAAQ;QACJ;QACA;QACA,qBAAqB;MAAA;IAE7B;AAEA,UAAM,iBAAiB,SAAS,WAAW,SAAS;AACpD,QAAI;AAEJ,QAAI,iBAAiB,MACrB;AACI,YAAM;IACV,OAEA;AACI,YAAM,qBAAqB,KAAK,IAAI,iBAAiB,GAAG,OAAO;AAE/D,YAAM;QACF;QACA;QACA,qBAAqB;MAAA;IAE7B;AAEA,QAAI,MAAM,GACV;AACI,QAAE,OAAO,MAAM,GAAG,MAAM,CAAC;IAC7B,OAEA;AACI,QAAE,OAAO,MAAM,GAAG,MAAM,CAAC;IAC7B;AACA,MAAE,iBAAiB,UAAU,GAAG,UAAU,GAAG,IAAI,GAAG,IAAI,GAAG,UAAU;EACzE;AACJ;;;AC3MA,IAAM,gBAAgB,IAAI,UAAA;AAwBnB,IAAM,YAAN,MACP;EAQI,YAAY,gBACZ;AAPA,SAAO,kBAA6C,CAAA;AACpD,SAAQ,eAA+B;AAEvC,SAAiB,UAAU,IAAI,OAAA;AAK3B,SAAK,kBAAkB;AACvB,SAAK,SAAS,eAAe;EACjC;;;;;;;EAQO,OAAO,GAAW,GACzB;AACI,SAAK,UAAU,GAAG,CAAC;AAEnB,WAAO;EACX;;;;;;;EAQO,OAAO,GAAW,GACzB;AACI,SAAK,YAAA;AAEL,UAAM,SAAS,KAAK,aAAa;AAEjC,UAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AACtC,UAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AAEtC,QAAI,UAAU,KAAK,UAAU,GAC7B;AACI,aAAO,KAAK,GAAG,CAAC;IACpB;AAEA,WAAO;EACX;;;;;;;;;;;;EAaO,IAAI,GAAW,GAAW,QAAgB,YAAoB,UAAkB,kBACvF;AAGI,SAAK,YAAY,KAAK;AAEtB,UAAM,SAAS,KAAK,aAAa;AAEjC,aAAS,QAAQ,GAAG,GAAG,QAAQ,YAAY,UAAU,gBAAgB;AAErE,WAAO;EACX;;;;;;;;;;;EAYO,MAAM,IAAY,IAAY,IAAY,IAAY,QAC7D;AACI,SAAK,YAAA;AAEL,UAAM,SAAS,KAAK,aAAa;AAEjC,eAAW,QAAQ,IAAI,IAAI,IAAI,IAAI,MAAM;AAEzC,WAAO;EACX;;;;;;;;;;;;;EAcO,SACH,IAAY,IACZ,eAAuB,cAAsB,WAC7C,GAAW,GAEf;AACI,UAAM,SAAS,KAAK,aAAa;AAGjC;MACI;MACA,KAAK,aAAa;MAClB,KAAK,aAAa;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;IAAA;AAGJ,WAAO;EACX;;;;;;;;;;;;;;EAeO,cACH,MAAc,MAAc,MAAc,MAC1C,GAAW,GACX,YAEJ;AACI,SAAK,YAAA;AAEL,UAAM,cAAc,KAAK;AAKzB;MACI,KAAK,aAAa;MAClB,YAAY;MAAO,YAAY;MAC/B;MAAM;MAAM;MAAM;MAAM;MAAG;MAC3B;IAAA;AAGJ,WAAO;EACX;;;;;;;;;;;EAYO,iBAAiB,MAAc,MAAc,GAAW,GAAW,WAC1E;AACI,SAAK,YAAA;AAEL,UAAM,cAAc,KAAK;AAKzB;MACI,KAAK,aAAa;MAClB,YAAY;MAAO,YAAY;MAC/B;MAAM;MAAM;MAAG;MACf;IAAA;AAGJ,WAAO;EACX;;;;;;EAOO,YACP;AACI,SAAK,QAAQ,IAAI;AAEjB,WAAO;EACX;;;;;;;EAQO,QAAQ,MAAoB,WACnC;AACI,SAAK,QAAA;AAGL,QAAI,aAAa,CAAC,UAAU,WAAA,GAC5B;AACI,aAAO,KAAK,MAAM,IAAI;AACtB,WAAK,UAAU,SAAS;IAC5B;AAEA,UAAM,kBAAkB,KAAK;AAC7B,UAAM,QAAQ,gBAAgB;AAE9B,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAC9C;AACI,YAAM,cAAc,KAAK,aAAa,CAAC;AAEvC,WAAK,YAAY,MAAM,EAAE,GAAI,YAAY,IAA0D;IACvG;AAMA,QAAI,KAAK,iBAAiB,gBAAgB,SAAS,QAAQ,GAC3D;AACI,UAAI,YAAY;AAGhB,eAAS,IAAI,OAAO,IAAI,gBAAgB,QAAQ,KAChD;AACI,cAAM,iBAAiB,gBAAgB,CAAC;AAExC,YAAI,eAAe,MAAM,SAAS,WAClC;AACI,gBAAM,UAAU,eAAe;AAC/B,gBAAM,cAAc,uCAAW;AAE/B,cAAI,eAAe,YAAY,gBAAgB,OAAO,GACtD;AAEI,sBAAU,UAAV,UAAU,QAAU,CAAA;AACpB,sBAAU,MAAM,KAAK,cAAc;AAGnC,4BAAgB,WAAW,GAAG,IAAI,CAAC;AACnC,4BAAgB;AAChB;UACJ,OAEA;AACI,wBAAY;UAChB;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;;;;;EAMO,OAAO,YAAY,OAC1B;AACI,SAAK,QAAQ,SAAS;EAC1B;;;;;;;;;;EAWO,KAAK,GAAW,GAAW,GAAW,GAAW,WACxD;AACI,SAAK,UAAU,IAAI,UAAU,GAAG,GAAG,GAAG,CAAC,GAAG,SAAS;AAEnD,WAAO;EACX;;;;;;;;;EAUO,OAAO,GAAW,GAAW,QAAgB,WACpD;AACI,SAAK,UAAU,IAAI,OAAO,GAAG,GAAG,MAAM,GAAG,SAAS;AAElD,WAAO;EACX;;;;;;;;;EAUO,KAAK,QAAgC,OAAiB,WAC7D;AACI,UAAM,UAAU,IAAI,QAAQ,MAAM;AAElC,YAAQ,YAAY;AAEpB,SAAK,UAAU,SAAS,SAAS;AAEjC,WAAO;EACX;;;;;;;;;;;EAYO,YAAY,GAAW,GAAW,QAAgB,OAAe,WAAW,GAAG,WACtF;AACI,YAAQ,KAAK,IAAI,QAAQ,GAAG,CAAC;AAC7B,UAAM,aAAc,KAAK,KAAK,KAAK,IAAK;AACxC,UAAM,QAAS,KAAK,KAAK,IAAK;AAC9B,UAAM,UAAU,CAAA;AAEhB,aAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACI,YAAM,QAAQ,aAAc,IAAI;AAEhC,cAAQ;QACJ,IAAK,SAAS,KAAK,IAAI,KAAK;QAC5B,IAAK,SAAS,KAAK,IAAI,KAAK;MAAA;IAEpC;AAEA,SAAK,KAAK,SAAS,MAAM,SAAS;AAElC,WAAO;EACX;;;;;;;;;;;;;EAcO,UACH,GAAW,GACX,QACA,OAAe,QACf,WAAW,GACX,YAEJ;AACI,YAAQ,KAAK,IAAK,QAAQ,GAAI,CAAC;AAE/B,QAAI,UAAU,GACd;AACI,aAAO,KAAK,YAAY,GAAG,GAAG,QAAQ,OAAO,QAAQ;IACzD;AAEA,UAAM,aAAc,SAAS,KAAK,IAAI,KAAK,KAAK,KAAK,IAAK;AAE1D,aAAS,KAAK,IAAI,QAAQ,UAAU;AAEpC,UAAM,aAAc,KAAK,KAAK,KAAK,IAAK;AACxC,UAAM,QAAS,KAAK,KAAK,IAAK;AAC9B,UAAM,iBAAkB,QAAQ,KAAK,KAAK,KAAM,QAAQ;AAExD,aAAS,IAAI,GAAG,IAAI,OAAO,KAC3B;AACI,YAAM,QAAS,IAAI,QAAS;AAC5B,YAAM,KAAK,IAAK,SAAS,KAAK,IAAI,KAAK;AACvC,YAAM,KAAK,IAAK,SAAS,KAAK,IAAI,KAAK;AACvC,YAAM,KAAK,QAAS,KAAK,KAAM;AAC/B,YAAM,KAAK,QAAS,KAAK,KAAM;AAC/B,YAAM,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE;AACrC,YAAM,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE;AACrC,YAAM,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE;AACrC,YAAM,KAAK,KAAM,SAAS,KAAK,IAAI,EAAE;AAErC,UAAI,MAAM,GACV;AACI,aAAK,OAAO,IAAI,EAAE;MACtB,OAEA;AACI,aAAK,OAAO,IAAI,EAAE;MACtB;AACA,WAAK,iBAAiB,IAAI,IAAI,IAAI,IAAI,UAAU;IACpD;AAEA,WAAO,KAAK,UAAA;EAChB;;;;;;;;;;;;;;EAeO,WAAW,QAAwB,QAAgB,eAAe,OAAO,YAChF;AACI,QAAI,OAAO,SAAS,GACpB;AACI,aAAO;IACX;AAEA,QAAI,cACJ;AACI,iCAA2B,MAAM,QAAQ,QAAQ,UAAU;IAC/D,OAEA;AACI,sBAAgB,MAAM,QAAQ,MAAM;IACxC;AAEA,WAAO,KAAK,UAAA;EAChB;;;;;;;;;;EAWO,WAAW,GAAW,GAAW,OAAe,QAAgB,QACvE;AACI,QAAI,WAAW,GACf;AACI,aAAO,KAAK,KAAK,GAAG,GAAG,OAAO,MAAM;IACxC;AAEA,UAAM,YAAY,KAAK,IAAI,OAAO,MAAM,IAAI;AAC5C,UAAM,QAAQ,KAAK,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,MAAM,CAAC;AAC9D,UAAM,QAAQ,IAAI;AAClB,UAAM,SAAS,IAAI;AACnB,UAAM,MAAM,QAAQ,IAAI,CAAC,QAAQ;AACjC,UAAM,OAAO,KAAK,IAAI,KAAK;AAE3B,WAAO,KACF,OAAO,GAAG,IAAI,IAAI,EAClB,MAAM,IAAI,KAAK,IAAI,KAAK,IAAI,MAAM,GAAG,IAAI,EACzC,OAAO,QAAQ,MAAM,CAAC,EACtB,MAAM,QAAQ,KAAK,IAAI,KAAK,OAAO,IAAI,MAAM,IAAI,EACjD,OAAO,OAAO,SAAS,IAAI,EAC3B,MAAM,QAAQ,KAAK,SAAS,KAAK,IAAI,QAAQ,MAAM,QAAQ,IAAI,EAC/D,OAAO,IAAI,MAAM,MAAM,EACvB,MAAM,IAAI,KAAK,SAAS,KAAK,GAAG,SAAS,MAAM,IAAI,EACnD,UAAA;EACT;;;;;;;;;;EAWO,YAAY,GAAW,GAAW,OAAe,QAAgB,SAAiB,WACzF;AACI,QAAI,WAAW,GACf;AACI,aAAO,KAAK,KAAK,GAAG,GAAG,OAAO,MAAM;IACxC;AAEA,UAAM,QAAQ,KAAK,IAAI,SAAS,KAAK,IAAI,OAAO,MAAM,IAAI,CAAC;AAC3D,UAAM,QAAQ,IAAI;AAClB,UAAM,SAAS,IAAI;AACnB,UAAM,SAAS;MACX,IAAI;MAAO;MACX,QAAQ;MAAO;MACf;MAAO,IAAI;MACX;MAAO,SAAS;MAChB,QAAQ;MAAO;MACf,IAAI;MAAO;MACX;MAAG,SAAS;MACZ;MAAG,IAAI;IAAA;AAIX,aAAS,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK,GAC7C;AACI,UAAI,OAAO,CAAC,MAAM,OAAO,IAAI,CAAC,KAAK,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,GACjE;AACI,eAAO,OAAO,IAAI,GAAG,CAAC;MAC1B;IACJ;AAEA,WAAO,KAAK,KAAK,QAAQ,MAAM,SAAS;EAC5C;;;;;;;;;;;EAYO,QAAQ,GAAW,GAAW,SAAiB,SAAiB,WACvE;AAGI,SAAK,UAAU,IAAI,QAAQ,GAAG,GAAG,SAAS,OAAO,GAAG,SAAS;AAE7D,WAAO;EACX;;;;;;;;;;;;;EAcO,UAAU,GAAW,GAAW,GAAW,GAAW,QAAiB,WAC9E;AACI,SAAK,UAAU,IAAI,iBAAiB,GAAG,GAAG,GAAG,GAAG,MAAM,GAAG,SAAS;AAElE,WAAO;EACX;;;;;;;;;;EAWO,UAAU,OAAuB,QACxC;AACI,SAAK,QAAA;AAEL,SAAK,gBAAgB,KAAK,EAAE,OAAO,WAAW,OAAA,CAAQ;AAEtD,WAAO;EACX;;;;;;;;EASO,UAAU,GAAW,GAC5B;AACI,QAAI,cAAc,KAAK;AAEvB,QAAI,aACJ;AACI,WAAK,QAAA;IACT;AAEA,kBAAc,IAAI,QAAA;AAElB,gBAAY,OAAO,KAAK,GAAG,CAAC;AAE5B,SAAK,eAAe;AAEpB,WAAO;EACX;;;;;;;;;EAUO,QAAQ,YAAY,OAC3B;AACI,UAAM,QAAQ,KAAK;AAEnB,QAAI,SAAS,MAAM,OAAO,SAAS,GACnC;AACI,YAAM,YAAY;AAElB,WAAK,gBAAgB,KAAK,EAAE,MAAA,CAAO;IACvC;AAEA,SAAK,eAAe;AAEpB,WAAO;EACX;EAEQ,YAAY,QAAQ,MAC5B;AACI,QAAI,KAAK,aAAc;AAEvB,SAAK,eAAe,IAAI,QAAA;AAExB,QAAI,OACJ;AAEI,YAAM,YAAY,KAAK,gBAAgB,KAAK,gBAAgB,SAAS,CAAC;AAEtE,UAAI,WACJ;AAEI,YAAI,KAAK,UAAU,MAAM;AACzB,YAAI,KAAK,UAAU,MAAM;AAEzB,YAAI,UAAU,aAAa,CAAC,UAAU,UAAU,WAAA,GAChD;AACI,gBAAM,IAAI,UAAU;AAEpB,gBAAM,QAAQ;AAEd,eAAM,EAAE,IAAI,KAAO,EAAE,IAAI,KAAM,EAAE;AACjC,eAAM,EAAE,IAAI,QAAU,EAAE,IAAI,KAAM,EAAE;QACxC;AAEA,aAAK,aAAa,OAAO,KAAK,IAAI,EAAE;MACxC,OAEA;AACI,aAAK,aAAa,OAAO,KAAK,GAAG,CAAC;MACtC;IACJ;EACJ;;EAGO,YACP;AACI,UAAM,OAAO,KAAK;AAElB,SAAK,gBAAgB,SAAS;AAC9B,SAAK,eAAe;AAEpB,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAC9C;AACI,YAAM,cAAc,KAAK,aAAa,CAAC;AAGvC,WAAK,YAAY,MAAM,EAAE,GAAI,YAAY,IAA0D;IACvG;AAEA,SAAK,OAAA;EACT;;EAGA,IAAI,SACJ;AACI,UAAM,SAAS,KAAK;AAEpB,WAAO,MAAA;AAEP,UAAM,kBAAkB,KAAK;AAE7B,aAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAC5C;AACI,YAAM,iBAAiB,gBAAgB,CAAC;AAExC,YAAM,aAAa,eAAe,MAAM,UAAU,aAAa;AAE/D,UAAI,eAAe,WACnB;AACI,eAAO,QAAQ,YAAY,eAAe,SAAS;MACvD,OAEA;AACI,eAAO,QAAQ,UAAU;MAC7B;IACJ;AAEA,WAAO;EACX;AACJ;;;AC9tBO,IAAM,eAAN,MAAM,cACb;;;;;;EAkDI,YAAY,cAA2C,SAAS,OAChE;AAlDA,SAAO,eAAkC,CAAA;AAGzC,SAAgB,MAAc,IAAI,cAAc;AAEhD,SAAQ,SAAS;AA8Cb,SAAK,gBAAgB;AAErB,QAAI,OAAO,iBAAiB,UAC5B;AACI,mBAAa,cAAc,IAAI;IACnC,OAEA;AACI,WAAK,gBAAe,6CAAc,YAAW,CAAA;IACjD;EACJ;;;;;EAjCA,IAAI,YACJ;AACI,QAAI,CAAC,KAAK,YACV;AACI,WAAK,aAAa,IAAI,UAAU,IAAI;IACxC;AAEA,QAAI,KAAK,QACT;AACI,WAAK,SAAS;AACd,WAAK,WAAW,UAAA;IACpB;AAEA,WAAO,KAAK;EAChB;;;;;;;EA2BO,QAAQ,MAAoB,WACnC;AACI,WAAO,KAAK,MAAA;AACZ,SAAK,aAAa,KAAK,EAAE,QAAQ,WAAW,MAAM,CAAC,MAAM,SAAS,EAAA,CAAG;AAErE,SAAK,SAAS;AAEd,WAAO;EACX;EAcO,OAAO,MACd;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,OAAO,MAAM,KAAA,CAAM;AAEpD,SAAK,SAAS;AAEd,WAAO;EACX;EAaO,SAAS,MAChB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,SAAS,MAAM,KAAA,CAAM;AAEtD,SAAK,SAAS;AAEd,WAAO;EACX;EAgBO,YAAY,MACnB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,YAAY,MAAM,KAAA,CAAM;AAEzD,SAAK,SAAS;AAEd,WAAO;EACX;EAoBO,iBAAiB,MACxB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,iBAAiB,MAAM,KAAA,CAAM;AAE9D,SAAK,SAAS;AAEd,WAAO;EACX;;;;;;;;;;;;EAaO,mBAAmB,MAAc,MAAc,GAAW,GAAW,YAC5E;AACI,UAAM,OAAO,KAAK,aAAa,KAAK,aAAa,SAAS,CAAC;AAE3D,UAAM,YAAY,KAAK,aAAa,MAAM,MAAM;AAEhD,QAAI,OAAO;AACX,QAAI,OAAO;AAEX,QAAI,CAAC,QAAQ,KAAK,WAAW,iBAC7B;AACI,aAAO,UAAU;AACjB,aAAO,UAAU;IACrB,OAEA;AACI,aAAO,KAAK,KAAK,CAAC;AAClB,aAAO,KAAK,KAAK,CAAC;AAElB,YAAM,WAAW,UAAU;AAC3B,YAAM,WAAW,UAAU;AAE3B,aAAO,YAAY,WAAW;AAC9B,aAAO,YAAY,WAAW;IAClC;AAEA,SAAK,aAAa,KAAK,EAAE,QAAQ,iBAAiB,MAAM,CAAC,MAAM,MAAM,MAAM,MAAM,GAAG,GAAG,UAAU,EAAA,CAAG;AAEpG,SAAK,SAAS;AAEd,WAAO;EACX;;;;;;EAOO,YACP;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,aAAa,MAAM,CAAA,EAAA,CAAI;AAExD,SAAK,SAAS;AAEd,WAAO;EACX;EAaO,WAAW,MAClB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,WAAW,MAAM,KAAA,CAAM;AAIxD,SAAK,SAAS;AAEd,WAAO;EACX;EASO,UAAU,MACjB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,UAAU,MAAM,KAAA,CAAM;AAEvD,SAAK,SAAS;AAEd,WAAO;EACX;EASO,UAAU,MACjB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,UAAU,MAAM,KAAA,CAAM;AAEvD,WAAO;EACX;EAaO,oBAAoB,MAC3B;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,oBAAoB,MAAM,KAAA,CAAM;AAEjE,SAAK,SAAS;AAEd,WAAO;EACX;;;;;;;;EASO,sBAAsB,GAAW,GAAW,YACnD;AAEI,UAAM,OAAO,KAAK,aAAa,KAAK,aAAa,SAAS,CAAC;AAE3D,UAAM,YAAY,KAAK,aAAa,MAAM,MAAM;AAEhD,QAAI,OAAO;AACX,QAAI,OAAO;AAEX,QAAI,CAAC,QAAQ,KAAK,WAAW,oBAC7B;AACI,aAAO,UAAU;AACjB,aAAO,UAAU;IACrB,OAEA;AACI,aAAO,KAAK,KAAK,CAAC;AAClB,aAAO,KAAK,KAAK,CAAC;AAElB,YAAM,WAAW,UAAU;AAC3B,YAAM,WAAW,UAAU;AAE3B,aAAO,YAAY,WAAW;AAC9B,aAAO,YAAY,WAAW;IAClC;AAEA,SAAK,aAAa,KAAK,EAAE,QAAQ,oBAAoB,MAAM,CAAC,MAAM,MAAM,GAAG,GAAG,UAAU,EAAA,CAAG;AAE3F,SAAK,SAAS;AAEd,WAAO;EACX;;;;;;;;;;EAWO,KAAK,GAAW,GAAW,GAAW,GAAW,WACxD;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,QAAQ,MAAM,CAAC,GAAG,GAAG,GAAG,GAAG,SAAS,EAAA,CAAG;AAExE,SAAK,SAAS;AAEd,WAAO;EACX;;;;;;;;;EAUO,OAAO,GAAW,GAAW,QAAgB,WACpD;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,UAAU,MAAM,CAAC,GAAG,GAAG,QAAQ,SAAS,EAAA,CAAG;AAE5E,SAAK,SAAS;AAEd,WAAO;EACX;EAeO,aAAa,MACpB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,aAAa,MAAM,KAAA,CAAM;AAE1D,SAAK,SAAS;AAEd,WAAO;EACX;EAYO,QAAQ,MACf;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,QAAQ,MAAM,KAAA,CAAM;AAErD,SAAK,SAAS;AAEd,WAAO;EACX;EAaO,eAAe,MACtB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,eAAe,MAAM,KAAA,CAAM;AAE5D,SAAK,SAAS;AAEd,WAAO;EACX;EAcO,aAAa,MACpB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,aAAa,MAAM,KAAA,CAAM;AAE1D,SAAK,SAAS;AAEd,WAAO;EACX;EAgBO,cAAc,MACrB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,cAAc,MAAM,KAAA,CAAM;AAE3D,SAAK,SAAS;AAEd,WAAO;EACX;EAYO,cAAc,MACrB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,cAAc,MAAM,KAAA,CAAM;AAE3D,SAAK,SAAS;AAEd,WAAO;EACX;EAYO,eAAe,MACtB;AACI,SAAK,aAAa,KAAK,EAAE,QAAQ,eAAe,MAAM,KAAA,CAAM;AAE5D,SAAK,SAAS;AAEd,WAAO;EACX;;;;;;;;;;;;;;;;;;;;EAqBO,KAAK,GAAW,GAAW,QAAgB,QAAgB,aAAsB,UAAmB,WAC3G;AACI,oBAAA,cAAgB,SAAS;AAEzB,UAAM,aAAc,KAAK,KAAK,KAAK,IAAK;AACxC,UAAM,MAAM,SAAS;AACrB,UAAM,QAAS,KAAK,KAAK,IAAK;AAC9B,UAAM,UAAU,CAAA;AAEhB,aAAS,IAAI,GAAG,IAAI,KAAK,KACzB;AACI,YAAM,IAAI,IAAI,IAAI,cAAc;AAChC,YAAM,QAAS,IAAI,QAAS;AAE5B,cAAQ;QACJ,IAAK,IAAI,KAAK,IAAI,KAAK;QACvB,IAAK,IAAI,KAAK,IAAI,KAAK;MAAA;IAE/B;AAEA,SAAK,KAAK,SAAS,MAAM,SAAS;AAElC,WAAO;EACX;;;;;;;;;EAUO,MAAM,OAAO,OACpB;AACI,UAAM,oBAAoB,IAAI,cAAA;AAE9B,sBAAkB,gBAAgB,KAAK;AAEvC,QAAI,CAAC,MACL;AACI,wBAAkB,eAAe,KAAK,aAAa,MAAA;IACvD,OAEA;AACI,eAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAC9C;AACI,cAAM,cAAc,KAAK,aAAa,CAAC;AAEvC,0BAAkB,aAAa,KAAK,EAAE,QAAQ,YAAY,QAAQ,MAAM,YAAY,KAAK,MAAA,EAAM,CAAG;MACtG;IACJ;AAEA,WAAO;EACX;EAEO,QACP;AACI,SAAK,aAAa,SAAS;AAC3B,SAAK,SAAS;AAEd,WAAO;EACX;;;;;;;;;;;;;;;EAgBO,UAAU,QACjB;AACI,QAAI,OAAO,WAAA,EAAc,QAAO;AAEhC,UAAM,IAAI,OAAO;AACjB,UAAM,IAAI,OAAO;AACjB,UAAM,IAAI,OAAO;AACjB,UAAM,IAAI,OAAO;AACjB,UAAM,KAAK,OAAO;AAClB,UAAM,KAAK,OAAO;AAElB,QAAI,IAAI;AACR,QAAI,IAAI;AAER,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,OAAO;AAEX,QAAI,KAAK;AACT,QAAI,KAAK;AAET,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAC9C;AACI,YAAM,cAAc,KAAK,aAAa,CAAC;AACvC,YAAM,OAAO,YAAY;AAEzB,cAAQ,YAAY,QAAA;QAEhB,KAAK;QACL,KAAK;AAED,cAAI,KAAK,CAAC;AACV,cAAI,KAAK,CAAC;AAEV,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAC9B,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAC9B;QACJ,KAAK;AAED,iBAAO,KAAK,CAAC;AACb,iBAAO,KAAK,CAAC;AACb,iBAAO,KAAK,CAAC;AACb,iBAAO,KAAK,CAAC;AAEb,cAAI,KAAK,CAAC;AACV,cAAI,KAAK,CAAC;AAEV,eAAK,CAAC,IAAK,IAAI,OAAS,IAAI,OAAQ;AACpC,eAAK,CAAC,IAAK,IAAI,OAAS,IAAI,OAAQ;AACpC,eAAK,CAAC,IAAK,IAAI,OAAS,IAAI,OAAQ;AACpC,eAAK,CAAC,IAAK,IAAI,OAAS,IAAI,OAAQ;AACpC,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAC9B,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAC9B;QAEJ,KAAK;AAED,iBAAO,KAAK,CAAC;AACb,iBAAO,KAAK,CAAC;AAEb,cAAI,KAAK,CAAC;AACV,cAAI,KAAK,CAAC;AAEV,eAAK,CAAC,IAAK,IAAI,OAAS,IAAI,OAAQ;AACpC,eAAK,CAAC,IAAK,IAAI,OAAS,IAAI,OAAQ;AAEpC,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAC9B,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAE9B;QAEJ,KAAK;AAED,cAAI,KAAK,CAAC;AACV,cAAI,KAAK,CAAC;AAEV,eAAK,KAAK,CAAC;AACX,eAAK,KAAK,CAAC;AAIX,eAAK,CAAC,IAAK,IAAI,KAAO,IAAI;AAC1B,eAAK,CAAC,IAAK,IAAI,KAAO,IAAI;AAE1B,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAC9B,eAAK,CAAC,IAAK,IAAI,IAAM,IAAI,IAAK;AAE9B;QAEJ,KAAK;AACD,eAAK,CAAC,IAAI,gBAAgB,KAAK,CAAC,GAAG,MAAM;AACzC;QACJ,KAAK;AACD,eAAK,CAAC,IAAI,gBAAgB,KAAK,CAAC,GAAG,MAAM;AACzC;QACJ,KAAK;AACD,eAAK,CAAC,IAAI,gBAAgB,KAAK,CAAC,GAAG,MAAM;AACzC;QACJ,KAAK;AACD,eAAK,CAAC,IAAI,gBAAgB,KAAK,CAAC,GAAG,MAAM;AACzC;QACJ,KAAK;AACD,eAAK,CAAC,EAAE,UAAU,MAAM;AACxB;QACJ,KAAK;AACD,eAAK,CAAC,IAAI,gBAAgB,KAAK,CAAC,GAAG,MAAM;AACzC;QACJ;AAEI,eAAK,4BAA4B,YAAY,MAAM;AAEnD;MAAA;IAEZ;AAEA,SAAK,SAAS;AAEd,WAAO;EACX;EAEA,IAAI,SACJ;AACI,WAAO,KAAK,UAAU;EAC1B;;;;;;;;;;;;;;;EAgBO,aAAaC,MACpB;AACI,QAAI,QAAQ,KAAK,aAAa,SAAS;AAEvC,QAAI,kBAAkB,KAAK,aAAa,KAAK;AAE7C,QAAI,CAAC,iBACL;AACI,MAAAA,KAAI,IAAI;AACR,MAAAA,KAAI,IAAI;AAER,aAAOA;IACX;AAEA,WAAO,gBAAgB,WAAW,aAClC;AACI;AAEA,UAAI,QAAQ,GACZ;AACI,QAAAA,KAAI,IAAI;AACR,QAAAA,KAAI,IAAI;AAER,eAAOA;MACX;AAEA,wBAAkB,KAAK,aAAa,KAAK;IAC7C;AAEA,YAAQ,gBAAgB,QAAA;MAEpB,KAAK;MACL,KAAK;AACD,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B;MACJ,KAAK;AACD,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B;MACJ,KAAK;AACD,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B;MACJ,KAAK;MACL,KAAK;AACD,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B,QAAAA,KAAI,IAAI,gBAAgB,KAAK,CAAC;AAC9B;MACJ,KAAK;AAED,wBAAgB,KAAK,CAAC,EAAE,aAAaA,IAAG;AACxC;IAAA;AAGR,WAAOA;EACX;AACJ;AAEA,SAAS,gBAAgB,eAAwB,WACjD;AACI,MAAI,eACJ;AACI,WAAO,cAAc,QAAQ,SAAS;EAC1C;AAEA,SAAO,UAAU,MAAA;AACrB;;;AC/0BO,SAAS,uBAAuB,KAAiB,IAAY,cACpE;AACI,QAAM,QAAQ,IAAI,aAAa,EAAE;AAEjC,SAAO,QAAQ,OAAO,KAAK,IAAI;AACnC;;;ACLO,SAAS,oBAAoB,KAAiB,SACrD;AAEI,QAAM,cAAc,IAAI,iBAAiB,MAAM;AAG/C,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KACxC;AACI,UAAM,aAAa,YAAY,CAAC;AAGhC,aAAS,IAAI,GAAG,IAAI,WAAW,SAAS,QAAQ,KAChD;AACI,YAAM,QAAQ,WAAW,SAAS,CAAC;AAGnC,cAAQ,MAAM,SAAS,YAAA,GAAY;QAE/B,KAAK;AAED,kBAAQ,KAAK,MAAM,EAAE,IAAI,oBAAoB,KAAmB;AAChE;QACJ,KAAK;AACD,kBAAQ,KAAK,MAAM,EAAE,IAAI,oBAAoB,KAAmB;AAChE;QACJ;AACI;MAAA;IAEZ;EACJ;AACJ;AAOA,SAAS,oBAAoB,OAC7B;AAEI,QAAM,KAAK,uBAAuB,OAAO,MAAM,CAAC;AAChD,QAAM,KAAK,uBAAuB,OAAO,MAAM,CAAC;AAChD,QAAM,KAAK,uBAAuB,OAAO,MAAM,CAAC;AAChD,QAAM,KAAK,uBAAuB,OAAO,MAAM,CAAC;AAGhD,QAAM,eAAe,MAAM,aAAa,eAAe,KAAK;AAG5D,QAAM,WAAW,IAAI;IACjB;IACA;IACA;IACA;IACA,iBAAiB,sBAAsB,UAAU;EAAA;AAIrD,WAAS,IAAI,GAAG,IAAI,MAAM,SAAS,QAAQ,KAC3C;AACI,UAAM,OAAO,MAAM,SAAS,CAAC;AAG7B,UAAM,SAAS,uBAAuB,MAAM,UAAU,CAAC;AACvD,UAAM,QAAQ,MAAM,OAAO,SAAS,KAAK,aAAa,YAAY,CAAC,EAAE,SAAA;AAErE,aAAS,aAAa,QAAQ,KAAK;EACvC;AAEA,SAAO;AACX;AAQA,SAAS,oBAAoB,QAC7B;AAEI,OAAK,qDAAqD;AAG1D,SAAO,IAAI,aAAa,GAAG,GAAG,GAAG,CAAC;AACtC;;;AC7EO,SAAS,gBAAgB,KAChC;AAEI,QAAM,QAAQ,IAAI,MAAM,+CAA+C;AAEvE,SAAO,QAAQ,MAAM,CAAC,IAAI;AAC9B;;;ACbO,IAAM,kBAAkB;;EAE3B,MAAM,EAAE,MAAM,SAAS,SAAS,EAAA;;EAChC,gBAAgB,EAAE,MAAM,UAAU,SAAS,EAAA;;;EAG3C,QAAQ,EAAE,MAAM,SAAS,SAAS,EAAA;;EAClC,gBAAgB,EAAE,MAAM,UAAU,SAAS,EAAA;;EAC3C,kBAAkB,EAAE,MAAM,UAAU,SAAS,EAAA;;EAC7C,kBAAkB,EAAE,MAAM,UAAU,SAAS,OAAA;;EAC7C,mBAAmB,EAAE,MAAM,UAAU,SAAS,QAAA;;EAC9C,qBAAqB,EAAE,MAAM,UAAU,SAAS,GAAA;;EAChD,oBAAoB,EAAE,MAAM,UAAU,SAAS,OAAA;;EAC/C,qBAAqB,EAAE,MAAM,UAAU,SAAS,EAAA;;;EAGhD,SAAS,EAAE,MAAM,UAAU,SAAS,EAAA;;AACxC;AAyBO,SAAS,cAAc,KAAiB,SAC/C;AACI,QAAM,QAAQ,IAAI,aAAa,OAAO;AAEtC,QAAM,cAA2B,CAAA;AAEjC,QAAM,YAAuB,CAAA;AAE7B,QAAM,SAAsB;IACxB;IACA;IACA,SAAS;IACT,WAAW;EAAA;AAIf,aAAW,OAAO,iBAClB;AACI,UAAM,YAAY,IAAI,aAAa,GAAG;AAEtC,QAAI,WACJ;AACI,qBAAe,SAAS,QAAQ,KAAK,UAAU,KAAA,CAAM;IACzD;EACJ;AAGA,MAAI,OACJ;AACI,UAAM,aAAa,MAAM,MAAM,GAAG;AAElC,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KACvC;AACI,YAAM,YAAY,WAAW,CAAC,EAAE,KAAA;AAEhC,YAAM,CAAC,KAAK,KAAK,IAAI,UAAU,MAAM,GAAG;AAExC,UAAI,gBAAgB,GAAmC,GACvD;AACI,uBAAe,SAAS,QAAQ,KAAK,MAAM,KAAA,CAAM;MACrD;IACJ;EACJ;AAEA,SAAO;IACH,aAAa,OAAO,YAAa,cAAuC;IACxE,WAAW,OAAO,UAAW,YAAmC;IAChE,SAAS,OAAO;IAChB,WAAW,OAAO;EAAA;AAE1B;AAUA,SAAS,eACL,SACA,QACA,IACA,OAEJ;AACI,UAAQ,IAAA;IAEJ,KAAK;AACD,UAAI,UAAU,QACd;AACI,YAAI,MAAM,WAAW,MAAM,GAC3B;AAEI,gBAAMC,MAAK,gBAAgB,KAAK;AAEhC,iBAAO,YAAY,OAAO,QAAQ,KAAKA,GAAE;QAC7C,OAEA;AAEI,iBAAO,YAAY,QAAQ,MAAM,OAAO,SAAS,KAAK,EAAE,SAAA;QAC5D;AAEA,eAAO,YAAY;MACvB;AAEA;IACJ,KAAK;AACD,aAAO,YAAY,QAAQ,OAAO,KAAK;AACvC;IACJ,KAAK;AACD,UAAI,UAAU,QACd;AACI,YAAI,MAAM,WAAW,MAAM,GAC3B;AAEI,gBAAMA,MAAK,gBAAgB,KAAK;AAEhC,iBAAO,UAAU,OAAO,QAAQ,KAAKA,GAAE;QAC3C,OAEA;AAEI,iBAAO,UAAU,QAAQ,MAAM,OAAO,SAAS,KAAK,EAAE,SAAA;QAC1D;AAEA,eAAO,UAAU;MACrB;AACA;IACJ,KAAK;AACD,aAAO,UAAU,QAAQ,OAAO,KAAK;AACrC;IACJ,KAAK;AACD,aAAO,YAAY,QAAQ,OAAO,KAAK;AACvC;IACJ,KAAK;AAED,aAAO,UAAU,QAAQ,OAAO,KAAK;AACrC,aAAO,YAAY,QAAQ,OAAO,KAAK;AACvC;EAAA;AAEZ;;;ACzKO,SAAS,sBAAsB,kBACtC;AACI,MAAI,iBAAiB,UAAU,GAC/B;AACI,WAAO;EACX;AAEA,QAAM,QAAQ,iBAAiB,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAEtE,QAAM,CAAC,aAAa,UAAU,IAAI;AAClC,QAAM,eAAe,MAAM,MAAM,SAAS,CAAC;AAE3C,QAAM,uBAAuB,cAAc;AAC3C,QAAM,wBAAwB,aAAa;AAK3C,MAAI,uBAAuB,KAAK,wBAAwB,GACxD;AACI,WAAO;EACX;AAEA,SAAO;AACX;AAUO,SAAS,uBAAuB,SAA0B,QAAgB,GACjF;AACI,QAAM,cAAc,QAAQ,aAAa,KAAK;AAE9C,MAAI,CAAC,eAAe,YAAY,WAAW,QAC3C;AACI,UAAM,IAAI,MAAM,sCAAsC,KAAK,UAAS,2CAAa,WAAU,WAAW,EAAE;EAC5G;AAEA,SAAQ,YAAgC;AAC5C;;;AC/CO,SAAS,gBAAgB,UAChC;AAEI,QAAM,QAAQ,SAAS,MAAM,UAAU;AACvC,QAAM,WAAW,MAAM,OAAO,CAAC,SAAS,KAAK,KAAA,EAAO,SAAS,CAAC;AAE9D,SAAO;AACX;AAQO,SAAS,kBAAkB,UAClC;AACI,QAAM,SAAS,SAAS,MAAM,uBAAuB;AAErD,MAAI,CAAC,UAAU,OAAO,SAAS,EAAG,QAAO;AAEzC,QAAM,UAAU,OAAO,IAAI,MAAM;AACjC,QAAM,KAAK,CAAA;AACX,QAAM,KAAK,CAAA;AAEX,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK,GACzC;AACI,QAAI,IAAI,IAAI,QAAQ,QACpB;AACI,SAAG,KAAK,QAAQ,CAAC,CAAC;AAClB,SAAG,KAAK,QAAQ,IAAI,CAAC,CAAC;IAC1B;EACJ;AAEA,MAAI,GAAG,WAAW,KAAK,GAAG,WAAW,EAAG,QAAO;AAE/C,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAE3B,QAAM,QAAQ,OAAO,SAAS,OAAO;AAErC,SAAO;AACX;AAQO,SAAS,cAAc,UAAkB,cAChD;AACI,QAAM,WAAW,IAAI,aAAa,UAAU,KAAK;AAEjD,aAAW,eAAe,SAAS,cACnC;AACI,iBAAa,aAAa,KAAK,WAAW;EAC9C;AACJ;;;AChCO,SAAS,UACZ,KACA,iBAEJ;AAEI,MAAI,OAAO,QAAQ,UACnB;AAEI,UAAM,MAAM,SAAS,cAAc,KAAK;AAExC,QAAI,YAAY,IAAI,KAAA;AACpB,UAAM,IAAI,cAAc,KAAK;EACjC;AAGA,QAAM,UAAU;IACZ,SAAS;IACT,MAAM,CAAA;IACN,MAAM,IAAI,aAAA;EAAa;AAI3B,sBAAoB,KAAK,OAAO;AAGhC,QAAM,WAAW,IAAI;AAErB,QAAM,EAAE,WAAW,YAAA,IAAgB,cAAc,KAAK,OAAO;AAE7D,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KACrC;AACI,UAAM,QAAQ,SAAS,CAAC;AAExB,QAAI,MAAM,SAAS,YAAA,MAAkB,OAAQ;AAC7C,mBAAe,OAAO,SAAS,WAAW,WAAW;EACzD;AAEA,SAAO;AACX;AAUA,SAAS,eAAe,KAAiB,SAAkB,WAAsB,aACjF;AACI,QAAM,WAAW,IAAI;AAGrB,QAAM,EAAE,WAAW,IAAI,aAAa,GAAA,IAAO,cAAc,KAAK,OAAO;AAErE,MAAI,MAAM,WACV;AACI,gBAAY,EAAE,GAAG,WAAW,GAAG,GAAA;EACnC,WACS,IACT;AACI,gBAAY;EAChB;AAEA,MAAI,MAAM,aACV;AACI,kBAAc,EAAE,GAAG,aAAa,GAAG,GAAA;EACvC,WACS,IACT;AACI,kBAAc;EAClB;AAEA,QAAM,UAAU,CAAC,aAAa,CAAC;AAG/B,MAAI,SACJ;AACI,gBAAY,EAAE,OAAO,EAAA;EACzB;AAGA,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAGJ,UAAQ,IAAI,SAAS,YAAA,GAAY;IAE7B,KAAK,QACL;AACI,UAAI,IAAI,aAAa,GAAG;AAExB,YAAM,WAAW,IAAI,aAAa,WAAW;AAE7C,YAAM,WAAW,gBAAgB,CAAC;AAClC,YAAM,qBAAqB,aAAa;AACxC,YAAM,sBAAsB,SAAS,SAAS;AAE9C,YAAM,qBAAqB,sBAAsB;AAEjD,UAAI,oBACJ;AACI,cAAM,mBAAmB,SAAS,IAAI,CAAC,aAAa;UAChD,MAAM;UACN,MAAM,kBAAkB,OAAO;QAAA,EACjC;AAEF,yBAAiB,KAAK,CAAC,GAAG,MAAM,EAAE,OAAO,EAAE,IAAI;AAG/C,cAAM,2BAA2B,SAAS,SAAS,KAAK,CAAC,sBAAsB,gBAAgB;AAE/F,YAAI,0BACJ;AAEI,mBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAC7C;AACI,kBAAM,UAAU,iBAAiB,CAAC;AAClC,kBAAM,cAAc,MAAM;AAE1B,oBAAQ,QAAQ,UAAA;AAChB,kBAAM,UAAU,IAAI,aAAa,QAAW,IAAI;AAEhD,0BAAc,QAAQ,MAAM,OAAO;AACnC,oBAAQ,QAAQ,KAAK,OAAO;AAE5B,gBAAI,aACJ;AACI,kBAAI,UAAW,SAAQ,QAAQ,KAAK,SAAS;AAC7C,kBAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;YACvD,OAEA;AACI,sBAAQ,QAAQ,IAAA;YACpB;UACJ;QACJ,OAEA;AAEI,mBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAC7C;AACI,kBAAM,UAAU,iBAAiB,CAAC;AAClC,kBAAM,SAAS,IAAI,MAAM;AAEzB,oBAAQ,QAAQ,UAAA;AAChB,kBAAM,UAAU,IAAI,aAAa,QAAW,IAAI;AAEhD,0BAAc,QAAQ,MAAM,OAAO;AACnC,oBAAQ,QAAQ,KAAK,OAAO;AAE5B,gBAAI,QACJ;AACI,sBAAQ,QAAQ,IAAA;YACpB,OAEA;AACI,kBAAI,UAAW,SAAQ,QAAQ,KAAK,SAAS;AAC7C,kBAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;YACvD;UACJ;QACJ;MACJ,OAEA;AACI,cAAM,4BAA4B,WAAY,aAAa,YAAa;AAExE,uBAAe,IAAI,aAAa,GAAG,yBAAyB;AAC5D,gBAAQ,QAAQ,KAAK,YAAY;AACjC,YAAI,UAAW,SAAQ,QAAQ,KAAK,SAAS;AAC7C,YAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;MACvD;AACA;IACJ;IAEA,KAAK;AACD,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,UAAI,uBAAuB,KAAK,KAAK,CAAC;AACtC,cAAQ,QAAQ,QAAQ,IAAI,IAAI,GAAG,CAAC;AACpC,UAAI,UAAW,SAAQ,QAAQ,KAAK,SAAS;AAC7C,UAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;AACnD;IAEJ,KAAK;AACD,UAAI,uBAAuB,KAAK,KAAK,CAAC;AACtC,UAAI,uBAAuB,KAAK,KAAK,CAAC;AACtC,cAAQ,uBAAuB,KAAK,SAAS,CAAC;AAC9C,eAAS,uBAAuB,KAAK,UAAU,CAAC;AAChD,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AAExC,UAAI,MAAM,IACV;AACI,gBAAQ,QAAQ,UAAU,GAAG,GAAG,OAAO,QAAQ,MAAM,EAAE;MAC3D,OAEA;AACI,gBAAQ,QAAQ,KAAK,GAAG,GAAG,OAAO,MAAM;MAC5C;AAEA,UAAI,UAAW,SAAQ,QAAQ,KAAK,SAAS;AAC7C,UAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;AACnD;IAEJ,KAAK;AACD,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AAExC,cAAQ,QAAQ,UAAA;AAChB,cAAQ,QAAQ,QAAQ,IAAI,IAAI,IAAI,EAAE;AAEtC,UAAI,UAAW,SAAQ,QAAQ,KAAK,SAAS;AAC7C,UAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;AACnD;IAEJ,KAAK;AACD,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AACxC,WAAK,uBAAuB,KAAK,MAAM,CAAC;AAExC,cAAQ,QAAQ,UAAA;AAChB,cAAQ,QAAQ,OAAO,IAAI,EAAE;AAC7B,cAAQ,QAAQ,OAAO,IAAI,EAAE;AAE7B,UAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;AACnD;IAEJ,KAAK;AACD,qBAAe,IAAI,aAAa,QAAQ;AACxC,eAAS,aAAa,MAAM,QAAQ,EAAE,IAAI,CAAC,MAAM,SAAS,GAAG,EAAE,CAAC;AAChE,cAAQ,QAAQ,KAAK,QAAQ,IAAI;AACjC,UAAI,UAAW,SAAQ,QAAQ,KAAK,SAAS;AAC7C,UAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;AACnD;IAEJ,KAAK;AACD,qBAAe,IAAI,aAAa,QAAQ;AACxC,eAAS,aAAa,MAAM,QAAQ,EAAE,IAAI,CAAC,MAAM,SAAS,GAAG,EAAE,CAAC;AAChE,cAAQ,QAAQ,KAAK,QAAQ,KAAK;AAClC,UAAI,YAAa,SAAQ,QAAQ,OAAO,WAAW;AACnD;IAGJ,KAAK;IACL,KAAK;AACD;IAEJ,SAAS;AAEL,WAAK,iBAAiB,IAAI,QAAQ,wBAAwB;AAC1D;IACJ;EAAA;AAGJ,MAAI,SACJ;AACI,gBAAY;EAChB;AAGA,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KACrC;AACI,mBAAe,SAAS,CAAC,GAAiB,SAAS,WAAW,WAAW;EAC7E;AACJ;;;AClTA,SAAS,YAAY,OACrB;AACI,SAAO,MAAM,YAAY,KAAoB;AACjD;AAEA,SAAS,cAAc,OACvB;AACI,SAAO,iBAAiB;AAC5B;AAEA,SAAS,eAAe,OACxB;AACI,SAAO,iBAAiB;AAC5B;AAEA,SAAS,UAAU,OACnB;AACI,SAAO,iBAAiB;AAC5B;AAYA,SAAS,gBACL,MACA,OACA,cAEJ;AACI,QAAM,OAAO,MAAM,OAAO,SAAS,SAAS,CAAC;AAE7C,OAAK,QAAQ,KAAK,SAAA;AAClB,OAAK,QAAQ,KAAK,UAAU,IAAI,aAAa,QAAQ,KAAK;AAC1D,OAAK,UAAU,QAAQ;AAEvB,SAAO,EAAE,GAAG,cAAc,GAAG,KAAA;AACjC;AAUA,SAAS,cAAc,MAAiB,OAAgB,cACxD;AACI,OAAK,UAAU;AAEf,SAAO,EAAE,GAAG,cAAc,GAAG,KAAA;AACjC;AAUA,SAAS,kBACL,MACA,OACA,cAEJ;AACI,OAAK,OAAO;AACZ,OAAK,QAAQ;AACb,OAAK,UAAU,MAAM;AACrB,OAAK,SAAS,MAAM;AAEpB,SAAO,EAAE,GAAG,cAAc,GAAG,KAAA;AACjC;AAUA,SAAS,mBACL,MACA,OACA,cAEJ;AACI,QAAM,cAAA;AACN,OAAK,OAAO;AACZ,OAAK,QAAQ;AACb,OAAK,UAAU,MAAM;AACrB,OAAK,SAAS,MAAM;AACpB,OAAK,eAAe,MAAM;AAE1B,SAAO,EAAE,GAAG,cAAc,GAAG,KAAA;AACjC;AAeA,SAAS,iBAAiB,OAAkB,cAC5C;AACI,QAAM,QAAQ,EAAE,GAAG,cAAc,GAAI,MAAA;AAErC,QAAM,QAAQ,MAAM,OAAO,SAAS,MAAM,KAAK;AAE/C,QAAM,SAAS,MAAM;AACrB,QAAM,QAAQ,MAAM,SAAA;AAEpB,SAAO;AACX;AAWO,SAAS,YACZ,OACA,cAEJ;AACI,MAAI,UAAU,UAAa,UAAU,MACrC;AACI,WAAO;EACX;AAEA,QAAM,OAA2B,CAAA;AACjC,QAAM,cAAc;AAEpB,MAAI,YAAY,KAAK,GACrB;AACI,WAAO,gBAAgB,MAAM,OAAO,YAAY;EACpD,WACS,UAAU,KAAK,GACxB;AACI,WAAO,cAAc,MAAM,OAAO,YAAY;EAClD,WACS,cAAc,KAAK,GAC5B;AACI,WAAO,kBAAkB,MAAM,OAAO,YAAY;EACtD,WACS,eAAe,KAAK,GAC7B;AACI,WAAO,mBAAmB,MAAM,OAAO,YAAY;EACvD,WACS,YAAY,QAAQ,cAAc,YAAY,IAAI,GAC3D;AACI,WAAO,kBAAkB,aAAa,YAAY,MAAM,YAAY;EACxE,WACS,YAAY,QAAQ,eAAe,YAAY,IAAI,GAC5D;AACI,WAAO,mBAAmB,aAAa,YAAY,MAAM,YAAY;EACzE;AAEA,SAAO,iBAAiB,aAAa,YAAY;AACrD;AAQO,SAAS,cAAc,OAAoB,cAClD;AACI,QAAM,EAAE,OAAO,WAAW,YAAY,KAAK,MAAM,WAAW,GAAG,KAAA,IAAS;AACxE,QAAM,OAAO,YAAY,OAAO,IAAI;AAEpC,MAAI,CAAC,MACL;AACI,WAAO;EACX;AAEA,SAAO;IACH;IACA;IACA;IACA;IACA;IACA;IACA,GAAG;EAAA;AAEX;;;ACvMA,IAAM,WAAW,IAAI,MAAA;AAkDrB,IAAM,aAAa,IAAI,OAAA;AAWhB,IAAM,mBAAN,MAAMC,0BAAwB,sBAKrC;EALO,cAAA;AAAA,UAAA,GAAA,SAAA;AAOH,SAAO,WAAwD,uBAAO,OAAO,IAAI;AAIjF,SAAO,qBAAqB;AAE5B,SAAO,cAAc;AAkDrB,SAAgB,MAAc,IAAI,iBAAiB;AAKnD,SAAO,QAAQ;AAEf,SAAO,YAAuB;AAE9B,SAAO,eAAuC,CAAA;AAQ9C,SAAO,YAAY;AAEnB,SAAQ,cAA4B,IAAI,aAAA;AACxC,SAAQ,aAAqB,IAAI,OAAA;AAEjC,SAAQ,aAAiC,EAAE,GAAGA,kBAAgB,iBAAA;AAC9D,SAAQ,eAAqC,EAAE,GAAGA,kBAAgB,mBAAA;AAClE,SAAQ,cAAyG,CAAA;AAEjH,SAAQ,QAAQ;AAEhB,SAAQ,UAAU,IAAI,OAAA;AACtB,SAAQ,eAAe;EAAA;;;;;;EAOhB,QACP;AACI,UAAM,QAAQ,IAAIA,kBAAA;AAElB,UAAM,YAAY,KAAK;AACvB,UAAM,eAAe,KAAK,aAAa,MAAA;AACvC,UAAM,cAAc,KAAK,YAAY,MAAA;AACrC,UAAM,aAAa,KAAK,WAAW,MAAA;AACnC,UAAM,aAAa,EAAE,GAAG,KAAK,WAAA;AAC7B,UAAM,eAAe,EAAE,GAAG,KAAK,aAAA;AAC/B,UAAM,cAAc,KAAK,YAAY,MAAA;AACrC,UAAM,UAAU,KAAK,QAAQ,MAAA;AAC7B,UAAM,eAAe;AAErB,WAAO;EACX;;;;EAKA,IAAI,YACJ;AACI,WAAO,KAAK;EAChB;EAEA,IAAI,UAAU,OACd;AACI,SAAK,aAAa,YAAY,OAAOA,kBAAgB,gBAAgB;EACzE;;;;EAKA,IAAI,cACJ;AACI,WAAO,KAAK;EAChB;EAEA,IAAI,YAAY,OAChB;AACI,SAAK,eAAe,cAAc,OAAOA,kBAAgB,kBAAkB;EAC/E;;;;;;;;EASO,aAAa,OACpB;AACI,SAAK,aAAa,YAAY,OAAOA,kBAAgB,gBAAgB;AAErE,WAAO;EACX;;;;;;;;EASO,eAAe,OACtB;AACI,SAAK,eAAe,YAAY,OAAOA,kBAAgB,kBAAkB;AAEzE,WAAO;EACX;EA0BO,QAAQ,SAAkB,MAAoB,IAAa,IAAa,IAAa,IAC5F;AACI,SAAK,aAAa,KAAK;MACnB,QAAQ;MACR,MAAM;QACF,OAAO;QAEP,IAAI,MAAM;QACV,IAAI,MAAM;QAEV,IAAI,MAAM,QAAQ,MAAM;QACxB,IAAI,MAAM,QAAQ,MAAM;QAExB,WAAW,KAAK,WAAW,MAAA;QAC3B,OAAO,KAAK,WAAW;QACvB,OAAQ,QAAQ,SAAS,IAAK,MAAM,OAAO,SAAS,IAAI,EAAE,SAAA,IAAa;MAAA;IAC3E,CACH;AAED,SAAK,SAAA;AAEL,WAAO;EACX;;;;;;EAOO,YACP;AACI,SAAK,cAAc,IAAI,aAAA;AAEvB,WAAO;EACX;EAWO,KAAK,OAAmB,OAC/B;AACI,QAAI;AAEJ,UAAM,kBAAkB,KAAK,aAAa,KAAK,aAAa,SAAS,CAAC;AAEtE,QAAI,KAAK,UAAU,MAAK,mDAAiB,YAAW,UACpD;AACI,aAAO,gBAAgB,KAAK;IAChC,OAEA;AACI,aAAO,KAAK,YAAY,MAAA;IAC5B;AAEA,QAAI,CAAC,KAAM,QAAO;AAGlB,QAAI,SAAS,MACb;AACI,UAAI,UAAU,UAAa,OAAO,UAAU,UAC5C;AAEI,oBAAY,QAAQ,sGAAsG;AAG1H,gBAAQ,EAAE,OAAO,OAAO,MAAA;MAC5B;AACA,WAAK,aAAa,YAAY,OAAOA,kBAAgB,gBAAgB;IACzE;AAGA,SAAK,aAAa,KAAK;MACnB,QAAQ;;MAER,MAAM,EAAE,OAAO,KAAK,WAAW,KAAA;IAAK,CACvC;AAED,SAAK,SAAA;AAEL,SAAK,sBAAA;AACL,SAAK,QAAQ;AAEb,WAAO;EACX;EAEQ,wBACR;AAEI,UAAM,EAAE,GAAG,EAAA,IAAM,KAAK,YAAY,aAAa,MAAM,MAAM;AAE3D,SAAK,YAAY,MAAA;AACjB,SAAK,YAAY,OAAO,GAAG,CAAC;EAChC;;;;;;;EAQO,OAAO,OACd;AACI,QAAI;AAEJ,UAAM,kBAAkB,KAAK,aAAa,KAAK,aAAa,SAAS,CAAC;AAEtE,QAAI,KAAK,UAAU,MAAK,mDAAiB,YAAW,QACpD;AACI,aAAO,gBAAgB,KAAK;IAChC,OAEA;AACI,aAAO,KAAK,YAAY,MAAA;IAC5B;AAEA,QAAI,CAAC,KAAM,QAAO;AAGlB,QAAI,SAAS,MACb;AACI,WAAK,eAAe,cAAc,OAAOA,kBAAgB,kBAAkB;IAC/E;AAGA,SAAK,aAAa,KAAK;MACnB,QAAQ;;MAER,MAAM,EAAE,OAAO,KAAK,aAAa,KAAA;IAAK,CACzC;AAED,SAAK,SAAA;AAEL,SAAK,sBAAA;AACL,SAAK,QAAQ;AAEb,WAAO;EACX;;;;;;;EAQO,MACP;AACI,aAAS,IAAI,GAAG,IAAI,GAAG,KACvB;AACI,YAAM,kBAAkB,KAAK,aAAa,KAAK,aAAa,SAAS,IAAI,CAAC;AAE1E,YAAM,WAAW,KAAK,YAAY,MAAA;AAElC,UAAI,iBACJ;AACI,YAAI,gBAAgB,WAAW,YAAY,gBAAgB,WAAW,QACtE;AACI,cAAI,gBAAgB,KAAK,MACzB;AACI,4BAAgB,KAAK,KAAK,QAAQ,QAAQ;UAC9C,OAEA;AACI,4BAAgB,KAAK,OAAO;AAC5B;UACJ;QACJ;MACJ;IACJ;AAEA,SAAK,sBAAA;AAEL,WAAO;EACX;;;;;;;;;;;;EAaO,IAAI,GAAW,GAAW,QAAgB,YAAoB,UAAkB,kBACvF;AACI,SAAK;AAEL,UAAM,IAAI,KAAK;AAEf,SAAK,YAAY;MACZ,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MACzB,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MAC1B;MACA;MACA;MACA;IAAA;AAGJ,WAAO;EACX;;;;;;;;;;;EAYO,MAAM,IAAY,IAAY,IAAY,IAAY,QAC7D;AACI,SAAK;AAEL,UAAM,IAAI,KAAK;AAEf,SAAK,YAAY;MACZ,EAAE,IAAI,KAAO,EAAE,IAAI,KAAM,EAAE;MAC3B,EAAE,IAAI,KAAO,EAAE,IAAI,KAAM,EAAE;MAC3B,EAAE,IAAI,KAAO,EAAE,IAAI,KAAM,EAAE;MAC3B,EAAE,IAAI,KAAO,EAAE,IAAI,KAAM,EAAE;MAC5B;IAAA;AAGJ,WAAO;EACX;;;;;;;;;;;;;EAcO,SACH,IAAY,IACZ,eACA,cACA,WACA,GAAW,GAEf;AACI,SAAK;AAEL,UAAM,IAAI,KAAK;AAEf,SAAK,YAAY;MACb;MAAI;MACJ;;MACA;MACA;MACC,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MACzB,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;IAAA;AAG9B,WAAO;EACX;;;;;;;;;;;;;;EAeO,cAAc,MAAc,MAAc,MAAc,MAAc,GAAW,GAAW,YACnG;AACI,SAAK;AAGL,UAAM,IAAI,KAAK;AAEf,SAAK,YAAY;MACZ,EAAE,IAAI,OAAS,EAAE,IAAI,OAAQ,EAAE;MAC/B,EAAE,IAAI,OAAS,EAAE,IAAI,OAAQ,EAAE;MAC/B,EAAE,IAAI,OAAS,EAAE,IAAI,OAAQ,EAAE;MAC/B,EAAE,IAAI,OAAS,EAAE,IAAI,OAAQ,EAAE;MAC/B,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MACzB,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MAC1B;IAAA;AAGJ,WAAO;EACX;;;;;;EAOO,YACP;;AACI,SAAK;AAEL,eAAK,gBAAL,mBAAkB;AAElB,WAAO;EACX;;;;;;;;;;EAWO,QAAQ,GAAW,GAAW,SAAiB,SACtD;AACI,SAAK;AAEL,SAAK,YAAY,QAAQ,GAAG,GAAG,SAAS,SAAS,KAAK,WAAW,MAAA,CAAO;AAExE,WAAO;EACX;;;;;;;;EASO,OAAO,GAAW,GAAW,QACpC;AACI,SAAK;AAEL,SAAK,YAAY,OAAO,GAAG,GAAG,QAAQ,KAAK,WAAW,MAAA,CAAO;AAE7D,WAAO;EACX;;;;;;EAOO,KAAK,MACZ;AACI,SAAK;AAEL,SAAK,YAAY,QAAQ,MAAM,KAAK,WAAW,MAAA,CAAO;AAEtD,WAAO;EACX;;;;;;;EAQO,OAAO,GAAW,GACzB;AACI,SAAK;AAEL,UAAM,IAAI,KAAK;AAEf,SAAK,YAAY;MACZ,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MACzB,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;IAAA;AAG9B,WAAO;EACX;;;;;;;EAQO,OAAO,GAAW,GACzB;AACI,SAAK;AAEL,UAAM,IAAI,KAAK;AAEf,UAAM,eAAe,KAAK,YAAY;AAEtC,UAAM,eAAgB,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;AAC/C,UAAM,eAAgB,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;AAE/C,QAAI,aAAa,WAAW,KAAK,aAAa,CAAC,EAAE,WAAW,UAC5D;AACI,mBAAa,CAAC,EAAE,KAAK,CAAC,IAAI;AAC1B,mBAAa,CAAC,EAAE,KAAK,CAAC,IAAI;AAE1B,aAAO;IACX;AACA,SAAK,YAAY;MACb;MACA;IAAA;AAGJ,WAAO;EACX;;;;;;;;;;;EAYO,iBAAiB,KAAa,KAAa,GAAW,GAAW,YACxE;AACI,SAAK;AAEL,UAAM,IAAI,KAAK;AAEf,SAAK,YAAY;MACZ,EAAE,IAAI,MAAQ,EAAE,IAAI,MAAO,EAAE;MAC7B,EAAE,IAAI,MAAQ,EAAE,IAAI,MAAO,EAAE;MAC7B,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MACzB,EAAE,IAAI,IAAM,EAAE,IAAI,IAAK,EAAE;MAC1B;IAAA;AAGJ,WAAO;EACX;;;;;;;;;EAUO,KAAK,GAAW,GAAW,GAAW,GAC7C;AACI,SAAK;AAEL,SAAK,YAAY,KAAK,GAAG,GAAG,GAAG,GAAG,KAAK,WAAW,MAAA,CAAO;AAEzD,WAAO;EACX;;;;;;;;;;;;EAaO,UAAU,GAAW,GAAW,GAAW,GAAW,QAC7D;AACI,SAAK;AAEL,SAAK,YAAY,UAAU,GAAG,GAAG,GAAG,GAAG,QAAQ,KAAK,WAAW,MAAA,CAAO;AAEtE,WAAO;EACX;;;;;;;;;EAUO,KAAK,QAAgC,OAC5C;AACI,SAAK;AAEL,SAAK,YAAY,KAAK,QAAQ,OAAO,KAAK,WAAW,MAAA,CAAO;AAE5D,WAAO;EACX;;;;;;;;;;;EAYO,YAAY,GAAW,GAAW,QAAgB,OAAe,WAAW,GAAG,WACtF;AACI,SAAK;AACL,SAAK,YAAY,YAAY,GAAG,GAAG,QAAQ,OAAO,UAAU,SAAS;AAErE,WAAO;EACX;;;;;;;;;;;;EAaO,UAAU,GAAW,GAAW,QAAgB,OAAe,QAAgB,UACtF;AACI,SAAK;AACL,SAAK,YAAY,UAAU,GAAG,GAAG,QAAQ,OAAO,QAAQ,QAAQ;AAEhE,WAAO;EACX;;;;;;;;;;;;;;EAeO,WAAW,QAAwB,QAAgB,cAAwB,YAClF;AACI,SAAK;AACL,SAAK,YAAY,WAAW,QAAQ,QAAQ,cAAc,UAAU;AAEpE,WAAO;EACX;;;;;;;;;;EAWO,WAAW,GAAW,GAAW,OAAe,QAAgB,QACvE;AACI,SAAK;AACL,SAAK,YAAY,WAAW,GAAG,GAAG,OAAO,QAAQ,MAAM;AAEvD,WAAO;EACX;;;;;;;;;;EAWO,YAAY,GAAW,GAAW,OAAe,QAAgB,SAAiB,WACzF;AACI,SAAK;AACL,SAAK,YAAY,YAAY,GAAG,GAAG,OAAO,QAAQ,SAAS,SAAS;AAEpE,WAAO;EACX;;;;;;;;;;;;;;;;;EAkBO,KAAK,GAAW,GAAW,QAAgB,QAAgB,cAAc,GAAG,WAAW,GAC9F;AACI,SAAK;AAEL,SAAK,YAAY,KAAK,GAAG,GAAG,QAAQ,QAAQ,aAAa,UAAU,KAAK,WAAW,MAAA,CAAO;AAE1F,WAAO;EACX;;;;;;EAOO,IAAI,KACX;AACI,SAAK;AAEL,cAAU,KAAK,IAAI;AAEnB,WAAO;EACX;;;;;EAMO,UACP;AACI,UAAM,QAAQ,KAAK,YAAY,IAAA;AAE/B,QAAI,OACJ;AACI,WAAK,aAAa,MAAM;AACxB,WAAK,aAAa,MAAM;AACxB,WAAK,eAAe,MAAM;IAC9B;AAEA,WAAO;EACX;;EAGO,OACP;AACI,SAAK,YAAY,KAAK;MAClB,WAAW,KAAK,WAAW,MAAA;MAC3B,WAAW,EAAE,GAAG,KAAK,WAAA;MACrB,aAAa,EAAE,GAAG,KAAK,aAAA;IAAa,CACvC;AAED,WAAO;EACX;;;;;EAMO,eACP;AACI,WAAO,KAAK;EAChB;;;;;EAMO,iBACP;AACI,SAAK,WAAW,SAAA;AAEhB,WAAO;EACX;;;;;;EAOO,OAAO,OACd;AACI,SAAK,WAAW,OAAO,KAAK;AAE5B,WAAO;EACX;;;;;;;EAQO,MAAM,GAAW,IAAY,GACpC;AACI,SAAK,WAAW,MAAM,GAAG,CAAC;AAE1B,WAAO;EACX;EAqBO,aAAa,GAAoB,GAAY,GAAY,GAAY,IAAa,IACzF;AACI,QAAI,aAAa,QACjB;AACI,WAAK,WAAW,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;AAElD,aAAO;IACX;AAEA,SAAK,WAAW,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE;AAEtC,WAAO;EACX;EAqBO,UAAU,GAAoB,GAAY,GAAY,GAAY,IAAa,IACtF;AACI,QAAI,aAAa,QACjB;AACI,WAAK,WAAW,OAAO,CAAC;AAExB,aAAO;IACX;AAEA,eAAW,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE;AACjC,SAAK,WAAW,OAAO,UAAU;AAEjC,WAAO;EACX;;;;;;;EAQO,UAAU,GAAW,IAAY,GACxC;AACI,SAAK,WAAW,UAAU,GAAG,CAAC;AAE9B,WAAO;EACX;;;;;;EAOO,QACP;AACI,SAAK,YAAY,MAAA;AACjB,SAAK,aAAa,SAAS;AAC3B,SAAK,eAAA;AAEL,SAAK,SAAA;AAEL,WAAO;EACX;EAEU,WACV;AAGI,SAAK,eAAe;AAIpB,QAAI,KAAK,MAAO;AAChB,SAAK,KAAK,UAAU,MAAM,EAAI;AAC9B,SAAK,QAAQ;EACjB;;EAGA,IAAI,SACJ;AACI,QAAI,CAAC,KAAK,aAAc,QAAO,KAAK;AAEpC,SAAK,eAAe;AAGpB,UAAM,SAAS,KAAK;AAEpB,WAAO,MAAA;AAEP,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAC9C;AACI,YAAM,cAAc,KAAK,aAAa,CAAC;AACvC,YAAM,SAAS,YAAY;AAE3B,UAAI,WAAW,QACf;AACI,cAAM,OAAO,YAAY;AAEzB,eAAO,UAAU,KAAK,KAAK,MAAM;MACrC,WACS,WAAW,WACpB;AACI,cAAM,OAAO,YAAY;AAEzB,eAAO,SAAS,KAAK,IAAI,KAAK,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,SAAS;MAC1F;AACA,UAAI,WAAW,UACf;AACI,cAAM,OAAO,YAAY;AAEzB,cAAM,YAAY,KAAK,MAAM;AAE7B,cAAM,eAAgB,KAAK,MAAM,SAAS,IAAI;AAE9C,cAAM,UAAU,KAAK,KAAK;AAE1B,eAAO;UACH,QAAQ,OAAO;UACf,QAAQ,OAAO;UACf,QAAQ,OAAO;UACf,QAAQ,OAAO;QAAA;MAEvB;IACJ;AAEA,WAAO;EACX;;;;;;EAOO,cAAc,OACrB;;AAEI,QAAI,CAAC,KAAK,OAAO,cAAc,MAAM,GAAG,MAAM,CAAC,EAAG,QAAO;AAEzD,UAAM,eAAe,KAAK;AAC1B,QAAI,SAAS;AAEb,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KACzC;AACI,YAAM,cAAc,aAAa,CAAC;AAElC,YAAM,OAAO,YAAY;AACzB,YAAM,OAAO,KAAK;AAElB,UAAI,CAAC,YAAY,UAAU,CAAC,KAAM;AAElC,YAAM,QAAQ,KAAK;AACnB,YAAM,SAAS,KAAK,UAAU;AAE9B,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AACI,cAAM,QAAQ,OAAO,CAAC,EAAE;AAExB,YAAI,CAAC,SAAS,CAAC,MAAO;AAEtB,cAAM,YAAY,OAAO,CAAC,EAAE;AAE5B,cAAM,mBAAmB,YAAY,UAAU,aAAa,OAAO,QAAQ,IAAI;AAE/E,YAAI,YAAY,WAAW,QAC3B;AACI,mBAAS,MAAM,SAAS,iBAAiB,GAAG,iBAAiB,CAAC;QAClE,OAEA;AACI,gBAAM,cAAe;AAErB,mBAAS,MAAM,eAAe,iBAAiB,GAAG,iBAAiB,GAAG,YAAY,OAAO,YAAY,SAAS;QAClH;AAEA,cAAM,QAAQ,KAAK;AAEnB,YAAI,OACJ;AACI,gBAAM,cAAa,WAAM,cAAN,mBAAiB;AAEpC,cAAI,YACJ;AACI,qBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KACvC;AACI,kBAAI,WAAW,CAAC,EAAE,MAAM,SAAS,iBAAiB,GAAG,iBAAiB,CAAC,GACvE;AACI,yBAAS;cACb;YACJ;UACJ;QACJ;AAEA,YAAI,QACJ;AACI,iBAAO;QACX;MACJ;IACJ;AAEA,WAAO;EACX;;EAGO,SACP;;AACI,SAAK,KAAK,UAAU,IAAI;AACxB,eAAW,OAAO,KAAK,UACvB;AACI,iBAAK,SAAS,GAAG,MAAjB,mBAAoB;IACxB;AACA,SAAK,WAAW,uBAAO,OAAO,IAAI;EACtC;;;;;;;;;;EAWO,QAAQ,UAA6C,OAC5D;AACI,QAAI,KAAK,UAAW;AACpB,SAAK,YAAY;AACjB,SAAK,YAAY,SAAS;AAC1B,SAAK,aAAa;AAElB,SAAK,OAAA;AACL,SAAK,KAAK,WAAW,IAAI;AACzB,SAAK,mBAAA;AAEL,UAAM,iBAAiB,OAAO,YAAY,YAAY,UAAU,mCAAS;AAEzE,QAAI,gBACJ;AACI,YAAM,uBAAuB,OAAO,YAAY,YAAY,UAAU,mCAAS;AAE/E,UAAI,KAAK,WAAW,SACpB;AACI,aAAK,WAAW,QAAQ,SAAS,KAAK,WAAW,OAC3C,KAAK,WAAW,KAAK,QAAA,IACrB,KAAK,WAAW,QAAQ,QAAQ,oBAAoB;MAC9D;AAEA,UAAI,KAAK,aAAa,SACtB;AACI,aAAK,aAAa,QAAQ,SAAS,KAAK,aAAa,OAC/C,KAAK,aAAa,KAAK,QAAA,IACvB,KAAK,aAAa,QAAQ,QAAQ,oBAAoB;MAChE;IACJ;AAEA,SAAK,aAAa;AAClB,SAAK,eAAe;AAEpB,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,SAAK,eAAe;AACpB,SAAK,aAAa;EACtB;AACJ;AA5qCa,iBAgBK,mBAAuC;;EAEjD,OAAO;;EAEP,OAAO;;EAEP,SAAS,QAAQ;;EAEjB,QAAQ;;EAER,MAAM;;EAEN,cAAc;AAClB;AA7BS,iBAgCK,qBAA2C;;EAErD,OAAO;;EAEP,OAAO;;EAEP,OAAO;;EAEP,WAAW;;EAEX,YAAY;;EAEZ,KAAK;;EAEL,MAAM;;EAEN,SAAS,QAAQ;;EAEjB,QAAQ;;EAER,MAAM;;EAEN,cAAc;;EAEd,WAAW;AACf;AAzDG,IAAM,kBAAN;",
  "names": ["parse", "_FillGradient", "y2", "x0", "y0", "x1", "x2", "y1", "out", "tempRect", "tempTextureMatrix", "generateTextureFillMatrix", "parse", "_GraphicsContextSystem", "RECURSION_LIMIT", "FLT_EPSILON", "PATH_DISTANCE_EPSILON", "curveAngleToleranceEpsilon", "mAngleTolerance", "begin", "recursive", "out", "out", "id", "_GraphicsContext"]
}
