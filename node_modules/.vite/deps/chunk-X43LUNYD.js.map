{
  "version": 3,
  "sources": ["../../pixi.js/src/assets/loader/parsers/LoaderParser.ts", "../../pixi.js/src/utils/path.ts", "../../pixi.js/src/assets/utils/createStringVariations.ts", "../../pixi.js/src/assets/utils/isSingleItem.ts", "../../pixi.js/src/assets/resolver/Resolver.ts", "../../pixi.js/src/assets/utils/copySearchParams.ts", "../../pixi.js/src/spritesheet/Spritesheet.ts", "../../pixi.js/src/spritesheet/spritesheetAsset.ts", "../../pixi.js/src/spritesheet/init.ts", "../../pixi.js/src/rendering/mask/utils/addMaskBounds.ts", "../../pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts", "../../pixi.js/src/rendering/mask/alpha/AlphaMask.ts", "../../pixi.js/src/rendering/mask/color/ColorMask.ts", "../../pixi.js/src/rendering/mask/stencil/StencilMask.ts", "../../pixi.js/src/utils/browser/detectVideoAlphaMode.ts", "../../pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts", "../../pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts", "../../pixi.js/src/rendering/init.ts", "../../pixi.js/src/filters/FilterPipe.ts", "../../pixi.js/lib/filters/defaults/defaultFilter.vert.mjs", "../../pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs", "../../pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs", "../../pixi.js/src/filters/defaults/passthrough/PassthroughFilter.ts", "../../pixi.js/src/maths/point/pointInTriangle.ts", "../../pixi.js/src/maths/shapes/Triangle.ts", "../../pixi.js/src/scene/container/bounds/getRenderableBounds.ts", "../../pixi.js/src/filters/FilterSystem.ts"],
  "sourcesContent": ["import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @category assets\n * @advanced\n */\nexport enum LoaderParserPriority\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately\n * @category assets\n * @advanced\n */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /**\n     * @deprecated Use `id` instead.\n     */\n    name?: string;\n    /** The name of the parser (this can be used when specifying parser in a ResolvedAsset) */\n    id: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @category assets\n * @advanced\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n", "import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @category utils\n * @advanced\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param baseUrl - The base URL to use\n     * @param rootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param paths - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * @example\n * ```ts\n * import { path } from 'pixi.js';\n *\n * // Basic path normalization\n * path.normalize('http://www.example.com/foo/bar/../baz');\n * // -> 'http://www.example.com/foo/baz'\n *\n * // Working with file paths\n * path.join('assets', 'images', 'sprite.png');\n * // -> 'assets/images/sprite.png'\n *\n * // URL handling\n * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n * // -> 'http://example.com/assets/images/texture.png'\n * ```\n * @remarks\n * - Normalizes to POSIX separators (forward slashes)\n * - Handles URLs, data URLs, and file paths\n * - Supports path composition and decomposition\n * - Common in asset loading and URL management\n * @category utils\n * @standard\n * @see {@link Path} For full API reference\n * @see {@link DOMAdapter} For platform-specific path handling\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     * @example\n     * ```ts\n     * // Convert a Windows path to POSIX format\n     * path.toPosix('C:\\\\Users\\\\User\\\\Documents\\\\file.txt');\n     * // -> 'C:/Users/User/Documents/file.txt'\n     * ```\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a URL\n     * path.isUrl('http://www.example.com');\n     * // -> true\n     * path.isUrl('C:/Users/User/Documents/file.txt');\n     * // -> false\n     * ```\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a data URL\n     * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');\n     * // -> true\n     * ```\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a blob URL\n     * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');\n     * // -> true\n     * ```\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path has a protocol\n     * path.hasProtocol('http://www.example.com');\n     * // -> true\n     * path.hasProtocol('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     * @example\n     * ```ts\n     * // Get the protocol from a URL\n     * path.getProtocol('http://www.example.com/path/to/resource');\n     * // -> 'http://'\n     * // Get the protocol from a file path\n     * path.getProtocol('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     * @example\n     * ```ts\n     * // Convert a relative URL to an absolute path\n     * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n     * // -> 'http://example.com/assets/images/texture.png'\n     * ```\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     * @example\n     * ```ts\n     * // Normalize a path with relative segments\n     * path.normalize('http://www.example.com/foo/bar/../baz');\n     * // -> 'http://www.example.com/foo/baz'\n     * // Normalize a file path with relative segments\n     * path.normalize('C:\\\\Users\\\\User\\\\Documents\\\\..\\\\file.txt');\n     * // -> 'C:/Users/User/file.txt'\n     * ```\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     * @example\n     * ```ts\n     * // Check if a path is absolute\n     * path.isAbsolute('http://www.example.com/foo/bar');\n     * // -> true\n     * path.isAbsolute('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     * @example\n     * ```ts\n     * // Join multiple path segments\n     * path.join('assets', 'images', 'sprite.png');\n     * // -> 'assets/images/sprite.png'\n     * // Join with relative segments\n     * path.join('assets', 'images', '../textures', 'sprite.png');\n     * // -> 'assets/textures/sprite.png'\n     * ```\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the directory name of a path\n     * path.dirname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/foo/bar'\n     * // Get the directory name of a file path\n     * path.dirname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/Users/User/Documents'\n     * ```\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the root of a URL\n     * path.rootname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/'\n     * // Get the root of a file path\n     * path.rootname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     * @example\n     * ```ts\n     * // Get the basename of a URL\n     * path.basename('http://www.example.com/foo/bar/baz.png');\n     * // -> 'baz.png'\n     * // Get the basename of a file path\n     * path.basename('C:/Users/User/Documents/file.txt');\n     * // -> 'file.txt'\n     * ```\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the extension of a URL\n     * path.extname('http://www.example.com/foo/bar/baz.png');\n     * // -> '.png'\n     * // Get the extension of a file path\n     * path.extname('C:/Users/User/Documents/file.txt');\n     * // -> '.txt'\n     * ```\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Parse a URL\n     * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');\n     * // -> {\n     * //   root: 'http://www.example.com/',\n     * //   dir: 'http://www.example.com/foo/bar',\n     * //   base: 'baz.png',\n     * //   ext: '.png',\n     * //   name: 'baz'\n     * // }\n     * // Parse a file path\n     * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');\n     * // -> {\n     * //   root: 'C:/',\n     * //   dir: 'C:/Users/User/Documents',\n     * //   base: 'file.txt',\n     * //   ext: '.txt',\n     * //   name: 'file'\n     * // }\n     * ```\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n", "function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n * @internal\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n", "/**\n * Checks if the given value is an array.\n * @param item - The item to test\n * @internal\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n", "import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @category assets\n * @advanced\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let {\n                data,\n                format,\n                loadParser: userDefinedLoadParser,\n                parser: userDefinedParser,\n            } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            // Helper function to parse a URL string using registered parsers\n            const parseUrl = (url: string): ResolvedAsset =>\n            {\n                const parser = this._parsers.find((p) => p.test(url));\n\n                return {\n                    src: url,\n                    ...parser?.parse(url),\n                };\n            };\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        // first see if it contains any {} tags...\n                        formattedAsset = parseUrl(src);\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        if (src.loadParser || src.parser)\n                        {\n                            userDefinedLoadParser = src.loadParser ?? userDefinedLoadParser;\n                            userDefinedParser = src.parser ?? userDefinedParser;\n                        }\n\n                        formattedAsset = {\n                            ...parseUrl(src.src),\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser: userDefinedLoadParser,\n                        parser: userDefinedParser,\n                        progressSize: asset.progressSize,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[i];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        parser?: string,\n        format?: string,\n        progressSize?: number,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.parser = parser ?? formattedAsset.parser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n        if (progressSize !== undefined)\n        {\n            formattedAsset.progressSize = progressSize;\n        }\n\n        return formattedAsset;\n    }\n}\n\n/**\n * @param url\n * @internal\n */\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n", "/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n * @internal\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n", "import { Rectangle } from '../maths/shapes/Rectangle';\nimport { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Options for loading a spritesheet from an atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetOptions<S extends SpritesheetData = SpritesheetData>\n{\n    /** Reference to Texture */\n    texture: BindableTexture;\n    /** JSON data for the atlas. */\n    data: S;\n    /** The filename to consider when determining the resolution of the spritesheet. */\n    resolutionFilename?: string;\n    /**\n     * Prefix to add to texture names when adding to global TextureCache,\n     * using this option can be helpful if you have multiple texture atlases\n     * that share texture names and you need to disambiguate them.\n     */\n    cachePrefix?: string;\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @category assets\n * @standard\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /**\n     * The maximum number of Textures to build per process.\n     * @advanced\n     */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to the source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /** Prefix string to add to global cache */\n    public readonly cachePrefix: string;\n\n    /**\n     * @class\n     * @param options - Options to use when constructing a new Spritesheet.\n     */\n    constructor(options: SpritesheetOptions<S>);\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S);\n\n    constructor(optionsOrTexture: SpritesheetOptions<S> | BindableTexture, arg1?: S)\n    {\n        let options = optionsOrTexture as SpritesheetOptions<S>;\n\n        if ((optionsOrTexture as BindableTexture)?.source instanceof TextureSource)\n        {\n            options = {\n                texture: optionsOrTexture as BindableTexture,\n                data: arg1,\n            };\n        }\n        const { texture, data, cachePrefix = '' } = options;\n\n        this.cachePrefix = cachePrefix;\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parse spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Parse spritesheet from loaded data. This is done synchronously\n     * and is only suitable for smaller spritesheets (less than ~1000 frames)\n     * or may cause too many Texture within a single process. However, synchronous parsing may be\n     * more convenient since the called does not need to be asynchronous and is safe for\n     * small-to-medium sized spritesheets.\n     *\n     * Other than being synchronous, `parseSync` is otherwise identical to `.parse()`.\n     */\n    public parseSync(): Record<keyof S['frames'], Texture>\n    {\n        this._processFrames(0, true);\n        this._processAnimations();\n\n        return this.textures;\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     * @param processAll - if true will process all frames in a single batch, ignoring BATCH_SIZE - this\n     * is used for synchronous parsing.\n     */\n    private _processFrames(initialFrameIndex: number, processAll: boolean = false): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = processAll ? Infinity : Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n", "import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtensionAdvanced } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset } from '../assets/types';\nimport type { TextureSourceOptions } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { SpritesheetData } from './Spritesheet';\n\n/**\n * Interface for the JSON data structure of a spritesheet.\n * This is used to define the structure of the JSON file that describes a spritesheet.\n * It includes metadata about the spritesheet and the frames it contains.\n * @see {@link Spritesheet}\n * @see {@link SpritesheetData}\n * @category assets\n * @advanced\n */\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[`${asset.cachePrefix}${key}`] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *         textureOptions: {\n *             scaleMode: \"nearest\"\n *         }\n *     }\n * })\n * @type {AssetExtension}\n * @category assets\n * @advanced\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        extension: {\n            type: ExtensionType.ResolveParser,\n            name: 'resolveSpritesheet',\n        },\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string) =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        /** used for deprecation purposes */\n        name: 'spritesheetLoader',\n        id: 'spritesheet',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spritesheetLoader',\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{\n                texture?: Texture,\n                imageFilename?: string,\n                ignoreMultiPack?: boolean,\n                textureOptions?: TextureSourceOptions,\n                cachePrefix?: string,\n            }>,\n            loader?: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename, // if user need to use custom filename (not from jsonFile.meta.image)\n                textureOptions, // if user need to set texture options on texture\n                cachePrefix, // if user need to use custom cache prefix\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([{ src: imagePath, data: textureOptions }]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet({\n                texture: texture.source,\n                data: asset,\n                cachePrefix\n            });\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            textureOptions,\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    }\n} satisfies AssetExtensionAdvanced<SpriteSheetJson, Spritesheet, Spritesheet, Spritesheet>;\n", "import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n", "import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\n/**\n * @param mask\n * @param bounds\n * @param skipUpdateTransform\n * @internal\n */\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n", "import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\n/**\n * @param mask\n * @param bounds\n * @param localRoot\n * @internal\n */\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nfunction getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * AlphaMask is an effect that applies a mask to a container using the alpha channel of a sprite.\n * It can be used to create complex masking effects by using a sprite as the mask.\n * The mask can be inverted, and it can render the mask to a texture if the mask is not a sprite.\n * @category rendering\n * @advanced\n */\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public inverse: boolean = false;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        if (this.mask === null) return;\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        if (!this.inverse)\n        {\n            addMaskBounds(this.mask, bounds, skipUpdateTransform);\n        }\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * The ColorMask effect allows you to apply a color mask to the rendering process.\n * This can be useful for selectively rendering certain colors or for creating\n * effects based on color values.\n * @category rendering\n * @advanced\n */\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * A mask that uses the stencil buffer to clip the rendering of a container.\n * This is useful for complex masks that cannot be achieved with simple shapes.\n * It is more performant than using a `Graphics` mask, but requires WebGL support.\n * It is also useful for masking with `Container` objects that have complex shapes.\n * @category rendering\n * @advanced\n */\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        if (this.mask === null) return;\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n", "/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\n\nimport type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @category utils\n * @internal\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = DOMAdapter.get().createCanvas(1, 1);\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n", "// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of resource used for video textures.\n * This is typically an HTMLVideoElement.\n * @category rendering\n * @advanced\n */\nexport type VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @category rendering\n * @advanced\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * A texture source that uses a video as its resource.\n * It automatically resizes the texture based on the video dimensions.\n * It also provides methods to control playback and handle video events.\n * This class supports automatic loading, playback, and frame updates.\n * It can also handle cross-origin videos and provides options for looping, muting, and inline playback.\n * @category rendering\n * @advanced\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement);\n    }\n}\n", "import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\n/**\n * The type of resource or options that can be used to create a texture source.\n * This includes ImageResource, TextureSourceOptions, BufferSourceOptions, and CanvasSourceOptions.\n * @category rendering\n * @advanced\n */\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n * @category rendering\n * @internal\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\n/**\n * @param options\n * @param skipCache\n * @internal\n */\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n * @category utils\n * @internal\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n", "import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n", "import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\nuniform sampler2D uTexture;\\nvoid main() {\\n    finalColor = texture(uTexture, vTextureCoord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=passthrough.frag.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize: vec4<f32>,\\n  uInputPixel: vec4<f32>,\\n  uInputClamp: vec4<f32>,\\n  uOutputFrame: vec4<f32>,\\n  uGlobalFrame: vec4<f32>,\\n  uOutputTexture: vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv: vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition: vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n    return textureSample(uTexture, uSampler, uv);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=passthrough.wgsl.mjs.map\n", "import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './passthrough.frag';\nimport source from './passthrough.wgsl';\n\n/**\n * The PassthroughFilter passes the input data through without altering it.\n * It serves as a basic filter, performing no graphical alterations.\n * @category filters\n * @internal\n */\nexport class PassthroughFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: { source, entryPoint: 'mainVertex' },\n            fragment: { source, entryPoint: 'mainFragment' },\n            name: 'passthrough-filter'\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'passthrough-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n        });\n    }\n}\n", "/**\n * Check if a point is inside a triangle.\n * @param px - x coordinate of the point\n * @param py - y coordinate of the point\n * @param x1 - x coordinate of the first vertex of the triangle\n * @param y1 - y coordinate of the first vertex of the triangle\n * @param x2 - x coordinate of the second vertex of the triangle\n * @param y2 - y coordinate of the second vertex of the triangle\n * @param x3 - x coordinate of the third vertex of the triangle\n * @param y3 - y coordinate of the third vertex of the triangle\n * @returns `true` if the point is inside the triangle, `false` otherwise\n * @category maths\n * @internal\n */\nexport function pointInTriangle(\n    px: number, py: number,\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number\n)\n{\n    // Calculate vectors from point p to each vertex of the triangle\n    const v2x = x3 - x1;\n    const v2y = y3 - y1;\n    const v1x = x2 - x1;\n    const v1y = y2 - y1;\n    const v0x = px - x1;\n    const v0y = py - y1;\n\n    // Compute dot products\n    const dot00 = (v2x * v2x) + (v2y * v2y);\n    const dot01 = (v2x * v1x) + (v2y * v1y);\n    const dot02 = (v2x * v0x) + (v2y * v0y);\n    const dot11 = (v1x * v1x) + (v1y * v1y);\n    const dot12 = (v1x * v0x) + (v1y * v0y);\n\n    // Calculate barycentric coordinates\n    const invDenom = 1 / ((dot00 * dot11) - (dot01 * dot01));\n    const u = ((dot11 * dot02) - (dot01 * dot12)) * invDenom;\n    const v = ((dot00 * dot12) - (dot01 * dot02)) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0) && (v >= 0) && (u + v < 1);\n}\n", "import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape of a triangle via user defined coordinates.\n *\n * Used for creating triangular shapes and hit areas with three points (x,y), (x2,y2), (x3,y3).\n * Points are stored in counter-clockwise order.\n * @example\n * ```ts\n * // Basic triangle creation\n * const triangle = new Triangle(0, 0, 100, 0, 50, 50);\n * // Use as hit area\n * container.hitArea = new Triangle(0, 0, 100, 0, 50, 100);\n * // Check point containment\n * const isInside = triangle.contains(mouseX, mouseY);\n * // Get bounding box\n * const bounds = triangle.getBounds();\n * ```\n * @see {@link Rectangle} For rectangular shapes\n * @see {@link Circle} For circular shapes\n * @see {@link Polygon} For complex shapes\n * @category maths\n * @standard\n */\nexport class Triangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Triangle(0, 0, 100, 0, 50, 100);\n     * console.log(shape.type); // 'triangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'triangle') {\n     *     console.log(shape.x2, shape.y2);\n     * }\n     * ```\n     * @readonly\n     * @default 'triangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'triangle';\n\n    /**\n     * The X coordinate of the first point of the triangle.\n     * @example\n     * ```ts\n     * // Set first point x position\n     * const triangle = new Triangle();\n     * triangle.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the first point of the triangle.\n     * @example\n     * ```ts\n     * // Set first point y position\n     * const triangle = new Triangle();\n     * triangle.y = 100;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The X coordinate of the second point of the triangle.\n     * @example\n     * ```ts\n     * // Create horizontal line for second point\n     * const triangle = new Triangle(0, 0);\n     * triangle.x2 = triangle.x + 100; // 100 units to the right\n     * ```\n     * @default 0\n     */\n    public x2: number;\n\n    /**\n     * The Y coordinate of the second point of the triangle.\n     * @example\n     * ```ts\n     * // Create vertical line for second point\n     * const triangle = new Triangle(0, 0);\n     * triangle.y2 = triangle.y + 100; // 100 units down\n     * ```\n     * @default 0\n     */\n    public y2: number;\n\n    /**\n     * The X coordinate of the third point of the triangle.\n     * @example\n     * ```ts\n     * // Create equilateral triangle\n     * const triangle = new Triangle(0, 0, 100, 0);\n     * triangle.x3 = 50;  // Middle point x\n     * triangle.y3 = 86.6; // Height using sin(60)\n     * ```\n     * @default 0\n     */\n    public x3: number;\n\n    /**\n     * The Y coordinate of the third point of the triangle.\n     * @example\n     * ```ts\n     * // Create right triangle\n     * const triangle = new Triangle(0, 0, 100, 0);\n     * triangle.x3 = 0;   // Align with first point\n     * triangle.y3 = 100; // 100 units down\n     * ```\n     * @default 0\n     */\n    public y3: number;\n\n    /**\n     * @param x - The X coord of the first point.\n     * @param y - The Y coord of the first point.\n     * @param x2 - The X coord of the second point.\n     * @param y2 - The Y coord of the second point.\n     * @param x3 - The X coord of the third point.\n     * @param y3 - The Y coord of the third point.\n     */\n    constructor(x = 0, y = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.x3 = x3;\n        this.y3 = y3;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this triangle\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n     * const isInside = triangle.contains(25, 25); // true\n     * ```\n     * @remarks\n     * - Uses barycentric coordinate system\n     * - Works with any triangle shape\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Triangle\n     * @see {@link Triangle.strokeContains} For checking stroke intersection\n     * @see {@link Triangle.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        const s = ((this.x - this.x3) * (y - this.y3)) - ((this.y - this.y3) * (x - this.x3));\n        const t = ((this.x2 - this.x) * (y - this.y)) - ((this.y2 - this.y) * (x - this.x));\n\n        if ((s < 0) !== (t < 0) && s !== 0 && t !== 0) { return false; }\n\n        const d = ((this.x3 - this.x2) * (y - this.y2)) - ((this.y3 - this.y2) * (x - this.x2));\n\n        return d === 0 || (d < 0) === (s + t <= 0);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this triangle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n     * const isOnStroke = triangle.strokeContains(25, 25, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = triangle.strokeContains(25, 25, 4, 1);   // Inside\n     * const centerStroke = triangle.strokeContains(25, 25, 4, 0.5); // Centered\n     * const outerStroke = triangle.strokeContains(25, 25, 4, 0);   // Outside\n     * ```\n     * @param pointX - The X coordinate of the point to test\n     * @param pointY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param _alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this triangle's stroke\n     * @see {@link Triangle.contains} For checking fill containment\n     * @see {@link Triangle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(pointX: number, pointY: number, strokeWidth: number, _alignment: number = 0.5): boolean\n    {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;\n\n        const { x, x2, x3, y, y2, y3 } = this;\n\n        if (squaredDistanceToLineSegment(pointX, pointY, x, y, x2, y3) <= halfStrokeWidthSquared\n            || squaredDistanceToLineSegment(pointX, pointY, x2, y2, x3, y3) <= halfStrokeWidthSquared\n            || squaredDistanceToLineSegment(pointX, pointY, x3, y3, x, y) <= halfStrokeWidthSquared)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates a clone of this Triangle\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Triangle(0, 0, 100, 0, 50, 100);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.x3 = 75;\n     * modified.y3 = 150;\n     *\n     * // Verify independence\n     * console.log(original.y3);  // 100\n     * console.log(modified.y3);  // 150\n     * ```\n     * @returns A copy of the triangle\n     * @see {@link Triangle.copyFrom} For copying into existing triangle\n     * @see {@link Triangle.copyTo} For copying to another triangle\n     */\n    public clone(): Triangle\n    {\n        const triangle = new Triangle(\n            this.x,\n            this.y,\n            this.x2,\n            this.y2,\n            this.x3,\n            this.y3\n        );\n\n        return triangle;\n    }\n\n    /**\n     * Copies another triangle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Triangle(0, 0, 100, 0, 50, 100);\n     * const target = new Triangle();\n     * target.copyFrom(source);\n     *\n     * // Chain with other operations\n     * const triangle = new Triangle()\n     *     .copyFrom(source)\n     *     .getBounds(rect);\n     * ```\n     * @param triangle - The triangle to copy from\n     * @returns Returns itself\n     * @see {@link Triangle.copyTo} For copying to another triangle\n     * @see {@link Triangle.clone} For creating new triangle copy\n     */\n    public copyFrom(triangle: Triangle): this\n    {\n        this.x = triangle.x;\n        this.y = triangle.y;\n        this.x2 = triangle.x2;\n        this.y2 = triangle.y2;\n        this.x3 = triangle.x3;\n        this.y3 = triangle.y3;\n\n        return this;\n    }\n\n    /**\n     * Copies this triangle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Triangle(0, 0, 100, 0, 50, 100);\n     * const target = new Triangle();\n     * source.copyTo(target);\n     *\n     * // Chain with other operations\n     * const result = source\n     *     .copyTo(new Triangle())\n     *     .getBounds();\n     * ```\n     * @remarks\n     * - Updates target triangle values\n     * - Copies all point coordinates\n     * - Returns target for chaining\n     * - More efficient than clone()\n     * @param triangle - The triangle to copy to\n     * @returns Returns given parameter\n     * @see {@link Triangle.copyFrom} For copying from another triangle\n     * @see {@link Triangle.clone} For creating new triangle copy\n     */\n    public copyTo(triangle: Triangle): Triangle\n    {\n        triangle.copyFrom(this);\n\n        return triangle;\n    }\n\n    /**\n     * Returns the framing rectangle of the triangle as a Rectangle object\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n     * const bounds = triangle.getBounds();\n     * // bounds: x=0, y=0, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * triangle.getBounds(rect);\n     * ```\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Triangle.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const minX = Math.min(this.x, this.x2, this.x3);\n        const maxX = Math.max(this.x, this.x2, this.x3);\n        const minY = Math.min(this.y, this.y2, this.y3);\n        const maxY = Math.max(this.y, this.y2, this.y3);\n\n        out.x = minX;\n        out.y = minY;\n        out.width = maxX - minX;\n        out.height = maxY - minY;\n\n        return out;\n    }\n}\n", "import { Matrix } from '../../../maths';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * This matrix is used for calculations of the bounds for renderables placed inside cacheAsTexture render groups.\n * @ignore\n * @internal\n */\nconst tempProjectionMatrix: Matrix = new Matrix();\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const actualMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n\n        if (renderGroup?.isCachedAsTexture)\n        {\n            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform)\n                .append(renderable.worldTransform);\n        }\n        else if (renderGroup?._parentCacheAsTextureRenderGroup)\n        {\n            bounds.matrix = tempProjectionMatrix\n                .copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform)\n                .append(renderable.groupTransform);\n        }\n        else\n        {\n            bounds.matrix = renderable.worldTransform;\n        }\n\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = actualMatrix;\n\n    return bounds;\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { PassthroughFilter } from '../filters/defaults/passthrough/PassthroughFilter';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n\n    /** The first enabled filter index in the current filter list. */\n    public firstEnabledIndex = -1;\n\n    /** The last enabled filter index in the current filter list. */\n    public lastEnabledIndex = -1;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: WebGLRenderer | WebGPURenderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n    private _passthroughFilter: Filter;\n\n    constructor(renderer: WebGLRenderer | WebGPURenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        // If the filter is disabled, we still need to write something into the output surface.\n        // Render a pass-through (copy) so the pipeline remains intact.\n        const filterToApply = filter.enabled\n            ? filter\n            : this._getPassthroughFilter();\n\n        this._setupBindGroupsAndRender(filterToApply, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.orig.width,\n            1.0 / sprite.texture.orig.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        this._passthroughFilter?.destroy(true);\n        (this._passthroughFilter as null) = null;\n    }\n\n    private _getPassthroughFilter(): Filter\n    {\n        this._passthroughFilter ??= new PassthroughFilter();\n\n        return this._passthroughFilter;\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: WebGLRenderer | WebGPURenderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: WebGLRenderer | WebGPURenderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        // Very cryptic, but important(!) moment.\n        //\n        // If we try to pull texture from the pool for backTexture before inputTexture,\n        // it will be unbounded later by startRenderPass. It happens because in such a case - the current backTexture\n        // is actually inputTexture from the previous filter application (check `pop` method).\n        //\n        // So maintaining the order (inputTexture -> backTexture) helps us to prevent unwanted texture unbinding.\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n\n        // set the global uniforms to take into account the bounds offset required\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n        const firstEnabled = filterData.firstEnabledIndex;\n        const lastEnabled = filterData.lastEnabledIndex;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (firstEnabled === lastEnabled)\n        {\n            // render a single filter...\n            filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (let i = firstEnabled; i < lastEnabled; i++)\n            {\n                const filter = filters[i];\n\n                if (!filter.enabled) continue;\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n            // apply the last enabled filter to the output\n            filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n        // cache first/last enabled indices for later passes\n        let firstEnabledIndex = -1;\n        let lastEnabledIndex = -1;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // Only enabled filters should influence pipeline characteristics\n            if (!filter.enabled) continue;\n\n            if (firstEnabledIndex === -1) firstEnabledIndex = i;\n            lastEnabledIndex = i;\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = true;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n        filterData.firstEnabledIndex = firstEnabledIndex;\n        filterData.lastEnabledIndex = lastEnabledIndex;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 0)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n"],
  "mappings": "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",
  "names": ["LoaderParserPriority", "path", "src", "_Spritesheet", "video", "_VideoSource", "source"]
}
